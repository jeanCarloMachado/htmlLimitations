
Muitos das limitações dos jogos multiplataforma não são
problemas específicos dos jogos, mas aplicam-se a todos tipos
de software \autocite[p. 3]{currentStateCrossPlatform}. Alguns
problemas são inerentes da categoria multiplataforma \citet[p.
7 ]{viabilityBusinessApplications} afirma que é geralmente muito
mais complexo obter aparência nativa, funcionalidade e performance
em aplicações multiplataforma. Outros problemas derivam-se dos
dispositivos ou da tecnologia atual.

Pode não ser trivial distinguir limitações de
problemas. Uma forma de interpretar limitações é como sendo problemas
que impedem algo seja feito. Para ajudar na distinção os
problemas encontrados foram descritos como contornáveis ou não.

A abaixo constam os problemas e limitações do HTML5, aplicáveis,
mesmo que não exclusivamente, aos jogos encontrados durante a pesquisa
e concepção do protótipo. Quando possível, buscou-se apresentar
as limitações na mesma ordem das tecnologias estudadas na revisão
bibliográfica. Não obstante, algumas limitaçãos foram tratadas em
partes separadas visto que se aplicam a várias das tecnologias da
Web. Para melhor organizá-las junto ao texto, foram adicionados
códigos as limitações que seguem o seguinte padrão: LMT + número da
limitação.

\section{HTML}

\noindent\citet{crossPlatformMobileGame} afirma que (\limitation{multipleTesting}):
\begin{quote}
Enquanto o HTML é desenvolvido muitas das funcionalidades
disponibilizadas são testadas em um pequeno conjunto de navegadores
para um pequeno conjunto de versões. Isso acarreta em suporte
inconsistente. A forma mais segura de garantir suporte é testando em
todas as versões alvo, entretanto essa solução não é prática.
\end{quote}

Este não é um problema exclusivo dos navegadores. Segundo
\citet{chromeWebView} da versão 4.4 do Android em diante a WebView
mudou de um projeto local para utilizar o Chromium. Entretanto, grande
parcela dos usuários Android ainda utilizam o sistema antigo o que
força os desenvolvedores suportarem ambas as versões. É razoável
afirmar que para o início de 2016 um terço dos usuários de Android
ainda utilizem a versão antiga da WebView \autocite{chromeWebView}.

O Crosswalk é uma tecnologia que pode resolver parcialmente o problema
de suporte de funcionalidades em diversas versões de dispositivos.
O Crosswalk funciona disponibilizando, juntamente com a aplicação,
uma versão recente do Chromium que será responsável por rodar a
aplicação. Desse modo todos os dispositivos que utilizam o pacote
gerado pelo Crosswalk vão rodar na mesma versão de navegador. Não
obstante, o Crosswalk só é suportado para plataforma Android \footnote{Na
seção \ref{crosswalk} dos Apêndices o Crosswalk é tratado com mais
detalhes}.

\section{CSS}

É muito custoso desenvolver interfaces que pareçam nativas
para cada dispositivo sem a utilização de plugins e outras
ferramentas auxiliares. No protótipo foi utilizada uma estilização
simples a qual pode ser interessante na Web. Conquanto, nos
dispositivos móveis, o layout criado para o jogo é muito diferente
da experiência normal destes aparelhos. Sendo que cada sistema
operacional conta com regras próprias para definir a experiência
do usuário \footnote{ O Android utiliza o projeto Material design
\url{https://www.google.com/design/spec/material-design} como base
para suas regras de como construir interfaces. Já o IOS utiliza um
conjunto de regras próprias que podem ser encontradas neste endereço
\url{https://developer.apple.com/library/ios/documentation/UserExperienc
e/Conceptual/MobileHIG/}} (\limitation{hardToBuildGuis}).

Uma solução para este problema é utilizar frameworks como o jQuery
Mobile e Kendo UI Mobile \footnote{Mais informações sobre o Kendo UI
e jQuery Mobile podem ser encontradas nos apêndices}. Estes frameworks
permitem criar elementos típicos de interfaces mobile como listas
com scroll, botões e transições com uma aparência nativa de forma
relativamente fácil \autocite{publishHtml5}.

Em alguns casos o tamanho das telas pode ser um fator limitante,
como por exemplo em jogos de estratégia. Estes jogos geralmente
necessitam mostrar uma vasta quantidade de informações, neste
contexto, jogadores com telas menores podem sair em desvantagem
(\limitation{differentScreenSizesMayPutSomeUsersInDisvantage}).
Em termos gerais, pode-se mitigar este problema utilizando design
responsivo. Na perspectiva do desenvolvedor, pode-se lidar com
múltiplos tamanhos de tela trabalhando com tamanhos relativos via
CSS. Todavia há casos, como o dos botões de certo e errado
do protótipo, em que a proporções ficam exageradas. Nestas ocasiões,
utilizar controles como o \textit{max-width} e \textit{min-width} é uma
solução conveniente. No protótipo, os botões de certo e errado tem uma proporção
de 40\% da tela. Em dispositivos móveis este valor é sensato, mas
em desktops com grandes resoluções a largura fica exagerada. Para
resolver este problema foi configurado via CSS que a largura dos botões
tenham no máximo 300 pixels via regra \textit{max-width}.

Outro fator problemático do CSS é a presença de prefixos
(\limitation{cssPrefixes}). Tecnologias experimentais do CSS geralmente
levam o nome do distribuidor como prefixo da propriedade. Utilizar as
mesmas regras em CSS com prefixos diferentes para suportar diversos
motores de renderização é um processo entediante e propenso à
duplicação e erros. A biblioteca \textit{-prefix-free} é uma
possível solução para este problema, detectando automaticamente
quando prefixos são necessários e adicionado-os em tempo de execução
\footnote{Mais informações sobre a biblioteca pode ser encontradas nos
apêndices}.

\section{JavaScript}

O JavaScript, por ser uma linguagem desenvolvida por consenso,
tem um ciclo de vida de atualizações demorado; pois necessita
que todos os consumidores da especificação entrem em acordo
(\limitation{jsSpecificationCycle}). Com a especificação
pronta, outra fase demorada é a adoção das tecnologias
nos navegadores (\limitation{jsImplementaionCycle}). O site
\url{https://kangax.github.io/compat-table/es6/} contém uma lista do
suporte aos recursos do ECMAScript nos motores JavaScript. Através
desta lista pode-se observar que as novas funcionalidades do ECMAScript
6 contém pobre suporte na grande maioria dos motores, especialmente
quando referente a funcionalidade de subclasses.

Por ser uma linguagem interpretada, erros tem de descobertos rodando a
aplicação (\limitation{discoverErrorsWhileRunning}). Alternativamente,
se JavaScript fosse compilado, vários problemas poderiam ser capturados
e informações úteis reveladas antes de se testar \autocite[p.
12]{viabilityBusinessApplications}. Uma forma de solucionar 
este problema é utilizando alguma linguagem compilada através de 
Web Assembly.

Arquivos JavaScript geralmente necessitam ser minificados, reunidos e
ofuscados. Muitas vezes esses processos precisam ser executadas durante
o desenvolvimento, e sem a utilização de automatizadores como o
Grunt Watch, o processo torna-se entediante bem como propenso a erros
(\limitation{complexBuild}).

Segundo \citet{htmlResearchJournal}, um problema do JavaScript é que
não é possível transferir métodos de objetos através de sistemas
via WebSockets, somente dados (\limitation{passCompleteObjectsOnSockets}).
Uma forma de contornar este problema é utilizar funções para
converter os dados em objetos em cada ponta do processamento mas isto
adiciona complexidade ao software.

\citet{howBrowsersWork} cita à respeito de scripts requerendo informações de
estilo durante o processo de parse. Se o estilo ainda não foi carregado
o script vai utilizar informações erradas, causando uma série de
problemas (\limitation{runScriptsOnlyOnTheEndOfTheProcessment}). Pode-se
contornar este problema executando scripts exclusivamente ao final da
renderização do HTML.

Por ser uma linguagem orientada a protótipos, JavaScript dá grande
poder e flexibilidade para os desenvolvedores. Não obstante, um
possível problema desta característica é quanto a manutenibilidade de
código (\limitation{harderToDoMaintainence}). \citet{html5Tradeoffs} afirma que:

\begin{quote}
A flexibilidade de manutenção de código em JavaScript é muito
dependente do expertise da pessoa que está escrevendo o código.
Escrever código "sustentável" em JavaScript é mais difícil se
comparado com Java ou C\# mas, aplicando bons padrões de design, é bem
possível escrever bom JavaScript.
\end{quote}

Além de bons padrões de design, outra forma de minimizar
os problemas de manutenibilidade de JavaScript é utilizando
guias de estilo de escrita. \citet{jsStyleGuide} afirma que
quando não existem padrões de escrita todos acabam escrevendo
código que apenas os autores conseguem entender. O endereço
\url{http://noeticforce.com/best-JavaScript-style-guide-for-maintainable
-code} contém um comparativo entre os guias de estilo mais comuns para
JavaScript.

\subsection{Sistema de tipos}

O sistema de tipos do JavaScript também é problemático. Erros
numéricos resultam no valor NaN (\textit{not a number}). Sendo que
todas as operações com NaN como operadores irão retornar outro
NaN. Isso torna a depuração de erros desnecessariamente complexa
\autocite{html5mostwanted} (\limitation{NANPropagation}). Uma saída
para este problema é checar constantemente os tipos de forma a
assegurar-se que eles continuam válidos. Entanto, este processo
pode se tornar burocrático e uma forma adicional de criar erros.

Outra limitação do JavaScript é quanto a checagem de tipos. Ao
testar o tipo de uma variável vazia com a função \textit{typeof}
o JavaScript retorna como se a variável fosse um objeto
(\limitation{typesCheck}).

\begin{figure}[H]
\centering
\begin{verbatim}
function is(type, object) {
    type = type[0].toUpperCase + type.slice(1);
    return Object.prototype.toString.call(object)
    === '[object ]' +  type + ']';
}
\end{verbatim}
\caption{Função para testar tipos que funciona como o esperado.}
\label{fig:fixJSTypes}
\source{\url{http://www.slideshare.net/fdaciuk/javascript-secrets-front-in-floripa-2015}}
\end{figure}

A figura \ref{fig:fixJSTypes} demonstra uma solução possível para
remediar o problema dos testes de tipos em JavaScript. A diferença
desta função é que ela converte a variável que se está testando
para sua representação em texto a qual contém o nome do tipo escrito
por extenso - utilizando-se deste valor pode-se deduzir o tipo da
variável corretamente.

\subsection{Performance}

Apesar da performance ter notavelmente melhorado, ainda é geralmente
menos eficiente produzir animações em JavaScript do que utilizando
transições e animações do CSS, que por sua vez são mais
otimizados e acelerados via hardware \autocite{html5mostwanted}
(\limitation{JSanimations}). O Web Assembly pode resolver este problema,
substituindo o JavaScript para os casos onde grande performance é
necessária. Mas para isso o Web Assembly precisa evoluir em sua
especificação e implementações.

\subsection{Fullscreen}

Não existe forma padronizada de detectar se uma aplicação
está em tela cheia ou não através de JavaScript
(\limitation{fullscreenManagement}). O IOS suporta a variável
\textit{navigator.standalone } para identificar se a aplicação está
em tela cheia. \citet{homescreenwebapps} recomenda a utilização do
trecho de código para determinar se está em modo tela cheia para
os demais navegadores. Não obstante, não existe solução oficial,
tanto para detectar quanto para manipular Fullscreen. O argumento da
não possibilidade de manipulação é que isso pode ser um problema de
segurança para o usuário.

\begin{figure}[H]
\centering
\begin{verbatim}
navigator.standalone = navigator.standalone 
|| (screen.height-document.documentElement.clientHeight<40)
\end{verbatim}
\caption{Teste de tela cheia}
\label{fig:fixJSTypes}
\source{\url{http://www.mobilexweb.com/blog/home-screen-web-apps-android-chrome-31}}
\end{figure}

\section{SVG}

Uma das grandes vantagens do SVG é que é definido via linguagem
de marcação e se integra bem com as demais tecnologias da Web.
Contudo, isso também implica em problemas de performance para
arquivos muito grandes pois os elementos são manipulados via DOM
(\limitation{svgDomPerformance}). Segundo \citet{html5mostwanted} a
grande desvantagem do SVG é que quão maior o documento mais lenta a
renderização.

Controle refinado sobre posicionamento também é um problema do SVG.
\citet{html5mostwanted} afirma que um aspecto negativo do SVG é que
é muito difícil atingir a perfeição na posição dos pixels,
por ser uma linguagem vetorizada (\limitation{svgRefinendControl}).
Essa característica acaba limitando a aplicabilidade do SVG como
renderizador de jogos para os casos não muito complexos, onde posicionamento
não seja uma fator crucial.

\section{Canvas}

Segundo \autocite{html5mostwanted}, os aspectos negativos do canvas é
que a performance varia de plataformas para plataformas e não existe
implementação nativa para animações.

\subsection{Performance}

O problema de performance (\limitation{canvasPerformance}) pode
ser parcialmente remediado com o FastCanvas. FastCanvas é uma
implementação nativa em C++ do canvas para Android que roda
separadamente do JavaScript. Devidas as características acima citadas
FastCanvas é substancialmente mais rápido do que a tag canvas para
navegadores Android. Todavia, o FastCanvas não suporta a
especificação do canvas completamente, e existem algumas diferenças no
comportamento entre o canvas original e o FastCanvas.

\subsection{Integrações}

A implementação de animações de fato não existe no canvas
(\limitation{noCanvasAnimation}). Similarmente carece-se de integração
com as demais tecnologias da Web (\limitation{noCanvasIntegration}).
Os desenhos do canvas não podem ser acessados via DOM nem serem
manipulados via CSS. Todas as modificações necessárias devem ser
feitas através de JavaScript. No protótipo, especificamente na classe
\textit{Countdown}, foi necessário adicionar regras de estilo via
JavaScript para a interação com o canvas ficar completa.

CSS já conta com definições quanto a animações e a manipulação de
elementos do canvas através do DOM facilitaria uma gama de situações.
Por exemplo, seria possível utilizar os eventos do DOM para capturar
interações do usuário através de elementos utilizados no canvas.
Se um retângulo fosse clicado o evento seria lançado a partir dele.
Controle similar é implementado atualmente acessando as coordenadas
do canvas onde uma interação aconteceu e fazendo o processamento com
aquela determinada área.

Felizmente a integração entre o canvas e as demais tecnologias da
Web está começando a acontecer. A interoperabilidade entre o Path2D
do canvas e a notação SVG é uma iniciativa na direção correta,
tornando ambas tecnologias cada vez mais relevantes e dinâmicas.

Outra característica peculiar, descoberta durante o desenvolvimento
do protótipo, é que o Canvas pode gerar resultados inesperados se
seus tamanhos de elemento e tela diferirem de formas específicas. Em
suma, existem dois tamanhos, o tamanho do elemento e da superfície de
desenho. Quando o tamanho do elemento é maior do que o da superfície
de desenho do documento escala a superfície de desenho para preencher o
elemento, o que pode gerar resultados inesperados.

\section{WebGL}

Como a especificação do WebGL é baseada na versão otimizada
para dispositivos móveis do OpenGL não é possível utilizar
muitos recursos especiais disponíveis para os ambientes desktop
(\limitation{noWebglDesktopFunctions}). Como a definição de caminhos
com a função \textit{glBegin} e a utilização de pontos flutuantes
para calcular coordenadas de vértices \autocite{esVsGl}. Em outras
palavras, a especificação do WebGL é cortada por baixo. Visto que
alguns dispositivos não teriam performance utilizando estes recursos,
nenhum dispositivo que use WebGL pode os desfrutar.

Segundo \citet{html5mostwanted} um dos problemas do WebGL é sua alta
curva de aprendizagem e o fato de não ter suporte para o Internet
Explorer. Entretanto, o suporte foi adicionado na última versão do
Internet Explorer (11). Infelizmente a dificuldade de utilização
ainda persiste (\limitation{hardToUseWebGL}), forçando a maioria dos
desenvolvedores a utilizarem abstrações criadas por bibliotecas de
terceiros \footnote{Os apendices contém algumas destas bibliotecas como
o tree.js}.

É importante também ressaltar que o WebGL não se comporta de
maneira simétrica nos navegadores que implementam a especificação.
Pode haver diferenças substanciais de performance em plataformas
diferentes e em navegadores diferentes. Para ver um programa em WebGL
é necessário um navegador recente, uma placa gráfica recente e um
sistema operacional que suporte a tecnologia \autocite{html5mostwanted}
(\limitation{limitedToRecentThingsWebgl}). Existe também uma lista de
placas gráficas com \textit{drivers} bloqueados por não funcionarem
corretamente no Firefox \autocite[p.42]{3daps}.

Além dos problemas citados, o suporte a especificação ainda é
incompleto em vários navegadores (\limitation{incompleteSupportWebgl}).
CocoonJS é uma aplicativo híbrido que preenche a fraca implementação
de WebGL nos dispositivos móveis possibilitando se desenvolver em
WebGL. CocoonJS conta com suporte a dispositivos legados à partir do
Android 2.3 e IPhone 5.

\subsection{Áudio}

Segundo \citet{html5mostwanted} a limitação do elemento de áudio no
HTML5 é que seu propósito é para executar apenas um som, como o som
de fundo dentro de um jogo. Não sendo adequada para efeitos sonoros
ou necessidades flexíveis de áudio.

Durante a concepção do protótipo foi utilizada a API de áudio, devido
sua maior flexibilidade. Infelizmente algumas vezes o som não é
executado ou demora até executar de modo de o que é executado ao mesmo
tempo que o próximo som (\limitation{soundAPIConflicts}).

A experimentação do protótipo, relativo a API de áudio, confirmou
as indicações de \citet{html5mostwanted} que afirma que a API de som
é boa se você deseja apenas tocar alguma música, mas se você está
lançando eventos em um jogo ela ainda é problemática.

Outro problema de áudio em HTML5 são os codecs. Alguns
navegadores favorecem formatos OGG (vorbis) e outros favorecem o
MP3 (\limitation{bestAudioCompressionNotSupportedByAllBrowsers}).
No protótipo foi utilizado o MP3, que apesar de não bem visto por
muitos navegadores, é suportado como uma forma de mínimo múltiplo
comum. Todavia, segundo \citet{opus}, MP3 é um codec antigo e existem
alternativas mais adequadas para a Web como o codec Opus, que oferece
uma melhor relação entre taxa de compressão e qualidade.

Além das restrições de codecs de áudio nos produtos da Apple,
áudio, especificamente no Safari do IOS, contém alguns problemas
específicos. Por exemplo, não é possível trocar o volume
através de JavaScript também não é possível tocar mais de um
som ou vídeo simultaneamente \autocite{unsolvedMediaHtmlIssues}
(\limitation{limitedMultimidiaControlOnSafari}).

\subsection{Vídeo}

O suporte a vídeo, apesar de estar melhorando, ainda é rudimentar.
No Silverlight existem uma coleção de possibilidades como aplicar
shaders diretamente no vídeo \autocite[p. 8]{researchOnHtml}
(\limitation{noEffectsOnVideo}). Não obstante, efeito similar
a shaders em vídeo é atingido através da importação de
vídeo dentro de um contexto WebGL \footnote{O endereço
\url{https://developer.Mozilla.org/en-US/docs/Web/API/WebGL_API/Tutoria
l/Animating_textures_in_WebGL} contém exemplos de como utilizar vídeos
em um contexto WebGL} ou canvas 2D.

Também não é possível controlar a entrada em tela cheia através de
scripts (\limitation{videoFullscreenControl}) pois é considerado uma
violação de segurança. Entretanto, os navegadores tem a opção de
deixar os usuários escolherem ver vídeos em tela cheia através de
controles adicionais \autocite[p. 68]{proHtml5}.

Assim como áudio, o elemento \textit{video} sofre com problemas de
codecs (\limitation{videoCodecs}), segundo \citet{html5Tradeoffs}:
\begin{quote}
O maior problema com as API's de áudio e de vídeo do HTML5 é
a disputa entre os codecs dos navegadores. Por exemplo, Mozilla e
Opera suportam Theora, já o Safari suporta H.264 que também é
suportado pelo IE9. Ambos, Iphone e Android suportam H.264 em seus
navegadores. A W3C recomenda OggVorbis e OggTheora para áudio e vídeo
respectivamente.
\end{quote}

O Safari do IOS também contém problemas exclusivos de vídeo. Segundo
\citet{unsolvedMediaHtmlIssues} não é possível capturar frames de
vídeo usando o método \textit{drawImage} do canvas. Também não é
possível pré carregar arquivos de vídeo sem iteração do usuário
(\limitation{safariVideoMissingControlAndCanvas}).

Para os raros casos onde o suporte a vídeo não existe,
como no Opera Mini, o projeto \textit{Vídeo for Everybody}
\url{http://camendesign.com/code/video_for_everybody} é um polyfill que
recorre à flash para apresentar o conteúdo.

\section{Armazenamento}

Não existe opção oficial que permita a utilização de tecnologias
SQL para Frontend (\limitation{noSqlSupport}). O WebSQL foi uma
tentativa nesta direção mas, visto que não continha mais de uma
implementação, foi descontinuado. Apesar de depreciado o Web SQL ainda
é usado por muitos desenvolvedores e mantido por alguns navegadores,
todavia, os desenvolvedores que procedem desta maneira ficam à mercê
dos caprichos dos navegadores não podendo contar com a força de um
órgão regulador para suportar a tecnologia. SQL seria interessante pois
muitos desenvolvedores tem experiência com este tipo de tecnologia e
por SQL permitir filtragem e correlacionamento de dados de uma forma
flexível e poderosa.

Uma outra característica da Web que pode afetar negativamente
aplicações que utilizam o persistência local de dados é que o
usuário pode configurar o navegador para não aceitar armazenamento
para determinado domínio, possivelmente comprometendo a experiência
de determinada aplicação. Esta característica é muito diferente do
que geralmente é oferecido em aplicações desktop, onde a aplicação
determina o que precisa usar sem necessitar de consenso do usuário, que
por sua vez pode escolher usar os não a aplicação.

\subsection{Web Storage}

Muitos navegadores não permitem armazenar mais de 5MB por domínio
em Web Storage, apesar da especificação permitir fazê-lo
\autocite{gameAssetManagement} (\limitation{webStorageLimit}). Também
não é possível saber quanto espaço já foi consumido pelo Web
Storage (\limitation{webStorageQueryLimit}).

Outra limitação do Web Storage é que todas as informações são
guardadas no formato texto (\limitation{webStorageStringOnly}). Isso
força a converter os valores toda a vez que algo for armazenado ou
recuperado \autocite{gameAssetManagement}. No protótipo isso não foi
problemático pois não existe grande manipulação sobre os dados. Mas
no caso de jogos mais complexos esta característica do Web Storage pode
ser uma limitação substancial.

\subsection{IndexedDB}

Apesar de ser desenvolvido com objetivo de ser uma solução para
todas as necessidades de armazenamento no Frontend IndexedDB ainda
sofre algumas limitações. O comportamento em abas anônimas não
está especificado e os resultados também variam de navegador para
navegador (\limitation{indexedDbAnonymousBehaviour}). Também não é
possível realizar buscas em textos, algo similar ao \textit{LIKE} do
SQL (\limitation{indexedDbNoLike}).

Outro problema encontrado durante a pesquisa é que no Firefox existe
uma pequena probabilidade de os dados se perderem. Isso se dá pois a
API não espera confirmação do sistema operacional para considerar
um dado válido, essa foi uma escolha em detrimento de performance.
Este comportamento pode ser modificado mas é a forma padrão de
funcionamento e os desenvolvedores podem não estar considerando esta
peculiaridade.

\section{Offline}

Nos arquivos de cache via manifestos, quando o download falha, o
navegador emite um evento mas não há indicação de qual problema
aconteceu (\limitation{noErrorMessagesOffline}). Isso pode tornar a
depuração ainda mais complicada que o usual \autocite{diveIntohtml}.
Este problema aconteceu durante o desenvolvimento do protótipo e foi
trabalhoso de depurar até descobrir que um arquivo estava faltando,
e qual especificamente. Uma coleção de códigos de erro e suas
respectivas mensagens na especificação poderia solucionar este
problema.

Os itens da palavra chave \textit{NETWORK:} apresentam um
comportamento não intuitivo. Arquivos de rede que não
são declarados ali não poderão ser consumidos uma vez
que exista cache na aplicação. O exemplo neste endereço
\url{http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-net
work/} demonstra este comportamento. Segundo \citet{gameAssetManagement}
a especificação define que se um arquivo não for listado em alguma
das seções do cache então o arquivo não estará disponível de
qualquer forma para a aplicação.

\section{Orientação}

Visto que a especificação de orientação não está pronta,
o suporte está longe de completo. Da mesma forma, existem
diferenças substanciais nas implementações entre os navegadores
(\limitation{orientationIsntReady}). Por exemplo, o Firefox e Google
Chrome não manipulam ângulos da mesma forma. Outrossim, alguns
eixos se comportam de maneiras opostas \autocite{mdnOrientation}. O
polyfill \textit{gyronorm.js} é uma tentativa de normalizar o uso de
dados de orientação nos navegadores que pode ser utilizada até a
especificação e os navegadores evoluírem.

\section{Detecção de recursos}

\citet{diveIntohtml} cita que (\limitation{checkResourcesOnlyOnJavascrit}):
\begin{quote}
Grande parte da detecção de funcionalidades é feita através de
JavaScript, isso força os desenvolvedores a criarem pelo menos parte da
marcação em JavaScript, isso pode ser um fator limitante para o uso
generalizado de HTML5.
\end{quote}

Para resolver este problema, o ideal seria que cada tecnologia contasse
com formas de detectar as funcionalidades que comporta. Não obstante,
este tipo de mecanismo conflita com outros princípios da Web. Pelo
fato de o HTML uma linguagem fundamentada exclusivamente em marcação
e estrutura, adicionar estruturas de controle não é uma alternativa
viável.

\section{Debug}

Com o depurador remoto do Google Chrome foi observado uma falta de
sincronia nas taxas de atualização da imagem no computador. Os
efeitos do CSS não são bem apresentados sendo provavelmente difícil
depurar animações. Em alguns casos quando a tela foi modificada
substancialmente (com nas mudanças de tela) a mudança de estado no
computador levou vários segundos para ser atualizada.

Outro problema do depurar do Chrome é que não existe inspetor
nativo de canvas. O inspetor de embutido do Google Chrome foi
removido pois continha comportamentos indesejáveis para os
desenvolvedores do navegador \autocite{canvasinspector}. Os
desenvolvedores mencionaram criar uma extensão para a funcionalidade
mas até o tempo de desenvolvimento deste trabalho não havia
nenhuma disponível. A única alternativa viável até o momento é
utilizar uma versão antiga do Chromium. O Firefox introduziu uma
ferramenta de inspeção para o canvas 2D em uma Conferência de
desenvolvimento de jogos em São Francisco em 2014, mas até então a
tecnologia não apareceu no navegador \autocite{firefoxCanvasDebug}.
Atualmente a área de ferramentas para depuração do canvas
2D está parcialmente comprometida por não existir um plugin
de terceiro onipresente nos navegadores como o WebGl Inspector
(\limitation{noCanvas2DIsnpectorOnipresent}).

O projeto Canvas Interceptor é uma iniciativa para preencher
esta demanda permitindo capturar alguns eventos do contexto 2D e
tirar \textit{snapshoots} dos passos da renderização do canvas.
Entretanto, o projeto requer que o desenvolvedor inclua um arquivo
JavaScript em seu projeto e inicialize o depurador dentro do código,
se tornando uma saída mais custosa do que um inspetor integrado
no navegador ou via extensão \footnote{Mais informações sobre o
projeto Canvas Interceptor podem ser encontradas no seguinte endereço
\url{https://github.com/Rob--W/canvas-interceptor}}.

\section{Entrada de comandos}

\citet[p. 9]{aSeriousContender} cita que: fazer scroll juntamente
com gestos de ações similares é uma área onde o HTML ainda é
fraco (\limitation{multiTouch}). Para contornar este problema pode-se utilizar bibliotecas como o
iScroll, TouchScroll, GloveBox, Sencha, jQuery Mobile, entre outros.

\subsection{Gamepad}

A forma de gerenciar a conexão de Gamepads é diferente entre o Firefox
e Google Chrome. No Firefox é lançado um evento toda a vez que o
Gamepad é desconectado, já no Google Chrome é necessário verificar
um vetor de gamepads pela existência do objeto de tempos em tempos
\autocite{gamepad} (\limitation{gamepadObject}). Este problema é
reflexo da especificação ainda incompleta e força os desenvolvedores
a duplicarem a mesma atividade no código.

\section{Disponibilização}

Durante o desenvolvimento notou-se que o serviço PhoneGap Build não
contém a última versão do PhoneGap e não é possível utilizar
plugins através dele. Embora no protótipo isso não tenha sido um
problema, em projetos maiores estes tipos de requerimentos podem ser
essenciais.

Outra limitação de disponibilização, neste caso para aplicativos
Web puros, é que a possibilidade de adicionar aplicativos a área
de trabalho está disponível apenas para o Safari e Google Chrome
(\limitation{desktopIcon}). Este tipo de possibilidade é importante por
gerar uma experiência similar a nativa em dispositivos móveis.

A disponibilização via mercado do IOS também é problemática. Toda
a aplicação precisa ter seu conteúdo revisado a cada nova versão,
e essa revisão é demorada e contém uma fila de espera substancial.
Se for comparado a muitos processos de disponibilização automatizados na
Web, disponibilizar aplicações para o IOS é rudimentar.

\subsection{Monetização}

Outro aspecto que pode ser limitante para aplicações Web é
sua forma de monetização. É muitas vezes difícil encontrar
oportunidades financeiras em jogos para navegador, visto que não
se pode vender pacotes para o usuário baixar \autocite[p. 44]{gameCommunities}
(\limitation{monetizationDifferent}).

Dado este este problema, desenvolvedores são muitas vezes forçados
a criar formas alternativas de lucro. A monetização de aplicativos
Web é geralmente feita através de propagandas \autocite[p.
44]{gameCommunities}. Outra saída é a venda de recursos extra,
\citet[p. 44]{gameCommunities} afirma que a venda de moeda virtual é
uma forma comum de monetização em jogos.

De outra forma, jogos Web podem ser integrados pelos desenvolvedores
a sistemas de pagamento, mas possivelmente aumentado a complexidade
da aplicação. Ou se optarem pela arquitetura híbrida, podem ser
integrados a algum mercado como o do Android ou da Apple.

\section{Outras Limitações}

\citet{html5Tradeoffs} menciona algumas limitações em uma âmbito HTML em geral:

\begin{quote}
Não podemos mudar a imagem de fundo do dispositivo, ou adicionar toques
etc. Similarmente, existem muitas API's de nuvem como os serviços
de impressão do ICloud ou Google Cloud que estão disponíveis para
aplicações nativas mas não para HTML5. Outros serviços utilitários
como o C2DM do Google que está disponível para desenvolvedores Android
para utilizar serviços de \textit{push} também não estão disponíveis
para o HTML5.
\end{quote}


\section{Revisão das Limitações}

O quadro \ref{table:technologies} é um comparativo das
tecnologias pesquisadas e seu suporte. As
informações de suporte foram extraídas do site \textit{Can I Use} e
os navegadores populares em questão são: Internet Explorer (11), Edge
(13), Firefox (43), Google Chorme (47), Safari (9) e Opera (34).

\begin{table}
\begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|  }
\hline
Tecnologia & Suporte nas últimas versões estáveis dos navegadores populares & Polyfills disponíveis  para versões antigas \\ \hline
Canvas & Sim & Sim \\ \hline
SVG & Sim & Sim \\ \hline
Gamepad & Não & Sim \\ \hline
WebGL & Parcial & Sim \\ \hline
WebSockets & Sim & Sim \\ \hline
IndexedDB & Parcial & Sim \\ \hline
WebCL & Não & Não \\ \hline
WebVR & Não & Não \\ \hline
WebAssembly & Não & Sim \\ \hline
Tag áudio & Sim & Sim \\ \hline
Áudio API & Não & Sim \\ \hline
Vídeo & Não & Sim \\ \hline
Prefetch & Não & Sim \\ \hline
Web Animations & Não & Sim \\ \hline
WebWorkers & Sim & Sim\\ \hline
\end{tabular}
\label{table:technologies}
\caption{Tecnologias dos jogos e seu suporte}
\end{table}

Com este comparativo fica visível que, mesmo em alguns casos não
existindo suporte nativo ou ele sendo incompleto e com limitações,
na vasta maioria dos casos, é possível utilizar tecnologias da Web
direcionadas para o desenvolvimento de jogos.

\newpage

O quadro \ref{table:technologies} é um resumo das limitações mais relevantes 
encontradas e se as mesmas podem ser contornadas ou não.
\begin{longtable}{| p{.09\textwidth} | p{.53\textwidth}| p{.11\textwidth} |}
\hline
Código & Descrição & Existe solução ou contorno? \\ \hline
\Cref{limitation:multipleTesting} & Para garantir que algo de fato funcione é necessário testar em múltiplos dispositivos & Parcial \\ \hline
\Cref{limitation:hardToBuildGuis} & Dificuldade em construir interfaces nativas para os diversos dispositivos & Sim \\ \hline
\Cref{limitation:differentScreenSizesMayPutSomeUsersInDisvantage} &  Desvantagem  para alguns jogadores devido ao tamanho da tela  & Parcial \\ \hline
\Cref{limitation:cssPrefixes} & Tecnologias equivalentes em fase experimental levam o prefixo do motor de renderização  & Sim \\ \hline
\Cref{limitation:jsSpecificationCycle} & Demora para chegar a um consenso na criação de especificações do JavaScript & Não \\ \hline
\Cref{limitation:jsImplementaionCycle} & Demora para implementar novas especificações do JavaScript & Sim \\ \hline
\Cref{limitation:discoverErrorsWhileRunning} & Por ser interpretado, erros no código JavaScript só podem ser descobertos em tempo de execução & Parcial \\ \hline
\Cref{limitation:complexBuild} & Requirimento de diversos passos para testar ou disponibilizar aplicações triviais & Sim  \\ \hline
\Cref{limitation:passCompleteObjectsOnSockets} & Impossibilidade de passar objetos completos em WebSockets & Parcial \\ \hline
\Cref{limitation:runScriptsOnlyOnTheEndOfTheProcessment} & Scripts só podem ser rodados com segurança no final da renderização & Parcial \\ \hline
\Cref{limitation:harderToDoMaintainence} & A manutenibilidade de JavaScript tende a ser pior do que a de outras linguagens comuns como C\# & Sim \\ \hline
\Cref{limitation:NANPropagation} & Propagação de valores inválidos NAN & Parcial \\ \hline
\Cref{limitation:typesCheck} & Checagem de alguns tipos retorna resultados inesperados & Parcial \\ \hline
\Cref{limitation:JSanimations} & É pouco eficiente produzir animações em JavaScript & Parcial  \\ \hline
\Cref{limitation:fullscreenManagement} & Impossibilidade de detectar e manipular \textit{fullscreen} de forma padronizada &Não \\ \hline
\Cref{limitation:svgDomPerformance} & Problemas de performance em arquivos SVG muito grandes & Não \\ \hline
\Cref{limitation:svgRefinendControl} & É praticamente impossível obter posicionamento preciso com SVG & Não \\ \hline
\Cref{limitation:noCanvasIntegration} & A integração do Canvas com as demais tecnologias da Web é pobre & Não \\ \hline
\Cref{limitation:noWebglDesktopFunctions} & Falta de alguns recursos disponíveis para OpenGL em ambientes que os permitiriam & Não \\ \hline
\Cref{limitation:hardToUseWebGL} & Para construir jogos é muito difícil utilizar WebGL diretamente & Sim \\ \hline
\Cref{limitation:incompleteSupportWebgl} & Em muitas plataformas o suporte a WebGl é incompleto & Parcial \\ \hline
\Cref{limitation:limitedToRecentThingsWebgl} & WebGl não funciona em placas gráficas antigas  & Não \\ \hline
\Cref{limitation:soundAPIConflicts} & A API de Audio é problemática com sons frequentes no Android & Não \\ \hline
\Cref{limitation:bestAudioCompressionNotSupportedByAllBrowsers} & Não existe um único codec moderno suportado em todos os navegadores & Parcial \\ \hline
\Cref{limitation:limitedMultimidiaControlOnSafari} & O Safari conta com problemas de controle de execução de multimídia & Não \\ \hline
\Cref{limitation:noEffectsOnVideo} & Não é possível aplicar shaders diretamente em vídeo & Sim \\ \hline
\Cref{limitation:videoFullscreenControl} & Falta de forma padronizada de controlar o modo tela cheia para vídeos & Não \\ \hline
\Cref{limitation:videoCodecs} & Falta de consenso sobre um codec de vídeo padrão & \\ Não \hline
\Cref{limitation:safariVideoMissingControlAndCanvas} & A integração de vídeo e canvas do Safari é problemática  e vídeo só pode ser carregado pelo usuário & Não \\ \hline
\Cref{limitation:noSqlSupport} & Não existência de tecnologia oficial de SQL para Web & Parcial \\ \hline
\Cref{limitation:webStorageLimit} & Em muitos navegadores não é possível armazenar mais de 5MB em Web Storage & Não \\ \hline
\Cref{limitation:webStorageQueryLimit} & Não existe forma padronizada de descobrir quando espaço ainda resta em Web Storage & Parcial \\ \hline
\Cref{limitation:webStorageStringOnly} & Web Storage só permite armazenamento de  dados como texto & Não \\ \hline
\Cref{limitation:indexedDbAnonymousBehaviour} & O comportamento do IndexedDB não está especificado & Não \\ \hline
\Cref{limitation:indexedDbNoLike} & Não é possível realizar buscas em texto com o IndexedDB & Não \\ \hline
\Cref{limitation:noErrorMessagesOffline} & Erros nas configurações do manifesto offline não contém mensagens descritivas & Não \\ \hline
\Cref{limitation:orientationIsntReady} & A implementação da API de orientação é divergente entre os navegadores & Sim \\ \hline
\Cref{limitation:checkResourcesOnlyOnJavascrit} & Checagem de recursos só por JavaScript força implementação de markup em scripts & Não \\ \hline
\Cref{limitation:noCanvas2DIsnpectorOnipresent} & Não existe inspetor Canvas 2D multiplataforma para navegadores & Parcial \\ \hline
\Cref{limitation:multiTouch} & Scroll juntamente com outros gestos não funciona corretamente na maioria dos navegadores & Sim \\ \hline
\Cref{limitation:gamepadObject} & Não existe forma padronizada de detectar a entrada e saída de controles nos navegadores & Não \\ \hline
\Cref{limitation:desktopIcon} & Não existe forma padronizada de adicionar ícones de aplicativos Web a área de trabaho & Não \\ \hline
\Cref{limitation:monetizationDifferent} & Jogos exclusivamente Web dificilmente são monetizados da forma convencional & Parcial \\ \hline
\caption{Lista de problemas e limitações}
\label{table:technologies}
\end{longtable}

Das limitações dispostas no quadro \ref{table:technologies}
aquelas resolvidas parcialmente identificam que o problema
pode ser contornado em partes, mas também quando o problema é
contornado de forma inesperada e não intuitiva. Como a utilização
de um depurador internamente no código no caso da limitação
\Cref{limitation:noCanvas2DIsnpectorOnipresent}.

As limitações as quais não tenham solução, em muitos casos, são
problemas temporais e que podem ser solucionados com o tempo. Como no
caso da limitação \Cref{limitation:gamepadObject}, que as diferenças
se dão em grande parte por a especificação não estar pronta. Outras
limitações são intrínssecas da característica do HTML e pode
demorar muito para serem resolvidas.

Algumas possibilidades que são triviais em ambientes desktop podem
tornar-se fatores limitante na plataforma Web. Como é o caso do
controle de Fullscreen via JavaScript. Em plataformas nativas esse
controle é geralmente garantido, já na Web não se permite esse
tipo de gestão. %pesquisar mais sobre isso

Apesar de pretender resolver os problemas de múltiplas tecnologias em
multiplataformas, HTML5 introduz uma gama de incompatiblidade entre suas
próprias versões e implementações.
