
Muitos das limitações dos jogos multiplataforma não são
problemas específicos dos jogos, mas aplicam-se a todos tipos
de software \autocite[pp. 3]{currentStateCrossPlatform}. Alguns
problemas são inerentes da categoria multiplataforma \cite[pp.
7 ]{viabilityBusinessApplications} afirma que é geralmente muito
mais complexo obter aparência nativa, funcionalidade e performance
em aplicações multiplataforma. Outros problemas derivam-se dos
dispositivos ou da tecnologia atual.

A abaixo constam as limitaçõesd do HTML5 aplicáveis, mesmo que não
exclusivamente, aos jogos encontradas durante a pesquisa e concepção
do protótipo. Quando possível, buscou-se apresentar as limitações
na mesma ordem das tecnologias estudadas na revisão bibliográfica.
Não obstante, algumas limitaçãos como performance e versões foram
tratadas em uma partes separadas visto que se aplicam a várias das
tecnologias da WEB.

\section{HTML}

Segundo \cite{crossPlatformMobileGame}
\begin{quote}
Enquanto o HTML é desenvolvido muitas das funcionalidades
disponibilizadas são testadas em um pequeno conjunto de navegadores
para um pequeno conjunto de versões. Isso acarreta em suporte
inconsistente. A forma mais segura de garantir suporte é testando em
todas as versões alvo, todavia essa solução não é prática.
\end{quote}

O Crosswalk é uma tecnologia que pode resolver parcialmente o problema
de versões de software antigas para Android. Visto que a aplicação
é disponibilizada juntamente com uma versão recente do navegador que
a irá rodá-la. Não obstante, o Crosswalk só é suportado
para Android \footnote{Nos apêndices o Crosswalk é tratado com mais
detalhes}.


\section{CSS}

É muito custoso desenvolver uma interfaces que pareçam nativas para
cada dispositivo sem a utilização de plugins e ferramentas. No
protótipo foi utilizada uma estilização simples, que pode se parecer
natural na WEB; não obstante, nos dispositivos móveis, o layout criado
é muito diferente da experiência normal nestes aparelhos.

Uma solução para este problema é utilizar frameworks como o jQuery
Mobile e Kendo UI Mobile \footnote{Mais informações sobre o Kendo UI
e jQuery Mobile podem ser encontradas nos apêndices}. Estes frameworks
permitem criar elementos típicos de interfaces mobile como listas
com scroll, botões e transições com uma aparência nativa de forma
relativamente fácil \autocite{publishHtml5}.

Em alguns casos o tamanho das telas pode ser um fator limitante – como
no caso de jogos de estratégia. Jogadores com telas menores podem sair
em desvantagem.

Para muitos caso pode-se contornar o problema de tamanhos diferenciados
trabalhando com tamanhos relativos via CSS. Não obstante, há casos,
como o dos botões de certo e errado, em que a proporções ficam
exageradas, nesses casos utilizar controles como o \textit{max-width} e
\textit{min-width} é uma solução conveniente.

Tecnologias experimentais do CSS geralmente levam o nome do distribuidor
como prefixo. Utilizar as mesmas regras em CSS com prefixos
diferentes para suportar diversos motores de renderização é um
processo entediante e propenso à duplicação e erros. A biblioteca
\textit{-prefix-free} é uma possível solução para este problema,
detectando automaticamente quando prefixos são necessários e
adicionado em tempo de execução \footnote{Mais informações sobre a
biblioteca pode ser encontradas nos apêndices}.

\section{JavaScript}

O JavaScript, por ser uma tecnologia desenvolvida por consenso, tem
um ciclo de vida de atualizações demorado; pois necessita que todos
os consumidores da especificação entrem em consenso e implementem o
concordado. O site \url{https://kangax.github.io/compat-table/es6/}
contém uma lista do suporte aos recursos do ECMAScript 6 nos motores
JavaScript.

Por ser uma linguagem interpretada, erros tem de descobertos rodando
a aplicação. Alternativamente se JavaScript fosse compilado vários
problemas poderiam ser capturados e informações úteis reveladas antes
de se testar \autocite[pp. 12]{viabilityBusinessApplications}.

Aplicações para produção muitas vezes necessitam ser minificadas por
performance e ofuscação. Sem a utilização de automatizadores como o
Grunt Watch essa tarefa é entediante e propensa a erros.

O sistema de tipos do JavaScript também é problemático.
Erros numéricos resultam no valor NaN (\textit{not a number}).
Todas as operações com NaN como operadores irão retornar outro
NaN. Isso torna a depuração de erros desnecessariamente complexa
\autocite{html5mostwanted}.

Ao testar o tipo (\textit{typeof}) de uma variável vazia o JavaScript
retorna como se fosse um objeto.

\begin{figure}[H]
\centering
\begin{verbatim}
function is(type, object) {
    type = type[0].toUpperCase + type.slice(1);
    return Object.prototype.toString.call(object)
    === '[object ]' +  type + ']';
}
\end{verbatim}
\caption{Função para testar tipos que funciona como o esperado.}
\label{fig:fixJSTypes}
\source{\url{http://www.slideshare.net/fdaciuk/javascript-secrets-front-in-floripa-2015}}
\end{figure}

A figura \ref{fig:fixJSTypes} demonstra uma solução possível para
remediar o problema dos testes de tipos em JavaScript. A diferença
desta função é que ela converte a variável que se está testando
para sua representação em texto a qual contém o nome do tipo escrito
por extenso - utilizando-se deste valor pode-se deduzir o tipo da
variável corretamente.

Segundo \cite{htmlResearchJournal}, um problema do JavaScript é que
não é possível transferir métodos de objetos através de sistemas,
via WebSocket, somente dados. Uma forma de contornar este problema é
utilizar funções para converter os dados em objetos em cada ponta do
processamento mas isto adiciona complexidade ao software.

Apesar da performance ter notavelmente melhorado, ainda é geralmente
menos eficiente produzir animações em JavaScript do que utilizando
transições e animações do CSS, que por sua vez são mais otimizados
e acelerados via hardware \autocite{html5mostwanted}.

O WEB Assembly pode resolver este problema, substituindo o JavaScript
para os casos onde grande performance é necessária. Mas para isso o
Web Assembly precisa evoluir na especificação e implementações.

\subsection{Fullscreen}

Não existe forma padronizada de detectar se uma aplicação está em
tela cheia ou não através de JavaScript. O IOS suporta a variável
\textit{navigator.standalone } para identificar se a aplicação está
em tela cheia. \cite{homescreenwebapps} recomenda a utilização do
trecho de código para determinar se está em modo tela cheia
nos demais navegadores.

\begin{figure}[H]
\centering
\begin{verbatim}
navigator.standalone = navigator.standalone || (screen.height-document.documentElement.clientHeight<40)
\end{verbatim}
\caption{Teste de tela cheia}
\label{fig:fixJSTypes}
\source{\url{http://www.mobilexweb.com/blog/home-screen-web-apps-android-chrome-31}}
\end{figure}

\section{Navegadores}

A tabela abaixo demonstra é um comparativo das tecnologias pesquisadas,
relevantes aos jogos e seu suporte. As informações de suporte foram
extraídas do site Can I Use e os navegadores populares em questão
são: Internet Explorer (11), Edge (13), Firefox (43), Google Chorme
(47), Safari (9) e Opera(34).

\begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|  }
\hline
Tecnologia & Suporte nas últimas versões estáveis dos navegadores populares & Polyfills disponíveis  para versões antigas \\
\hline
Canvas & Sim & Sim \\
SVG & Sim & Sim \\
Gamepad & Não & Sim \\
WebGL & Parcial & Sim \\
WebSockets & Sim & Sim \\
Video & Sim & Sim \\
Audio & Sim & Sim \\
IndexedDB & Parcial & Sim \\
WebCL & Não & Não \\
WebVR & Não & Não \\
WebAssembly & Não & Sim \\
Tag áudio & Sim & Sim \\
Áudio API & Não & Sim \\
Vídeo & Não & Sim \\
\hline
\end{tabular}

\section{Android}

Segundo \cite{chromeWebView} da versão 4.4 do Android em diante a
WebView mudou de um projeto local para utilizar o Chromium. Entretanto,
grande parcela dos usuários Android ainda utilizam o sistema antigo o
que força os desenvolvedores suportarem ambas as versões. É razoável
afirmar que para o início de 2016 um terço dos usuários de Android
ainda utilizem a versão antiga da WebView \cite{chromeWebView}.

\section{SVG}

Uma das grandes vantagens do SVG é que é definido via linguagem de
marcação e se integra bem com as demais tecnologias da WEB. Não
obstante, isso também implica em problemas de performance para arquivos
muito grandes pois os elementos são manipulados via DOM. Segundo
\cite{html5mostwanted} a grande desvantagem do SVG é que quão maior o
documento mais lenta a renderização.

Controle refinado também é um problema do SVG \cite{html5mostwanted}
cita que um aspecto negativo do SVG é que é muito difícil atingir a
perfeição na posição dos pixels, por ser uma linguagem vetorizada

\section{Canvas}

A literatura aponta várias limitações distintas na API do canvas.
Segundo \autocite{html5mostwanted}, os aspectos negativos do canvas é
que a performance varia de plataformas para plataformas e não existe
implementação nativa para animações.

O problema de performance mencionado pode ser parcialmente remediado
com o FastCanvas. FastCanvas é uma implementação nativa em C++ do
canvas para Android que roda separadamente do JavaScript. Devidas as
características acima citadas FastCanvas é substancialmente mais
rápido do que a tag canvas para navegadores Android. Não obstante, o
FastCanvas não suporta a especificação do canvas completamente, e
existem umas diferenças no comportamento entre o canvas original e o
FastCanvas.

A implementação de animações de fato não existe no canvas,
similarmente carece-se de integração com as demais tecnologias
da WEB. Os desenhos do canvas não podem ser acessados via DOM nem
serem manipulados via CSS, todas as modificações necessárias devem
ser feitas através de JavaScript.
No protótipo, especificamente na classe \textit{Countdown}, foi necessário
adicionar regras de estilo no JavaScript para a interação com o canvas
ficar completa.

CSS já conta com definições quanto a animações e a manipulação de
elementos do canvas através do DOM facilitaria uma gama de situações.
Por exemplo, seria possível utilizar os eventos do DOM para capturar
interações do usuário através de elementos utilizados no canvas.
Se um retângulo fosse clicado o evento seria lançado a partir dele.
Controle similar é implementado atualmente acessando as coordenadas
do canvas onde uma interação aconteceu e fazendo o processamento com
aquela determinada área.

Felizmente a integração entre o canvas e as demais tecnologias da
WEB está começando a acontecer. A interoperabilidade entre o Path2D
do canvas e a notação SVG é uma iniciativa na direção correta,
tornando ambas tecnologias cada vez relevantes e dinâmicas.

Uma característica peculiar descoberta durante o desenvolvimento
do protótipo é que o Canvas pode gerar resultados inesperados se
seus tamanhos de elemento e tela diferirem de formas específicas. Em
suma, existem dois tamanhos, o tamanho do elemento e da superfície de
desenho. Quando o tamanho do elemento é maior do que o da superfície
de desenho do documento escala a superfície de desenho para preencher o
elemento, o que pode gerar resultados inesperados.

\section{WebGL}

Como WebGL é baseada na versão otimizada para dispositivos móveis do
OpenGL não é possível utilizar muitos recursos especiais disponíveis
para os ambientes desktop. Como a definição de caminhos com a função
\textit{glBegin} e a impossibilidade de utilizar pontos flutuantes para
calcular coordenadas de vértices \autocite{esVsGl}.

Segundo \cite{html5mostwanted} um dos problemas do WebGL é sua alta
curva de aprendizagem e o fato de não ter suporte para o Internet
Explorer. Entretanto, o suporte foi adicionado na última versão do
Internet Explorer (11). Infelizmente a dificuldade de utilização
ainda persiste, forçando a maioria dos desenvolvedores a utilizarem
abstrações criadas por bibliotecas de terceiros \footnote{Os apendices
contém algumas destas bibliotecas como o tree.JavaScript}.

É importante ressaltar que o WebGL não se comporta de maneira
simétrica nos navegadores que implementam a especificação. Pode haver
diferenças substanciais de performance em plataformas diferentes e em
navegadores diferentes. Existe também uma lista de placas gráficas com
\textit{drivers} bloqueados por não funcionarem corretamente no Firefox
\autocite[pp.42]{3daps}.

Para ver um programa em WebGL é necessário um navegador recente, uma
placa gráfica recente e um sistema operacional que suporte a tecnologia
\autocite{html5mostwanted}

CocoonJS é uma aplicativo híbrido que preenche a fraca implementação
de WebGL nos dispositivos móveis possibilitando se desenvolver em
WEBGL, CSS. Conta com suporte a dispositivos legados à partir do
Android 2.3 e IPhone 5.

\subsection{ÁUDIO}

Segundo \cite{html5mostwanted} a limitação do elemento de áudio do
HTML5 é que seu propósito é para executar apenas um som, como o som
de fundo dentro de um jogo. Não sendo adequada para efeitos sonoros 
ou necessidades flexíveis de áudio.

Durante a concepção do protótipo foi utilizada a API de audio, devido
sua maior flexibilidade. Infelizmente, algumas vezes o som não é
executado ou demora até executar de modo de o que é executado ao mesmo
tempo que o próximo som.

A experimentação do protótipo relativo a API de áudio confirmou as
afirmações de \cite{html5mostwanted} a API de som é boa se você
deseja apenas tocar alguma música, mas se você está lançando eventos
em um jogo ela ainda é problemática.

Outro problema de áudio em HTML5 são os codecs. Alguns navegadores
favorecem formatos OGG (vorbis) e outros, como o Safari, favorecem o
MP3.

Audio no Safari do IOS contém alguns problemas específicos.
Por exemplo, não é possível trocar o volume através de
JavaScript também não é possível tocar mais de um som ou vídeo
simultaneamente \autocite{unsolvedMediaHtmlIssues}.

\subsection{VIDEO}

O suporte a vídeo, apesar de estar melhorando, ainda é rudimentar. No
Silverlight existem uma coleção de possibilidades como aplicar shaders
diretamente no vídeo e streaming suave de 1080px HD \autocite[pp.
8]{researchOnHtml}.

Não é possível controlar a entrada em tela cheia através de script
pois é considerado uma violação de segurança. Não obstante,
os navegadores tem a opção de deixar os usuários escolherem ver
vídeos em tela cheia através de controles adicionais \autocite[pp.
68]{proHtml5}.

Assim como áudio o elemento \textit{video} sofre com problemas de
codecs, segundo \cite{html5Tradeoffs}:
\begin{quote}
O maior problema com as API's de áudio e de vídeo do HTML5 é
a disputa entre os codecs dos navegadores. Por exemplo, Mozilla e
Opera suportam Theora, já o Safari suporta H.264 que também é
suportado pelo IE9. Ambos, Iphone e Android suportam H.264 em seus
navegadores. A W3C recomenda OggVorbis e OggTheora para áudio e vídeo
respectivamente.
\end{quote}

O Safari do IOS também contém problemas exclusivos de vídeo. Segundo
\cite{unsolvedMediaHtmlIssues} não é possível capturar frames de
vídeo usando o método \textit{drawImage} do canvas. Também não é
possível pré carregar arquivos de vídeo sem iteração do usuário, entre outros.

Para os raros casos onde o suporte a vídeo não existe,
como no Opera Mini, o projeto \textit{Vídeo for Everybody}
\url{http://camendesign.com/code/video_for_everybody} é um polyfill que
recorre à flash para apresentar o conteúdo.

\section{Armazenamento}

IndexedDB é uma API interessante mas para projetos menores é um tanto complexa.

Não existe tecnologia oficial que permita a utilização de tecnologias
SQL para Frontend. O WebSQL foi uma tentativa nesta direção mas, visto
que não continha mais de uma implementação, foi descontinuado. SQL seria 
interessante pois muitos desenvolvedores tem experiência  com este tipo de tecnologia
e suporta estruturas de filtragem de dados realmente poderosas.

\section{OFFLINE}

Nos arquivos de cache via manifestos, quando o download falha, o
navegador emite um evento mas não há indicação de qual problema
aconteceu. Isso pode tornar a depuração ainda mais complicada que o
usual \autocite{diveIntohtml}. 

Este problema aconteceu durante o desenvolvimento do protótipo e foi
trabalhoso de depurar até descobrir que um arquivo estava faltando,
e qual especificamente. Uma coleção de códigos de erro e suas
respectivas mensagens na especificação poderia solucionar este
problema.

Refresh duplo para ver assets cacheados. Ver:


\section{Orientação}

Visto que a especificação o suporte está longe de completo, até
o momento da pesquisa o único navegador popular que implementa a
especificação completamente é o Edge da Microsoft.

Outrossim, existem diferenças substanciais entre navegadores, por
exemplo: O Firefox e Google Chrome não manipulam ângulos da mesma
forma, por conseguinte alguns eixos se comportam de maneiras opostas
\autocite{mdnOrientation}. O polyfill \textit{gyronorm.js} é uma
tentativa de normalizar o uso de dados de orientação nos navegadores
que pode ser utilizada até a especificação e os navegadores
evoluírem.

\section{Detecção de recursos}

Grande parte da detecção de funcionalidades é feita através de
JavaScript, isso força os desenvolvedores a criarem pelo menos parte da
marcação em JavaScript, isso pode ser um fator limitante para o uso
generalizado de HTML5 \autocite{diveIntohtml}.

\section{Debug}

Com o depurador do Google Chrome remoto foi observado uma falta de
sincronia na atualização da imagem no computador. Os efeitos do CSS
não são bem apresentados e algumas vezes a tela foi completamente
alterada (como na mudança de páginas) e no computador o estado
anterior é apresentado.

O inspetor de canvas nativo do Google Chrome foi removido pois continha
comportamentos indesejáveis para os desenvolvedores do navegador
\autocite{canvasinspector}. Os desenvolvedores mencionaram criar uma
extensão para a funcionalidade mas até o tempo de desenvolvimento
deste trabalho não havia nenhuma disponível. A única alternativa
viável até o momento é utilizar uma versão antiga do Chromium.

O Firefox introduziu uma ferramenta de inspeção para o canvas 2D
em uma Conferência de desenvolvimento de jogos em São Francisco em 2014,
mas até a tecnologia não apareceu no navegador \autocite{firefoxCanvasDebug}.

Atualmente a área de ferramentas para depuração do canvas 2D estão
comprometidas por não existir um plugin de terceiro tão bem
consolidado como o WebGl Inspector. O projeto Canvas Interceptor é
uma iniciativa para preencher esta demanda permitindo capturar alguns
eventos do contexto 2d e tirar \textit{snapshoots} dos passos da renderização
do canvas. Entretanto, o projeto requer que o desenvolvedor inclua
um arquivo JavaScript em seu projeto e inicialize o depurador dentro do código,
se tornando uma saída mais custosa do que um inspetor nativo no
navegador ou via extensão. \footnote{Mais informações sobre o
projeto Canvas Interceptor podem ser encontradas no seguinte endereço
https://github.com/Rob--W/canvas-interceptor}

\section{Entrada de comandos}

\autocite[pp. 9]{aSeriousContender} cita que: Fazer scroll juntamente
com gestos de ações similares é uma área onde o HTML ainda é
fraco. Para contornar este problema pode-se utilizar bibliotecas como o
iScroll, TouchScroll, GloveBox, Sencha, jQuery Mobile, entre outros.

\subsection{Gamepad}
Chrome does things differently here. Instead of constantly storing the gamepad's latest state in a variable it only stores a snapshot, so to do the same thing in Chrome you have to keep polling it and then only use the Gamepad object in code when it is available.

\section{Disponibilização}

O serviço PhoneGap Build não contém a última versão do PhoneGap e
não é possível utilizar plugins através deles. Embora no protótipo
isso não tenha sido um problema, em projetos maiores estes tipos de
requerimentos podem ser vitais.


\section{Monetização}

É muitas vezes difícil encontra oportunidades financeiras em jogos
para navegador, visto que não existem pacotes de jogos para vender
\autocite[pp. 44]{gameCommunities}.

Dado este este problema, desenvolvedores são muitas vezes forçados
a criar formas alternativas de lucro. A monetização de aplicativos
WEB é geralmente feita através de propagandas \autocite[pp.
44]{gameCommunities}. Outra saída é a venda de recursos extra,
\cite[pp. 44]{gameCommunities} afirma que a venda de moeda virtual é
uma forma comum monetização.

Não obstante jogos WEB podem ser integrados pelos desenvolvedores
a sistemas de pagamento - possivelmente aumentado a complexidade da
aplicação. Ou serem integrados a algum mercado como o do Android, se
optarem pela arquitetura híbrida.


\section{PERFORMANCE}

Otimizações de performance dependem do ambiente em que estão
sendo feitas. E aquelas que hoje tem um impacto positivo hoje
podem se tornar inúteis, ou mesmo prejudiciais, amanhã
\autocite[pp.131]{html5mostwanted}.

Com o HTTP/2 minificar arquivos pode não ser mais benéfico, visto que
todos passam pelo mesmo canal de comunicação.

\subsection{ASSETS}

Trafegar muitos arquivos deixa o sistema lento. Pode-se contornar este
problema utilizando páginas de carregamento e/ou cache.

Outro problema relativo aos assets é descrito por \cite{howBrowsersWork}
scripts requerendo informações de estilo durante o processo de
parse. Se o estilo ainda não foi carregado o script vai utilizar
informações erradas, causando uma série de problemas.

\section{Outras Limitações}

\cite{html5Tradeoffs} cita algumas limitações no contexto geral
\begin{quote}
Não podemos mudar a imagem de fundo do dispositivo, ou adicionar toques
etc. Similarmente, existem muitas API's de nuvem como os serviços
de impressão do ICloud ou Google Cloud que estão disponíveis para
aplicações nativas mas não para HTML5. Outros serviços utilitários
como o C2DM do Google que está disponível para desenvolvedores Android
para utilizar serviços de \textit{push} também não estão disponíveis
para o HTML5.
\end{quote}

\cite{browserGamesTechnologyAndFuture} apresenta as seguintes limitações
no contexto de jogos de navegador.

\begin{itemize}
\item Não podem ser instalados em um dispositivo móvel como um aplicativo separado
\item Não tem acesso a funcionalidades específicas dos dispositivos e recursos como notificações, use de hardware nativo ou comunicação entre aplicativos.
\end{itemize}

