\begin{draft}

\section{LIMITAÇÕES}

Muitos dos problemas dos jogos multiplataforma não são
específicos dos jogos, mas aplicam-se a todos tipos de software
\parencite{currentStateCrossPlatform}. Alguns problemas são inerentes
das tecnologias, outras dos dispositivos ou da característica
multiplataforma.

Não obstante, abaixo constam as limitações aplicáveis, mesmo
que não exclusivamente, aos jogos. Encontradas durante a pesquisa e
concepção do protótipo.

\subsection{Recursos}

Apesar da grande maioria dos recursos oferecidos nativamente
nos dispositivos estar presente em HTML5 ainda existem algumas
funcionalidades faltando para este tipo de aplicação.

\cite{html5Tradeoffs} cita algumas limitações no contexto geral
\begin{quote}
Não podemos mudar a imagem de fundo do dispositivo, ou adicionar toques
etc. Similarmente, existem muitas API's de nuvem como os serviços
de impressão do ICloud ou Google Cloud que estão disponíveis para
aplicações nativas mas não para HTML5. Outros serviços utilitários
como o C2DM do Google que está disponível para desenvolvedores Android
para utilizar serviços de \textit{push} também não estão disponíveis
para o HTML5.
\end{quote}

\subsection{VERSÕES}
A grande maioria dos dispositivos atualmente no mercado utilizam
obsoletas de seus softwares. Isso dificulta o desenvolvimento. Se a
tecnologia de tradução para o navegador utilizar o a classe Webview do
Android, como o Apache Cordova faz, as versões mais antigas podem ser
penalizadas com problemas de performance ou falta de recursos.

Segundo \cite{crossPlatformMobileGame}
\begin{quote}
Enquanto o HTML é desenvolvido muitas das funcionalidades
disponibilizadas são testadas em um pequeno conjunto de
navegadores para um pequeno conjunto de versões. Isso
acarreta em suporte inconsistente. A forma mais segura de garantir
suporte é testando em todas as versões alvo, todavia essa solução
não é prática.
\end{quote}

\subsection{OFFLINE}

Quando o download offline falha o navegador emite um evento mas não há
indicação de qual problema aconteceu. Isso pode tornar a depuração
ainda mais complicada que o usual \autocite{diveIntohtml}.

Refresh duplo para ver assets cacheados. Ver:
http://buildnewgames.com/game-asset-management/

\subsection{SVG}

Segundo \cite{html5mostwanted} a grande desvantagem do SVG é que quão
maior o documento mais lenta a renderização.

\subsection{Canvas}

A literatura aponta várias limitações distintas na API do canvas.
Segundo \autocite{html5mostwanted}, os aspectos negativos do canvas é
que a performance varia de plataformas para plataformas e não existe
implementação nativa para animações.

O problema de performance  mencionado pode ser remediado com o FastCanvas.
O FastCanvas é uma iniciativa híbrida para Android que busca mitigar os
problemas de performance do Canvas com uma API nativa. Não obstante, o
FastCanvas não suporta a especificação do canvas completamente,

A implementação de animações de fato não existe no canvas,
similarmente carece-se de integração com as demais tecnologias
da WEB. Os desenhos do canvas não podem ser acessados via DOM nem
serem manipulados via CSS, todas as modificações necessárias devem
ser feitas via JavaScript. CSS já conta com definições quanto a
animações e a manipulação de elementos do canvas através do DOM
facilitaria uma gama de situações, por exemplo com interações do
usuário com algum elemento do canvas. Que hoje são geralmente feitos
acessando as coordenadas do canvas onde uma interação aconteceu e
fazendo o processamento com aquela determinada área, poderia ser feito
adicionando-se um \textit{listener} para determinado objeto do canvas.
A interoperabilidade entre o Path2D do canvas e a notação SVG é uma iniciativa
na direção correta, tornando as tecnologias cada vez mais interoperáveis.

No protótipo, especificamente na classe \textit{Countdown}, foi necessário
adicionar regras de estilo no JavaScript para  a interação com o canvas
ficar completa.

Uma característica peculiar descoberta durante o desenvolvimento
do protótipo é que o Canvas pode gerar resultados inesperados se
seus tamanhos de elemento e tela diferirem de formas específicas. Em
suma, existem dois tamanhos, o tamanho do elemento e da superfície de
desenho. Quando o tamanho do elemento é maior do que o da superfície
de desenho do documento escala a superfície de desenho para preencher o
elemento, o que pode gerar resultados inesperados.

\subsection{WebGL}

Como WebGL é baseada na versão otimizada para dispositivos móveis do
OpenGL não é possível utilizar muitos recursos especiais disponível
para os ambientes desktop.

Segundo \cite{html5mostwanted} um dos problemas do WebGL é sua alta
curva de aprendizagem e o fato de não ter suporte para o Internet
Explorer. Entretanto o suporte foi adicionado na última versão do
Internet Explorer (11). Não obstante a dificuldade de utilização
ainda persiste, forçando a maioria dos desenvolvedores a utilizarem
abstrações criadas por bibliotecas de terceiros.

\footnote{Os apêndices contam com uma coleção de bibliotecas que facilitam a utilização de WebGL}

É importante ressaltar que o WebGL não se comporta de maneira
simétrica nos navegadores que implementam a especificação. Pode haver
diferenças substanciais de performance em plataformas diferentes e em
navegadores diferentes. Existe também uma lista de placas gráficas
com drivers bloqueados por não funcionarem corretamente no Firefox
\autocite[pp.42]{3daps}.

Para ver um programa em WebGL é necessário um navegador recente, uma
placa gráfica recente e um sistema operacional que suporte a tecnologia
\autocite{html5mostwanted}

\subsection{VIDEO}

O suporte a vídeo apesar de estar melhorando ainda é básico.
No Silverlight existem uma coleção de possibilidades como aplicar
shaders diretamente no vídeo e streaming suave de 1080px HD \autocite[pp. 8]{researchOnHtml}.

O projeto \textit{Vídeo for Everybody} \begin{verbatim}
http://camendesign.com/code/video_for_everybody \end{verbatim} é um
polyfill que recorre à flash quando o vídeo não é suportado pelo
navegador.

\subsection{ASSETS}

Trafegar muitos assets deixa o sistema lento. Pode-se contornar este
problema utilizando páginas de carregamento e/ou cache;

Outro problema relativo aos assets é descrito por \cite{howBrowsersWork}
scripts requerendo informações de estilo durante o processo de
parse. Se o estilo ainda não foi carregado o script vai utilizar
informações erradas, causando uma série de problemas.

\subsection{Codecs}

\subsection{ÁUDIO}

Segundo \cite{browserGamesTechnologyAndFuture} em sido difícil
construir aplicações sofisticadas e interativas sem a utilização de
plugins para áudio.
Segundo \cite{html5mostwanted} a limitação do elemento de áudio do
HTML5 é que seu propósito é para executar apenas um som, como o som
de fundo dentro de um jogo.

A API de som no protótipo nem sempre emite o som quando o
evento é disparado sucessivamente. Confirmando a afirmação de
\cite{html5mostwanted} a API de som é boa se você deseja apenas tocar
alguma música, mas se você está lançando eventos em um jogo ela é
problemática.

Os navegadores variam na disponibilização de formatos aceitáveis
Somente um áudio pode ser tocado no Navegador do Android

Não é possível trocar o volume no IOS.

Alguns navegadores favorecem formatos OGG (vorbis) e outros, como o
Safari, favorecem o MP3.

Segundo \cite{html5Tradeoffs}
\begin{quote}
O maior problema com as API's de áudio e de vídeo do HTML5 é
a disputa entre os codecs dos navegadores. Por exemplo, Mozilla e
Opera suportam Theora, já o Safari suporta H.264 que também é
suportado pelo IE9. Ambos, Iphone e Android suportam H.264 em seus
navegadores. A W3C recomenda OggVorbis e OggTheora para áudio e vídeo
respectivamente.
\end{quote}

\subsection{INTERFACE GRÁFICA}

É muito custoso desenvolver uma interfaces que pareçam nativas
para cada dispositivo sem a utilização de plugins e ferramentas
especializadas. Em termos gerais, trabalhar com proporções é
positivo. Não obstante
há casos, como o dos botões de certo e errado que a proporções ficam
exageradas, nesses casos a utilizada de max-width é uma solução
conveniente.

\subsection{PERFORMANCE GERAL}

De acordo com uma pesquisa, para um usuário uma tarefa é instantânea
se ele leva até 0.1 segundos para ser executada. Se a tarefa toma
aproximadamente um segundo então a demora será notada mas o
usuário não se incomodará com ela. Entretanto, se a tarefa leva
aproximadamente 10 segundos para terminar o usuário então começa a
ficar aborrecido e esse é o limite que algum feedback deve ser dado
para um usuário.

Otimizações de performance dependem do ambiente em que estão
sendo feitas. E aquelas que hoje tem um impacto positivo hoje
podem se tornar inúteis, ou mesmo prejudiciais, amanhã
\autocite[pp.131]{html5mostwanted}.

\subsection{Acelerômetro}

\subsection{IMPLEMENTAÇÃO INCONSISTENTE DE APIs}

\subsection{TAMANHO DE TELA}
Em alguns casos o tamanho das telas pode ser um fator limitante – como
no caso de jogos de estratégia. Jogadores com telas menores podem sair
em desvantagem.

\subsection{JavaScript}

O JavaScript, por ser uma tecnologia desenvolvida por consenso, tem um
ciclo de vida de atualizações demorado; pois necessita que todos os
consumidores da especificação entrem em consenso e implementem a.

Apesar da performance ter notavelmente melhorado, ainda é geralmente
menos eficiente produzir animações em JavaScript do que utilizando
transições e animações do CSS, que por sua vez são mais otimizados
e acelerados via hardware \autocite{html5mostwanted}.

Erros numéricos resultam no valor NaN (\textit{not a number}).
Todas as operações com NaN como operadores irão retornar outro
NaN. Isso torna a depuração de erros desnecessariamente complexa
\autocite{html5mostwanted}.

\subsection{Detecção de recursos}

Grande parte da detecção de funcionalidades é feita através de
JavaScript, isso força os desenvolvedores a criarem pelo menos parte da
marcação em JavaScript, isso pode ser um fator limitante para o uso
generalizado de HTML5 \autocite{diveIntohtml}.

\subsection{Scroll}
\autocite[pp. 9]{aSeriousContender} cita que:
Fazer scroll juntamente com gestos de ações similares é uma área
onde o HTML ainda é fraco. Existem várias tentativas para solucionar
esse problema como o iScroll, TouchScroll, GloveBox, Sencha, jQuery
Mobile.

\subsection{Armazenamento}

Em praticamente nenhuma das tecnologias da WEB é possível armazenar objetos e  seu estado atual.

IndexedDB é uma API interessante mas para projetos menores é um tanto complexa.

%unsorted

\cite{browserGamesTechnologyAndFuture} apresenta as seguintes limitações
no contexto de jogos de navegador.

\begin{itemize}
\item Não podem ser instalados em um dispositivo móvel como um aplicativo separado
\item Não tem acesso a funcionalidades específicas dos dispositivos e recursos como notificações, use de hardware nativo ou comunicação entre aplicativos.
\end{itemize}



\end{draft}
