
Muitos das limitações dos jogos multiplataforma não são
problemas específicos dos jogos, mas aplicam-se a todos tipos
de software \autocite[pp. 3]{currentStateCrossPlatform}. Alguns
problemas são inerentes da categoria multiplataforma \cite[pp.
7 ]{viabilityBusinessApplications} afirma que é geralmente muito
mais complexo obter aparência nativa, funcionalidade e performance
em aplicações multiplataforma. Outros problemas derivam-se dos
dispositivos ou da tecnologia atual.

A abaixo constam as limitaçõesd do HTML5 aplicáveis, mesmo que não
exclusivamente, aos jogos encontradas durante a pesquisa e concepção
do protótipo. Quando possível, buscou-se apresentar as limitações
na mesma ordem das tecnologias estudadas na revisão bibliográfica.
Não obstante, algumas limitaçãos como performance e versões foram
tratadas em uma partes separadas visto que se aplicam a várias das
tecnologias da WEB.

\section{CSS}

É muito custoso desenvolver uma interfaces que pareçam nativas para
cada dispositivo sem a utilização de plugins e ferramentas. No
protótipo foi utilizada uma estilização simples, que pode se parecer
natural na WEB; não obstante, nos dispositivos móveis, o layout criado
é muito diferente da experiência normal nestes aparelhos.

Uma solução para este problema é utilizar frameworks como o jQuery
Mobile e Kendo UI Mobile \footnote{Mais informações sobre o Kendo UI
e jQuery Mobile podem ser encontradas nos apêndices}. Estes frameworks
permitem criar elementos típicos de interfaces mobile como listas
com scroll, botões e transições com uma aparência nativa de forma
relativamente fácil \autocite{publishHtml5}.

Em alguns casos o tamanho das telas pode ser um fator limitante – como
no caso de jogos de estratégia. Jogadores com telas menores podem sair
em desvantagem.

Para muitos caso pode-se contornar o problema de tamanhos diferenciados
trabalhando com tamanhos relativos via CSS. Não obstante, há casos,
como o dos botões de certo e errado, em que a proporções ficam
exageradas, nesses casos utilizar controles como o \textit{max-width} e
\textit{min-width} é uma solução conveniente.

Tecnologias experimentais do CSS geralmente levam o nome do distribuidor
como prefixo. Utilizar as mesmas regras em CSS com prefixos
diferentes para suportar diversos motores de renderização é um
processo entediante e propenso à duplicação e erros. A biblioteca
\textit{-prefix-free} é uma possível solução para este problema,
detectando automaticamente quando prefixos são necessários e
adicionado em tempo de execução \footnote{Mais informações sobre a
biblioteca pode ser encontradas nos apêndices}.

\autocite[pp. 9]{aSeriousContender} cita que: Fazer scroll juntamente
com gestos de ações similares é uma área onde o HTML ainda é
fraco. Para contornar este problema pode-se utilizar bibliotecas como o
iScroll, TouchScroll, GloveBox, Sencha, jQuery Mobile, entre outros.

\section{JavaScript}

O JavaScript, por ser uma tecnologia desenvolvida por consenso, tem
um ciclo de vida de atualizações demorado; pois necessita que todos
os consumidores da especificação entrem em consenso e implementem o
concordado.

Por ser uma linguagem interpretada, erros tem de descobertos rodando
a aplicação. Alternativamente se JavaScript fosse compilado vários
problemas poderiam ser capturados e informações úteis reveladas antes
de se testar \autocite[pp. 12]{viabilityBusinessApplications}.

Aplicações para produção muitas vezes necessitam ser minificadas por
performance e ofuscação. Sem a utilização de automatizadores como o
Grunt Watch essa tarefa é entediante e propensa a erros.

O sistema de tipos do JavaScript também é problemático.
Erros numéricos resultam no valor NaN (\textit{not a number}).
Todas as operações com NaN como operadores irão retornar outro
NaN. Isso torna a depuração de erros desnecessariamente complexa
\autocite{html5mostwanted}.

Ao testar o tipo (\textit{typeof}) de uma variável vazia o JavaScript
retorna como se fosse um objeto.

\begin{figure}[H]
\centering
\begin{verbatim}
function is(type, object) {
    type = type[0].toUpperCase + type.slice(1);
    return Object.prototype.toString.call(object)
    === '[object ]' +  type + ']';
}
\end{verbatim}
\caption{Função para testar tipos que funciona como o esperado.}
\label{fig:fixJSTypes}
\source{\url{http://www.slideshare.net/fdaciuk/javascript-secrets-front-in-floripa-2015}}
\end{figure}

A figura \ref{fig:fixJSTypes} demonstra uma solução possível para
remediar o problema dos testes de tipos em JavaScript. A diferença
desta função é que ela converte a variável que se está testando
para sua representação em texto a qual contém o nome do tipo escrito
por extenso - utilizando-se deste valor pode-se deduzir o tipo da
variável corretamente.

Segundo \cite{htmlResearchJournal}, um problema do JavaScript é que
não é possível transferir métodos de objetos através de sistemas,
via WebSocket, somente dados. Uma forma de contornar este problema é
utilizar funções para converter os dados em objetos em cada ponta do
processamento mas isto adiciona complexidade ao software.

Apesar da performance ter notavelmente melhorado, ainda é geralmente
menos eficiente produzir animações em JavaScript do que utilizando
transições e animações do CSS, que por sua vez são mais otimizados
e acelerados via hardware \autocite{html5mostwanted}.

O WEB Assembly pode resolver este problema, substituindo o JavaScript
para os casos onde grande performance é necessária. Mas para isso o
Web Assembly precisa evoluir na especificação e implementações.


\section{SVG}

Uma das grandes vantagens do SVG é que é definido via linguagem de marcação e se integra bem com as demais tecnologias da WEB. Não obstante, isso também implica em problemas de performance para arquivos muito grandes.
Segundo \cite{html5mostwanted} a grande desvantagem do SVG é que quão
maior o documento mais lenta a renderização.

Controle refinado também é um problema do SVG \cite{html5mostwanted} cita que
um aspecto negativo do SVG é que é muito difícil atingir a
perfeição na posição dos pixels, por ser uma linguagem vetorizada

\section{Canvas}

A literatura aponta várias limitações distintas na API do canvas.
Segundo \autocite{html5mostwanted}, os aspectos negativos do canvas é
que a performance varia de plataformas para plataformas e não existe
implementação nativa para animações.

O problema de performance mencionado pode ser parcialmente remediado
com o FastCanvas. FastCanvas é uma implementação nativa em C++ do
Canvas para Android que roda separadamente do JavaScript. Devidas as
características acima citadas FastCanvas é substancialmente mais
rápido do que a tag canvas para navegadores Android. Não obstante, o
FastCanvas não suporta a especificação do canvas completamente, e
existem umas diferenças no comportamento de de ambos.

A implementação de animações de fato não existe no canvas,
similarmente carece-se de integração com as demais tecnologias
da WEB. Os desenhos do canvas não podem ser acessados via DOM nem
serem manipulados via CSS, todas as modificações necessárias devem
ser feitas através de JavaScript. 
No protótipo, especificamente na classe \textit{Countdown}, foi necessário
adicionar regras de estilo no JavaScript para a interação com o canvas
ficar completa.

CSS já conta com definições quanto a animações e a manipulação de
elementos do canvas através do DOM facilitaria uma gama de situações.
Por exemplo, poderia se utilizar os eventos do DOM para capturar
interações do usuário através de elementos utilizados no canvas.
Controle similar é implementado atualmente acessando as coordenadas
do canvas onde uma interação aconteceu e fazendo o processamento com
aquela determinada área.

Não obstante a integração entre o canvas e as demais tecnologias da
WEB está começando a acontecer. A interoperabilidade entre o Path2D
do canvas e a notação SVG é uma iniciativa na direção correta,
tornando as tecnologias cada vez úteis e dinâmicas.

Uma característica peculiar descoberta durante o desenvolvimento
do protótipo é que o Canvas pode gerar resultados inesperados se
seus tamanhos de elemento e tela diferirem de formas específicas. Em
suma, existem dois tamanhos, o tamanho do elemento e da superfície de
desenho. Quando o tamanho do elemento é maior do que o da superfície
de desenho do documento escala a superfície de desenho para preencher o
elemento, o que pode gerar resultados inesperados.

\section{WebGL}

Como WebGL é baseada na versão otimizada para dispositivos móveis do
OpenGL não é possível utilizar muitos recursos especiais disponível
para os ambientes desktop.

Segundo \cite{html5mostwanted} um dos problemas do WebGL é sua alta
curva de aprendizagem e o fato de não ter suporte para o Internet
Explorer. Entretanto o suporte foi adicionado na última versão do
Internet Explorer (11). Não obstante a dificuldade de utilização
ainda persiste, forçando a maioria dos desenvolvedores a utilizarem
abstrações criadas por bibliotecas de terceiros.


É importante ressaltar que o WebGL não se comporta de maneira
simétrica nos navegadores que implementam a especificação. Pode haver
diferenças substanciais de performance em plataformas diferentes e em
navegadores diferentes. Existe também uma lista de placas gráficas
com drivers bloqueados por não funcionarem corretamente no Firefox
\autocite[pp.42]{3daps}.

Para ver um programa em WebGL é necessário um navegador recente, uma
placa gráfica recente e um sistema operacional que suporte a tecnologia
\autocite{html5mostwanted}

CocoonJS é uma aplicativo híbrido que preenche a fraca implementação
de WebGL nos dispositivos móveis possibilitando se desenvolver em
WEBGL, CSS. Conta com suporte a dispositivos legados à partir do
Android 2.3 e IPhone 5.

\section{Codecs}

\subsection{ÁUDIO}

Segundo \cite{browserGamesTechnologyAndFuture} em sido difícil
construir aplicações sofisticadas e interativas sem a utilização de
plugins para áudio.
Segundo \cite{html5mostwanted} a limitação do elemento de áudio do
HTML5 é que seu propósito é para executar apenas um som, como o som
de fundo dentro de um jogo.

Durante a concepção do protótipo foi utilizado o elemento audio
para emitir sons na utilização dos botões de resposta do aplicativo, 
não obstante sons consecutivos tiveram problemas no Android. 
Depois de migrado para a API  de áudio os problemas aparentemente foram 
resolvidos. 

Confirmando a afirmação de \cite{html5mostwanted} a API de som é
boa se você deseja apenas tocar alguma música, mas se você está
lançando eventos em um jogo ela é problemática.

Os navegadores variam na disponibilização de formatos aceitáveis
Somente um áudio pode ser tocado no Navegador do Android

Não é possível trocar o volume no IOS.

Alguns navegadores favorecem formatos OGG (vorbis) e outros, como o
Safari, favorecem o MP3.

Segundo \cite{html5Tradeoffs}
\begin{quote}
O maior problema com as API's de áudio e de vídeo do HTML5 é
a disputa entre os codecs dos navegadores. Por exemplo, Mozilla e
Opera suportam Theora, já o Safari suporta H.264 que também é
suportado pelo IE9. Ambos, Iphone e Android suportam H.264 em seus
navegadores. A W3C recomenda OggVorbis e OggTheora para áudio e vídeo
respectivamente.
\end{quote}

\subsection{VIDEO}

O suporte a vídeo apesar de estar melhorando ainda é básico. No
Silverlight existem uma coleção de possibilidades como aplicar shaders
diretamente no vídeo e streaming suave de 1080px HD \autocite[pp.
8]{researchOnHtml}.

O projeto \textit{Vídeo for Everybody}
\url{http://camendesign.com/code/video_for_everybody} é um polyfill que
recorre à flash quando o vídeo não é suportado pelo navegador.

Não é possível controlar a entrada em tela cheia através de script
pois é considerado uma violação de segurança. Não obstante,
os navegadores tem a opção de deixar os usuários escolherem ver
vídeos em tela cheia através de controles adicionais \autocite[pp.
68]{proHtml5}.

As tecnologias de mídia são restringidas pelo política de mesma
origem \autocite[pp. 68]{proHtml5}.

\section{Armazenamento}

IndexedDB é uma API interessante mas para projetos menores é um tanto complexa.

\section{OFFLINE}

Nos arquivos de cache via manifestos, quando o download falha, o
navegador emite um evento mas não há indicação de qual problema
aconteceu. Isso pode tornar a depuração ainda mais complicada que o
usual \autocite{diveIntohtml}.

Este problema aconteceu durante o desenvolvimento do protótipo e foi
trabalhoso de depurar até descobrir que um arquivo estava faltando, e
qual especificamente.

Refresh duplo para ver assets cacheados. Ver:
http://buildnewgames.com/game-asset-management/

\section{Orientação}

Visto que a especificação o suporte está longe de completo, até
o momento da pesquisa o único navegador popular que implementa a
especificação completamente é o Edge da Microsoft.

Outrossim, existem diferenças substanciais entre navegadores, por
exemplo: O Firefox e Google Chrome não manipulam angulos da mesma
forma, por conseguinte alguns eixos se comportam de maneiras opostas
\autocite{mdnOrientation}. O polyfill gyronorm.js é uma tentativa de
normalizar o uso de dados de orientação nos navegadores que pode ser
utilizada até a especificação e os navegadores evoluírem.

\section{Detecção de recursos}

Grande parte da detecção de funcionalidades é feita através de
JavaScript, isso força os desenvolvedores a criarem pelo menos parte da
marcação em JavaScript, isso pode ser um fator limitante para o uso
generalizado de HTML5 \autocite{diveIntohtml}.

\section{Debug}

Com o depurador do Google Chrome remoto foi observado uma falta de
sincronia na atualização da imagem no computador. Os efeitos do CSS
não são bem apresentados e algumas vezes a tela foi completamente
alterada (como na mudança de páginas) e no computador o estado
anterior é apresentado.

O inspetor de canvas nativo do Google Chrome foi removido pois continha
comportamentos indesejáveis para os desenvolvedores do navegador
\autocite{canvasinspector}. Os desenvolvedores mencionaram criar uma
extensão para a funcionalidade mas até o tempo de desenvolvimento
deste trabalho não havia nenhuma disponível. A única alternativa
viável até o momento é utilizar uma versão antiga do Chromium.

O Firefox introduziu uma ferramenta de inspeção para o canvas 2D
em uma Conferência de desenvolvimento de jogos em São Francisco em 2014,
mas até a tecnologia não apareceu no navegador \autocite{firefoxCanvasDebug}.

Atualmente a área de ferramentas para depuração do canvas 2D estão
comprometidas por não existir um plugin de terceiro tão bem
consolidado como o WebGl Inspector. O projeto Canvas Interceptor é
uma iniciativa para preencher esta demanda permitindo capturar alguns
eventos do contexto 2d e tirar \textit{snapshoots} dos passos da renderização
do canvas. Entretanto, o projeto requer que o desenvolvedor inclua
um arquivo JavaScript em seu projeto e inicialize o depurador dentro do código,
se tornando uma saída mais custosa do que um inspetor nativo no
navegador ou via extensão. \footnote{Mais informações sobre o
projeto Canvas Interceptor podem ser encontradas no seguinte endereço
https://github.com/Rob--W/canvas-interceptor}

\section{Entrada de comandos}

\subsection{Gamepad}
Chrome does things differently here. Instead of constantly storing the gamepad's latest state in a variable it only stores a snapshot, so to do the same thing in Chrome you have to keep polling it and then only use the Gamepad object in code when it is available.

\section{Disponibilização}

O serviço PhoneGap Build não contém a última versão do PhoneGap e
não é possível utilizar plugins através deles. Embora no protótipo
isso não tenha sido um problema, em projetos maiores estes tipos de
requerimentos podem ser vitais.

\section{Recursos}
Apesar da grande maioria dos recursos oferecidos nativamente
nos dispositivos estar presente em HTML5 ainda existem algumas
funcionalidades faltando para este tipo de aplicação.

\cite{html5Tradeoffs} cita algumas limitações no contexto geral
\begin{quote}
Não podemos mudar a imagem de fundo do dispositivo, ou adicionar toques
etc. Similarmente, existem muitas API's de nuvem como os serviços
de impressão do ICloud ou Google Cloud que estão disponíveis para
aplicações nativas mas não para HTML5. Outros serviços utilitários
como o C2DM do Google que está disponível para desenvolvedores Android
para utilizar serviços de \textit{push} também não estão disponíveis
para o HTML5.
\end{quote}

\cite{browserGamesTechnologyAndFuture} apresenta as seguintes limitações
no contexto de jogos de navegador.

\begin{itemize}
\item Não podem ser instalados em um dispositivo móvel como um aplicativo separado
\item Não tem acesso a funcionalidades específicas dos dispositivos e recursos como notificações, use de hardware nativo ou comunicação entre aplicativos.
\end{itemize}

\section{Monetização}

É muitas vezes difícil encontra oportunidades financeiras em jogos
para navegador, visto que não existem pacotes de jogos para vender
\autocite[pp. 44]{gameCommunities}.

Os desenvolvedores são muitas vezes forçados a criar formas alternativas
de lucro. A monetização de aplicativos WEB é geralmente feita através de
propagandas \autocite[pp. 44]{gameCommunities}. Outra saída é a venda
de recursos extra, \cite[pp. 44]{gameCommunities} afirma
que a venda de moeda virtual é uma forma comum monetização.

Não obstante jogos WEB podem ser integrados pelos desenvolvedores
a sistemas de pagamento - possivelmente aumentado a complexidade da
aplicação. Ou serem integrados a algum mercado como o do Android, se
optarem pela arquitetura híbrida.

\section{VERSÕES}

A grande maioria dos dispositivos atualmente no mercado utilizam
obsoletas de seus softwares.

Além das versões obsoletas existe o problema de muitos navegadores 
implementarem especificações incompleta ou incorretamente.

Segundo \cite{crossPlatformMobileGame}
\begin{quote}
Enquanto o HTML é desenvolvido muitas das funcionalidades
disponibilizadas são testadas em um pequeno conjunto de navegadores
para um pequeno conjunto de versões. Isso acarreta em suporte
inconsistente. A forma mais segura de garantir suporte é testando em
todas as versões alvo, todavia essa solução não é prática.
\end{quote}

O Crosswalk é uma tecnologia que pode resolver parcialmente o problema
de versões de software antigas para Android. Visto que a aplicação
é disponibilizada juntamente com uma versão recente do navegador que
a irá rodá-la. Não obstante, o Crosswalk só é suportado
para Android \footnote{Nos apêndices o Crosswalk é tratado com mais
detalhes}.

\section{PERFORMANCE}

Otimizações de performance dependem do ambiente em que estão
sendo feitas. E aquelas que hoje tem um impacto positivo hoje
podem se tornar inúteis, ou mesmo prejudiciais, amanhã
\autocite[pp.131]{html5mostwanted}.

\subsubsection{ASSETS}

Trafegar muitos assets deixa o sistema lento. Pode-se contornar este
problema utilizando páginas de carregamento e/ou cache;

Outro problema relativo aos assets é descrito por \cite{howBrowsersWork}
scripts requerendo informações de estilo durante o processo de
parse. Se o estilo ainda não foi carregado o script vai utilizar
informações erradas, causando uma série de problemas.


A tabela abaixo demonstra é um comparativo das tecnologias
pesquisadas, relevantes aos jogos e seu suporte.

\begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|  }
\hline
Tecnologia & Suporte nos navegadores atuais & Polyfills disponíveis  para versões antigas \\
\hline
WebSoket & Sim & Sim \\
\hline
\end{tabular}

