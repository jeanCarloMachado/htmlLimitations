
Muitos das limitações dos jogos multiplataforma não são
problemas específicos dos jogos, mas aplicam-se a todos tipos
de software \autocite[pp. 3]{currentStateCrossPlatform}. Alguns
problemas são inerentes da categoria multiplataforma \cite[pp.
7 ]{viabilityBusinessApplications} afirma que é geralmente muito
mais complexo obter aparência nativa, funcionalidade e performance
em aplicações multiplataforma. Outros problemas derivam-se dos
dispositivos ou da tecnologia atual.

A abaixo constam as limitações do HTML5 aplicáveis, mesmo que não
exclusivamente, aos jogos encontradas durante a pesquisa e concepção
do protótipo. Quando possível, buscou-se apresentar as limitações
na mesma ordem das tecnologias estudadas na revisão bibliográfica.
Não obstante, algumas limitaçãos como performance e versões foram
tratadas em uma partes separadas visto que se aplicam a várias das
tecnologias da WEB.

\section{HTML}

Segundo \cite{crossPlatformMobileGame}
\begin{quote}
Enquanto o HTML é desenvolvido muitas das funcionalidades
disponibilizadas são testadas em um pequeno conjunto de navegadores
para um pequeno conjunto de versões. Isso acarreta em suporte
inconsistente. A forma mais segura de garantir suporte é testando em
todas as versões alvo, todavia essa solução não é prática.
\end{quote}

O Crosswalk é uma tecnologia que pode resolver parcialmente o problema
de versões de software antigas para Android. Visto que a aplicação
é disponibilizada juntamente com uma versão recente do navegador que
a irá rodá-la. Não obstante, o Crosswalk só é suportado
para Android \footnote{Nos apêndices o Crosswalk é tratado com mais
detalhes}.


\section{CSS}

É muito custoso desenvolver uma interfaces que pareçam nativas para
cada dispositivo sem a utilização de plugins e ferramentas. No
protótipo foi utilizada uma estilização simples, que pode se parecer
natural na WEB; não obstante, nos dispositivos móveis, o layout criado
é muito diferente da experiência normal nestes aparelhos.

Uma solução para este problema é utilizar frameworks como o jQuery
Mobile e Kendo UI Mobile \footnote{Mais informações sobre o Kendo UI
e jQuery Mobile podem ser encontradas nos apêndices}. Estes frameworks
permitem criar elementos típicos de interfaces mobile como listas
com scroll, botões e transições com uma aparência nativa de forma
relativamente fácil \autocite{publishHtml5}.

Em alguns casos o tamanho das telas pode ser um fator limitante –
como no caso de jogos de estratégia, nestes casos, jogadores com telas
menores podem sair em desvantagem.

Na perspectiva do desenvolvedor, pode-se lidar com múltiplos tamanhos
de tela trabalhando com tamanhos relativos via CSS. Não obstante, há
casos, como o dos botões de certo e errado do protótipo, em que a
proporções ficam exageradas, nesses casos utilizar controles como o
\textit{max-width} e \textit{min-width} é uma solução conveniente.

Outro fator problemático do CSS é a presença de prefixos. Tecnologias
experimentais do CSS geralmente levam o nome do distribuidor como
prefixo. Utilizar as mesmas regras em CSS com prefixos diferentes para
suportar diversos motores de renderização é um processo entediante e
propenso à duplicação e erros. A biblioteca \textit{-prefix-free} é
uma possível solução para este problema, detectando automaticamente
quando prefixos são necessários e adicionado-os em tempo de execução
\footnote{Mais informações sobre a biblioteca pode ser encontradas nos
apêndices}.

\section{JavaScript}

O JavaScript, por ser uma linguagem desenvolvida por consenso, tem um
ciclo de vida de atualizações demorado; pois necessita que todos os
consumidores da especificação entrem em acordo. Com a especificação
pronta, outra fase demorada é a adoção das tecnologias nos
navegadores, o site \url{https://kangax.github.io/compat-table/es6/}
contém uma lista do suporte aos recursos do ECMAScript 6 nos motores
JavaScript.

Por ser uma linguagem interpretada, erros tem de descobertos rodando
a aplicação. Alternativamente se JavaScript fosse compilado vários
problemas poderiam ser capturados e informações úteis reveladas antes
de se testar \autocite[pp. 12]{viabilityBusinessApplications}.

Aplicações para produção muitas vezes necessitam ser minificadas por
performance e ofuscação. Sem a utilização de automatizadores como o
Grunt Watch essa tarefa é entediante e propensa a erros.

Segundo \cite{htmlResearchJournal}, um problema do JavaScript é que
não é possível transferir métodos de objetos através de sistemas,
via WebSocket, somente dados. Uma forma de contornar este problema é
utilizar funções para converter os dados em objetos em cada ponta do
processamento mas isto adiciona complexidade ao software.

\cite{howBrowsersWork} cita que scripts requerendo informações de
estilo durante o processo de parse. Se o estilo ainda não foi carregado
o script vai utilizar informações erradas, causando uma série de
problemas. Pode-se contornar este problema executando scripts apenas 
ao final da renderização.

\subsection{Sistema de tipos}

O sistema de tipos do JavaScript também é problemático.
Erros numéricos resultam no valor NaN (\textit{not a number}).
Todas as operações com NaN como operadores irão retornar outro
NaN. Isso torna a depuração de erros desnecessariamente complexa
\autocite{html5mostwanted}.

Ao testar o tipo (\textit{typeof}) de uma variável vazia o JavaScript
retorna como se fosse um objeto.

\begin{figure}[H]
\centering
\begin{verbatim}
function is(type, object) {
    type = type[0].toUpperCase + type.slice(1);
    return Object.prototype.toString.call(object)
    === '[object ]' +  type + ']';
}
\end{verbatim}
\caption{Função para testar tipos que funciona como o esperado.}
\label{fig:fixJSTypes}
\source{\url{http://www.slideshare.net/fdaciuk/javascript-secrets-front-in-floripa-2015}}
\end{figure}

A figura \ref{fig:fixJSTypes} demonstra uma solução possível para
remediar o problema dos testes de tipos em JavaScript. A diferença
desta função é que ela converte a variável que se está testando
para sua representação em texto a qual contém o nome do tipo escrito
por extenso - utilizando-se deste valor pode-se deduzir o tipo da
variável corretamente.

\subsection{Performance}

Apesar da performance ter notavelmente melhorado, ainda é geralmente
menos eficiente produzir animações em JavaScript do que utilizando
transições e animações do CSS, que por sua vez são mais otimizados
e acelerados via hardware \autocite{html5mostwanted}.

O WEB Assembly pode resolver este problema, substituindo o JavaScript
para os casos onde grande performance é necessária. Mas para isso o
Web Assembly precisa evoluir na especificação e implementações.

\subsection{Fullscreen}

Não existe forma padronizada de detectar se uma aplicação está em
tela cheia ou não através de JavaScript. O IOS suporta a variável
\textit{navigator.standalone } para identificar se a aplicação está
em tela cheia. \cite{homescreenwebapps} recomenda a utilização do
trecho de código para determinar se está em modo tela cheia
nos demais navegadores.

\begin{figure}[H]
\centering
\begin{verbatim}
navigator.standalone = navigator.standalone 
|| (screen.height-document.documentElement.clientHeight<40)
\end{verbatim}
\caption{Teste de tela cheia}
\label{fig:fixJSTypes}
\source{\url{http://www.mobilexweb.com/blog/home-screen-web-apps-android-chrome-31}}
\end{figure}


\section{Android}

Segundo \cite{chromeWebView} da versão 4.4 do Android em diante a
WebView mudou de um projeto local para utilizar o Chromium. Entretanto,
grande parcela dos usuários Android ainda utilizam o sistema antigo o
que força os desenvolvedores suportarem ambas as versões. É razoável
afirmar que para o início de 2016 um terço dos usuários de Android
ainda utilizem a versão antiga da WebView \cite{chromeWebView}.

\section{SVG}

Uma das grandes vantagens do SVG é que é definido via linguagem de
marcação e se integra bem com as demais tecnologias da WEB. Não
obstante, isso também implica em problemas de performance para arquivos
muito grandes pois os elementos são manipulados via DOM. Segundo
\cite{html5mostwanted} a grande desvantagem do SVG é que quão maior o
documento mais lenta a renderização.

Controle refinado também é um problema do SVG \cite{html5mostwanted}
cita que um aspecto negativo do SVG é que é muito difícil atingir a
perfeição na posição dos pixels, por ser uma linguagem vetorizada

\section{Canvas}

A literatura aponta várias limitações distintas na API do canvas.
Segundo \autocite{html5mostwanted}, os aspectos negativos do canvas é
que a performance varia de plataformas para plataformas e não existe
implementação nativa para animações.

\subsection{Performance}

O problema de performance mencionado pode ser parcialmente remediado
com o FastCanvas. FastCanvas é uma implementação nativa em C++ do
canvas para Android que roda separadamente do JavaScript. Devidas as
características acima citadas FastCanvas é substancialmente mais
rápido do que a tag canvas para navegadores Android. Não obstante, o
FastCanvas não suporta a especificação do canvas completamente, e
existem umas diferenças no comportamento entre o canvas original e o
FastCanvas.

\subsection{Integrações}

A implementação de animações de fato não existe no canvas,
similarmente carece-se de integração com as demais tecnologias
da WEB. Os desenhos do canvas não podem ser acessados via DOM nem
serem manipulados via CSS, todas as modificações necessárias devem
ser feitas através de JavaScript.
No protótipo, especificamente na classe \textit{Countdown}, foi necessário
adicionar regras de estilo no JavaScript para a interação com o canvas
ficar completa.

CSS já conta com definições quanto a animações e a manipulação de
elementos do canvas através do DOM facilitaria uma gama de situações.
Por exemplo, seria possível utilizar os eventos do DOM para capturar
interações do usuário através de elementos utilizados no canvas.
Se um retângulo fosse clicado o evento seria lançado a partir dele.
Controle similar é implementado atualmente acessando as coordenadas
do canvas onde uma interação aconteceu e fazendo o processamento com
aquela determinada área.

Felizmente a integração entre o canvas e as demais tecnologias da
WEB está começando a acontecer. A interoperabilidade entre o Path2D
do canvas e a notação SVG é uma iniciativa na direção correta,
tornando ambas tecnologias cada vez relevantes e dinâmicas.

Outra característica peculiar, descoberta durante o desenvolvimento
do protótipo, é que o Canvas pode gerar resultados inesperados se
seus tamanhos de elemento e tela diferirem de formas específicas. Em
suma, existem dois tamanhos, o tamanho do elemento e da superfície de
desenho. Quando o tamanho do elemento é maior do que o da superfície
de desenho do documento escala a superfície de desenho para preencher o
elemento, o que pode gerar resultados inesperados.

\section{WebGL}

Como WebGL é baseada na versão otimizada para dispositivos móveis do
OpenGL não é possível utilizar muitos recursos especiais disponíveis
para os ambientes desktop. Como a definição de caminhos com a função
\textit{glBegin} e a impossibilidade de utilizar pontos flutuantes para
calcular coordenadas de vértices \autocite{esVsGl}.

Segundo \cite{html5mostwanted} um dos problemas do WebGL é sua alta
curva de aprendizagem e o fato de não ter suporte para o Internet
Explorer. Entretanto, o suporte foi adicionado na última versão do
Internet Explorer (11). Infelizmente a dificuldade de utilização
ainda persiste, forçando a maioria dos desenvolvedores a utilizarem
abstrações criadas por bibliotecas de terceiros \footnote{Os apendices
contém algumas destas bibliotecas como o tree.JavaScript}.

É importante ressaltar que o WebGL não se comporta de maneira
simétrica nos navegadores que implementam a especificação. Pode haver
diferenças substanciais de performance em plataformas diferentes e em
navegadores diferentes. Existe também uma lista de placas gráficas com
\textit{drivers} bloqueados por não funcionarem corretamente no Firefox
\autocite[pp.42]{3daps}.

Para ver um programa em WebGL é necessário um navegador recente, uma
placa gráfica recente e um sistema operacional que suporte a tecnologia
\autocite{html5mostwanted}

CocoonJS é uma aplicativo híbrido que preenche a fraca implementação
de WebGL nos dispositivos móveis possibilitando se desenvolver em
WEBGL, CSS. Conta com suporte a dispositivos legados à partir do
Android 2.3 e IPhone 5.

\subsection{ÁUDIO}

Segundo \cite{html5mostwanted} a limitação do elemento de áudio do
HTML5 é que seu propósito é para executar apenas um som, como o som
de fundo dentro de um jogo. Não sendo adequada para efeitos sonoros 
ou necessidades flexíveis de áudio.

Durante a concepção do protótipo foi utilizada a API de audio, devido
sua maior flexibilidade. Infelizmente, algumas vezes o som não é
executado ou demora até executar de modo de o que é executado ao mesmo
tempo que o próximo som.

A experimentação do protótipo relativo a API de áudio confirmou as
afirmações de \cite{html5mostwanted} a API de som é boa se você
deseja apenas tocar alguma música, mas se você está lançando eventos
em um jogo ela ainda é problemática.

Outro problema de áudio em HTML5 são os codecs. Alguns navegadores
favorecem formatos OGG (vorbis) e outros, como o Safari, favorecem o
MP3.

Audio no Safari do IOS contém alguns problemas específicos.
Por exemplo, não é possível trocar o volume através de
JavaScript também não é possível tocar mais de um som ou vídeo
simultaneamente \autocite{unsolvedMediaHtmlIssues}.

\subsection{VIDEO}

O suporte a vídeo, apesar de estar melhorando, ainda é rudimentar. No
Silverlight existem uma coleção de possibilidades como aplicar shaders
diretamente no vídeo e streaming suave de 1080px HD \autocite[pp.
8]{researchOnHtml}.

Não é possível controlar a entrada em tela cheia através de script
pois é considerado uma violação de segurança. Não obstante,
os navegadores tem a opção de deixar os usuários escolherem ver
vídeos em tela cheia através de controles adicionais \autocite[pp.
68]{proHtml5}.

Assim como áudio o elemento \textit{video} sofre com problemas de
codecs, segundo \cite{html5Tradeoffs}:
\begin{quote}
O maior problema com as API's de áudio e de vídeo do HTML5 é
a disputa entre os codecs dos navegadores. Por exemplo, Mozilla e
Opera suportam Theora, já o Safari suporta H.264 que também é
suportado pelo IE9. Ambos, Iphone e Android suportam H.264 em seus
navegadores. A W3C recomenda OggVorbis e OggTheora para áudio e vídeo
respectivamente.
\end{quote}

O Safari do IOS também contém problemas exclusivos de vídeo. Segundo
\cite{unsolvedMediaHtmlIssues} não é possível capturar frames de
vídeo usando o método \textit{drawImage} do canvas. Também não é
possível pré carregar arquivos de vídeo sem iteração do usuário, entre outros.

Para os raros casos onde o suporte a vídeo não existe,
como no Opera Mini, o projeto \textit{Vídeo for Everybody}
\url{http://camendesign.com/code/video_for_everybody} é um polyfill que
recorre à flash para apresentar o conteúdo.

\section{Armazenamento}

Não existe tecnologia oficial que permita a utilização de tecnologias
SQL para Frontend. O WebSQL foi uma tentativa nesta direção mas, visto
que não continha mais de uma implementação, foi descontinuado. SQL seria 
interessante pois muitos desenvolvedores tem experiência  com este tipo de tecnologia
e suporta estruturas de filtragem de dados realmente poderosas.

\subsection{Web Storage}

Muitos navegadores não permitem armazenar mais de 5M por domínio
em Web Storage, apesar da especificação permitir fazê-lo
\autocite{gameAssetManagement}. Também não é possível saber
quanto espaço já foi consumido pelo Web Storage.

Outra limitação do Web Storage é que todas as informações são
guardadas como texto. Isso força a converter os valores toda a vez que
algo for armazenado ou recuperado \autocite{gameAssetManagement}..

No protótipo isso não foi problemático pois não existe grande
manipulação sobre os dados. Mas no caso de jogos mais complexos esta
característica do Web Storage pode ser uma limitação substancial.

\section{OFFLINE}

Nos arquivos de cache via manifestos, quando o download falha, o
navegador emite um evento mas não há indicação de qual problema
aconteceu. Isso pode tornar a depuração ainda mais complicada que o
usual \autocite{diveIntohtml}. 

Este problema aconteceu durante o desenvolvimento do protótipo e foi
trabalhoso de depurar até descobrir que um arquivo estava faltando,
e qual especificamente. Uma coleção de códigos de erro e suas
respectivas mensagens na especificação poderia solucionar este
problema.

Os itens da palavra chave \textit{NETWORK:} apresentam um
comportamento não intuitivo. Arquivos de rede que não
são declarados ali não poderão ser consumidos uma vez
que exista cache na aplicação. O exemplo neste endereço
\url{http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-net
work/} exemplifica o funcionamento. Segundo \cite{gameAssetManagement} a
especificação define que se um arquivo não for listado em alguma das
seções do cache então o arquivo não estará disponível de qualquer
forma para a aplicação.

\section{Orientação}

Visto que a especificação o suporte está longe de completo, até
o momento da pesquisa o único navegador popular que implementa a
especificação completamente é o Edge da Microsoft.

Por conseguinte, existem diferenças substanciais entre navegadores. Por
exemplo: O Firefox e Google Chrome não manipulam ângulos da mesma
forma, por conseguinte alguns eixos se comportam de maneiras opostas
\autocite{mdnOrientation}. O polyfill \textit{gyronorm.js} é uma
tentativa de normalizar o uso de dados de orientação nos navegadores
que pode ser utilizada até a especificação e os navegadores
evoluírem.

\section{Detecção de recursos}

\autocite{diveIntohtml} cita que:
\begin{quote}
Grande parte da detecção de funcionalidades é feita através de
JavaScript, isso força os desenvolvedores a criarem pelo menos parte da
marcação em JavaScript, isso pode ser um fator limitante para o uso
generalizado de HTML5.
\end{quote}

\section{Debug}

Com o depurador remoto do Google Chrome foi observado uma falta de
sincronia nas taxas de atualização de imagem no computador. Os
efeitos do CSS não são bem apresentados sendo provavelmente difícil
depurar animações. Em alguns casos quando a tela foi modificada
substancialmente (com nas mudanças de tela) a mudança de estado no
computador levou vários segundos para ser atualizada.

Outro problema do depurar do Chrome é que não existe inspetor nativo
de canvas. O inspetor de embutido do Google Chrome foi removido pois
continha comportamentos indesejáveis para os desenvolvedores do
navegador \autocite{canvasinspector}.

Os desenvolvedores mencionaram criar uma extensão para a funcionalidade
mas até o tempo de desenvolvimento deste trabalho não havia nenhuma
disponível. A única alternativa viável até o momento é utilizar uma
versão antiga do Chromium.

O Firefox introduziu uma ferramenta de inspeção para o canvas 2D
em uma Conferência de desenvolvimento de jogos em São Francisco em 2014,
mas até a tecnologia não apareceu no navegador \autocite{firefoxCanvasDebug}.

Atualmente a área de ferramentas para depuração do canvas 2D está
parcialmente comprometida por não existir um plugin de terceiro
onipresente nos navegadores como o WebGl Inspector.

O projeto Canvas Interceptor é uma iniciativa para preencher
esta demanda permitindo capturar alguns eventos do contexto 2D e
tirar \textit{snapshoots} dos passos da renderização do canvas.
Entretanto, o projeto requer que o desenvolvedor inclua um arquivo
JavaScript em seu projeto e inicialize o depurador dentro do código,
se tornando uma saída mais custosa do que um inspetor integrado
no navegador ou via extensão \footnote{Mais informações sobre o
projeto Canvas Interceptor podem ser encontradas no seguinte endereço
\url{https://github.com/Rob--W/canvas-interceptor}}.

\section{Entrada de comandos}

\autocite[pp. 9]{aSeriousContender} cita que: fazer scroll juntamente
com gestos de ações similares é uma área onde o HTML ainda é
fraco. Para contornar este problema pode-se utilizar bibliotecas como o
iScroll, TouchScroll, GloveBox, Sencha, jQuery Mobile, entre outros.

\subsection{Gamepad}

A forma de gerenciar a conexão de Gamepads é diferente entre o Firefox
e Google Chrome. No Firefox é lançado um evento toda a vez que o
Gamepad é desconectado, já no Google Chrome é necessário verificar
um vetor de gamepads pela existência do objeto de tempos em tempos \autocite{gamepad}.
Este problema é reflexo da especificação ainda incompleta e força os
desenvolvedores a duplicarem a mesma atividade no código.

\section{Disponibilização}

Para serviços híbridos, durante o desenvolvimento notou-se que o
serviço PhoneGap Build não contém a última versão do PhoneGap e
não é possível utilizar plugins através deles. Embora no protótipo
isso não tenha sido um problema, em projetos maiores estes tipos de
requerimentos podem ser essenciais.

Outra limitação de disponibilização, neste caso para aplicativos
WEB puros é que a possibilidade de adicionar aplicativos a área de
trabalho está disponível apenas para o Safari e Google Chrome. Este
tipo de possibilidade é importante por gerar uma experiência similar a
nativa para aplicativos puramente WEB.

\subsection{Monetização}

Outro aspecto que pode ser limitante para aplicações WEB é sua forma
de monetização. É muitas vezes difícil encontra oportunidades
financeiras em jogos para navegador, visto que não existem pacotes de
jogos para vender \autocite[pp. 44]{gameCommunities}.

Dado este este problema, desenvolvedores são muitas vezes forçados
a criar formas alternativas de lucro. A monetização de aplicativos
WEB é geralmente feita através de propagandas \autocite[pp.
44]{gameCommunities}. Outra saída é a venda de recursos extra,
\cite[pp. 44]{gameCommunities} afirma que a venda de moeda virtual é
uma forma comum de monetização em jogos.

Não obstante jogos WEB podem ser integrados pelos desenvolvedores
a sistemas de pagamento - possivelmente aumentado a complexidade da
aplicação. Ou serem integrados a algum mercado como o do Android, se
optarem pela arquitetura híbrida.

\section{Outras Limitações}

\cite{html5Tradeoffs} cita algumas limitações em uma âmbito geral:
\begin{quote}
Não podemos mudar a imagem de fundo do dispositivo, ou adicionar toques
etc. Similarmente, existem muitas API's de nuvem como os serviços
de impressão do ICloud ou Google Cloud que estão disponíveis para
aplicações nativas mas não para HTML5. Outros serviços utilitários
como o C2DM do Google que está disponível para desenvolvedores Android
para utilizar serviços de \textit{push} também não estão disponíveis
para o HTML5.
\end{quote}

\section{Navegadores}

A tabela abaixo demonstra é um comparativo das tecnologias pesquisadas,
relevantes aos jogos e seu suporte. As informações de suporte foram
extraídas do site Can I Use e os navegadores populares em questão
são: Internet Explorer (11), Edge (13), Firefox (43), Google Chorme
(47), Safari (9) e Opera(34).

\begin{tabular}{ |p{3cm}|p{3cm}|p{3cm}|  }
\hline
Tecnologia & Suporte nas últimas versões estáveis dos navegadores populares & Polyfills disponíveis  para versões antigas \\
\hline
Canvas & Sim & Sim \\
SVG & Sim & Sim \\
Gamepad & Não & Sim \\
WebGL & Parcial & Sim \\
WebSockets & Sim & Sim \\
Video & Sim & Sim \\
Audio & Sim & Sim \\
IndexedDB & Parcial & Sim \\
WebCL & Não & Não \\
WebVR & Não & Não \\
WebAssembly & Não & Sim \\
Tag áudio & Sim & Sim \\
Áudio API & Não & Sim \\
Vídeo & Não & Sim \\
Prefetch & Não & Sim \\
\hline
\end{tabular}

Com este comparativo fica visível que, mesmo em alguns casos não
existindo suporte nativo ou ele sendo incompleto e com limitações, na
vasta maioria dos casos é possível utilizar as tecnologias da WEB para
jogos.

