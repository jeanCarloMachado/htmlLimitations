\begin{draft}

Muitos das limitações dos jogos multiplataforma não são
específicos dos jogos, mas aplicam-se a todos tipos de software
\parencite{currentStateCrossPlatform}. Alguns problemas são inerentes
das tecnologias, outras dos dispositivos ou da característica
multiplataforma.

Não obstante, abaixo constam as limitações aplicáveis, mesmo
que não exclusivamente, aos jogos. Encontradas durante a pesquisa e
concepção do protótipo.

\section{VERSÕES}

A grande maioria dos dispositivos atualmente no mercado utilizam
obsoletas de seus softwares.

Segundo \cite{crossPlatformMobileGame}
\begin{quote}
Enquanto o HTML é desenvolvido muitas das funcionalidades
disponibilizadas são testadas em um pequeno conjunto de
navegadores para um pequeno conjunto de versões. Isso
acarreta em suporte inconsistente. A forma mais segura de garantir
suporte é testando em todas as versões alvo, todavia essa solução
não é prática.
\end{quote}

O Crosswalk é uma tecnologia que pode resolver parcialmente
este problema para jogos híbridos. Visto que a aplicação é
disponibilizada juntamente com uma versão recente do navegador que a
irá rodá-la versões de software para dispositivos móveis não é
um problema problema. Não obstante, o Crosswalk só é suportado para
Android \footnote{Nos apêndices o Crosswalk é tratado com mais detalhes}.

\section{CSS}

É muito custoso desenvolver uma interfaces que pareçam nativas
para cada dispositivo sem a utilização de plugins e ferramentas
. 

Em termos gerais, trabalhar com proporções é positivo. Não obstante
há casos, como o dos botões de certo e errado que a proporções ficam
exageradas, nesses casos a utilizada de max-width é uma solução
conveniente.

Frameworks como o Ionic e Sencha Touch  possibilitam criar elementos 
típicos de interfaces mobile como listas com scroll, botões e transições
facilmente \autocite{publishHtml5}.

\subsubsection{TAMANHO DE TELA}
Em alguns casos o tamanho das telas pode ser um fator limitante – como
no caso de jogos de estratégia. Jogadores com telas menores podem sair
em desvantagem.

\subsubsection{Scroll}
\autocite[pp. 9]{aSeriousContender} cita que:
Fazer scroll juntamente com gestos de ações similares é uma área
onde o HTML ainda é fraco. Existem várias tentativas para solucionar
esse problema como o iScroll, TouchScroll, GloveBox, Sencha, jQuery
Mobile.

\section{JavaScript}

O JavaScript, por ser uma tecnologia desenvolvida por consenso, tem um
ciclo de vida de atualizações demorado; pois necessita que todos os
consumidores da especificação entrem em consenso e implementem a.

Apesar da performance ter notavelmente melhorado, ainda é geralmente
menos eficiente produzir animações em JavaScript do que utilizando
transições e animações do CSS, que por sua vez são mais otimizados
e acelerados via hardware \autocite{html5mostwanted}.

Erros numéricos resultam no valor NaN (\textit{not a number}).
Todas as operações com NaN como operadores irão retornar outro
NaN. Isso torna a depuração de erros desnecessariamente complexa
\autocite{html5mostwanted}.


\section{SVG}

Segundo \cite{html5mostwanted} a grande desvantagem do SVG é que quão
maior o documento mais lenta a renderização.

\section{Canvas}

A literatura aponta várias limitações distintas na API do canvas.
Segundo \autocite{html5mostwanted}, os aspectos negativos do canvas é
que a performance varia de plataformas para plataformas e não existe
implementação nativa para animações.

O problema de performance  mencionado pode ser remediado com o FastCanvas.
O FastCanvas é uma iniciativa híbrida para Android que busca mitigar os
problemas de performance do Canvas com uma API nativa. Não obstante, o
FastCanvas não suporta a especificação do canvas completamente,

A implementação de animações de fato não existe no canvas,
similarmente carece-se de integração com as demais tecnologias
da WEB. Os desenhos do canvas não podem ser acessados via DOM nem
serem manipulados via CSS, todas as modificações necessárias devem
ser feitas via JavaScript. CSS já conta com definições quanto a
animações e a manipulação de elementos do canvas através do DOM
facilitaria uma gama de situações, por exemplo com interações do
usuário com algum elemento do canvas. Que hoje são geralmente feitos
acessando as coordenadas do canvas onde uma interação aconteceu e
fazendo o processamento com aquela determinada área, poderia ser feito
adicionando-se um \textit{listener} para determinado objeto do canvas.
A interoperabilidade entre o Path2D do canvas e a notação SVG é uma iniciativa
na direção correta, tornando as tecnologias cada vez mais interoperáveis.

No protótipo, especificamente na classe \textit{Countdown}, foi necessário
adicionar regras de estilo no JavaScript para  a interação com o canvas
ficar completa.

Uma característica peculiar descoberta durante o desenvolvimento
do protótipo é que o Canvas pode gerar resultados inesperados se
seus tamanhos de elemento e tela diferirem de formas específicas. Em
suma, existem dois tamanhos, o tamanho do elemento e da superfície de
desenho. Quando o tamanho do elemento é maior do que o da superfície
de desenho do documento escala a superfície de desenho para preencher o
elemento, o que pode gerar resultados inesperados.

\section{WebGL}

Como WebGL é baseada na versão otimizada para dispositivos móveis do
OpenGL não é possível utilizar muitos recursos especiais disponível
para os ambientes desktop.

Segundo \cite{html5mostwanted} um dos problemas do WebGL é sua alta
curva de aprendizagem e o fato de não ter suporte para o Internet
Explorer. Entretanto o suporte foi adicionado na última versão do
Internet Explorer (11). Não obstante a dificuldade de utilização
ainda persiste, forçando a maioria dos desenvolvedores a utilizarem
abstrações criadas por bibliotecas de terceiros.

\footnote{Os apêndices contam com uma coleção de bibliotecas que facilitam a utilização de WebGL}

É importante ressaltar que o WebGL não se comporta de maneira
simétrica nos navegadores que implementam a especificação. Pode haver
diferenças substanciais de performance em plataformas diferentes e em
navegadores diferentes. Existe também uma lista de placas gráficas
com drivers bloqueados por não funcionarem corretamente no Firefox
\autocite[pp.42]{3daps}.

Para ver um programa em WebGL é necessário um navegador recente, uma
placa gráfica recente e um sistema operacional que suporte a tecnologia
\autocite{html5mostwanted}

\section{Codecs}

\subsection{ÁUDIO}

Segundo \cite{browserGamesTechnologyAndFuture} em sido difícil
construir aplicações sofisticadas e interativas sem a utilização de
plugins para áudio.
Segundo \cite{html5mostwanted} a limitação do elemento de áudio do
HTML5 é que seu propósito é para executar apenas um som, como o som
de fundo dentro de um jogo.

A API de som no protótipo nem sempre emite o som quando o
evento é disparado sucessivamente. Confirmando a afirmação de
\cite{html5mostwanted} a API de som é boa se você deseja apenas tocar
alguma música, mas se você está lançando eventos em um jogo ela é
problemática.

Os navegadores variam na disponibilização de formatos aceitáveis
Somente um áudio pode ser tocado no Navegador do Android

Não é possível trocar o volume no IOS.

Alguns navegadores favorecem formatos OGG (vorbis) e outros, como o
Safari, favorecem o MP3.

Segundo \cite{html5Tradeoffs}
\begin{quote}
O maior problema com as API's de áudio e de vídeo do HTML5 é
a disputa entre os codecs dos navegadores. Por exemplo, Mozilla e
Opera suportam Theora, já o Safari suporta H.264 que também é
suportado pelo IE9. Ambos, Iphone e Android suportam H.264 em seus
navegadores. A W3C recomenda OggVorbis e OggTheora para áudio e vídeo
respectivamente.
\end{quote}

\subsection{VIDEO}

O suporte a vídeo apesar de estar melhorando ainda é básico. No
Silverlight existem uma coleção de possibilidades como aplicar shaders
diretamente no vídeo e streaming suave de 1080px HD \autocite[pp.
8]{researchOnHtml}.

O projeto \textit{Vídeo for Everybody} \begin{verbatim}
http://camendesign.com/code/video_for_everybody \end{verbatim} é um
polyfill que recorre à flash quando o vídeo não é suportado pelo
navegador.

Não é possível controlar a entrada em tela cheia através de script pois 
é considerado uma violação de segurança. Não obstante, os navegadores
tem a opção de deixar os usuários escolherem ver vídeos em tela cheia
através de  controles adicionais \autocite[pp. 68]{proHtml5}.

As tecnologias de mídia são restringidas pelo política de mesma origem \autocite[pp. 68]{proHtml5}.

\section{Armazenamento}

Em praticamente nenhuma das tecnologias da WEB é possível armazenar objetos e  seu estado atual.

IndexedDB é uma API interessante mas para projetos menores é um tanto complexa.

\section{OFFLINE}

Quando o download offline falha o navegador emite um evento mas não há
indicação de qual problema aconteceu. Isso pode tornar a depuração
ainda mais complicada que o usual \autocite{diveIntohtml}.


Refresh duplo para ver assets cacheados. Ver:
http://buildnewgames.com/game-asset-management/

\section{Orientação}

Visto que a especificação o suporte está longe de completo, até
o momento da pesquisa o único navegador popular que implementa a
especificação completamente é o Edge da Microsoft.

Outrossim, existem diferenças substanciais entre navegadores, por
exemplo: O Firefox e Google Chrome não manipulam angulos da mesma
forma, por conseguinte alguns eixos se comportam de maneiras opostas
\autocite{mdnOrientation}. O polyfill gyronorm.js é uma tentativa de
normalizar o uso de dados de orientação nos navegadores que pode ser
utilizada até a especificação e os navegadores evoluírem.

\section{Detecção de recursos}

Grande parte da detecção de funcionalidades é feita através de
JavaScript, isso força os desenvolvedores a criarem pelo menos parte da
marcação em JavaScript, isso pode ser um fator limitante para o uso
generalizado de HTML5 \autocite{diveIntohtml}.

\section{Debug}

Com o depurador do Google Chrome remoto foi observado uma falta de
sincronia na atualização da imagem no computador. Os efeitos do CSS
não são bem apresentados e algumas vezes a tela foi completamente
alterada (como na mudança de páginas) e no computador o estado
anterior é apresentado.

O inspetor de canvas nativo do Google Chrome foi removido pois continha
comportamentos indesejáveis para os desenvolvedores do navegador
\autocite{canvasinspector}. Os desenvolvedores mencionaram criar uma
extensão para a funcionalidade mas até o tempo de desenvolvimento
deste trabalho não havia nenhuma disponível. A única alternativa
viável até o momento é utilizar uma versão antiga do Chromium.

O Firefox introduziu uma ferramenta de inspeção para o canvas 2d
em uma Conferência de desenvolvimento de jogos em São Francisco em 2014,
mas até a tecnologia não apareceu no navegador \autocite{firefoxCanvasDebug}.

Atualmente a área de ferramentas para depuração do canvas 2D estão
comprometidas por não existir um plugin de terceiro tão bem
consolidado como o WebGl Inspector. O projeto Canvas Interceptor é
uma iniciativa para preencher esta demanda permitindo capturar alguns
eventos do contexto 2d e tirar \textit{snapshoots} dos passos da renderização
do canvas. Entretanto, o projeto requer que o desenvolvedor inclua
um arquivo JavaScript em seu projeto e inicialize o depurador dentro do código,
se tornando uma saída mais custosa do que um inspetor nativo no
navegador ou via extensão. \footnote{Mais informações sobre o
projeto Canvas Interceptor podem ser encontradas no seguinte endereço
https://github.com/Rob--W/canvas-interceptor}

\section{Recursos}

Apesar da grande maioria dos recursos oferecidos nativamente
nos dispositivos estar presente em HTML5 ainda existem algumas
funcionalidades faltando para este tipo de aplicação.

\cite{html5Tradeoffs} cita algumas limitações no contexto geral
\begin{quote}
Não podemos mudar a imagem de fundo do dispositivo, ou adicionar toques
etc. Similarmente, existem muitas API's de nuvem como os serviços
de impressão do ICloud ou Google Cloud que estão disponíveis para
aplicações nativas mas não para HTML5. Outros serviços utilitários
como o C2DM do Google que está disponível para desenvolvedores Android
para utilizar serviços de \textit{push} também não estão disponíveis
para o HTML5.
\end{quote}

\cite{browserGamesTechnologyAndFuture} apresenta as seguintes limitações
no contexto de jogos de navegador.

\begin{itemize}
\item Não podem ser instalados em um dispositivo móvel como um aplicativo separado
\item Não tem acesso a funcionalidades específicas dos dispositivos e recursos como notificações, use de hardware nativo ou comunicação entre aplicativos.
\end{itemize}

\section{PERFORMANCE}

De acordo com uma pesquisa, para um usuário uma tarefa é instantânea
se ele leva até 0.1 segundos para ser executada. Se a tarefa toma
aproximadamente um segundo então a demora será notada mas o
usuário não se incomodará com ela. Entretanto, se a tarefa leva
aproximadamente 10 segundos para terminar o usuário então começa a
ficar aborrecido e esse é o limite que algum feedback deve ser dado
para um usuário.

Otimizações de performance dependem do ambiente em que estão
sendo feitas. E aquelas que hoje tem um impacto positivo hoje
podem se tornar inúteis, ou mesmo prejudiciais, amanhã
\autocite[pp.131]{html5mostwanted}.

\subsubsection{ASSETS}

Trafegar muitos assets deixa o sistema lento. Pode-se contornar este
problema utilizando páginas de carregamento e/ou cache;

Outro problema relativo aos assets é descrito por \cite{howBrowsersWork}
scripts requerendo informações de estilo durante o processo de
parse. Se o estilo ainda não foi carregado o script vai utilizar
informações erradas, causando uma série de problemas.

\end{draft}
