%{{{
\section{JOGOS}
%{{{
Segundo \autocite{indieGamesLemes} jogo digital constitui-se em uma
atividade lúdica composta por uma série de ações e decisões,
limitada por regras e pelo universo do game, que resultam em uma
condição final.

Video games melhoram as funções cognitivas, melhoram as capacidades criativas, e
motivam uma visão positiva diante a falha \autocite{gamebenefits}.

A natureza dos jogos tem mudado drasticamente na última década, se tornando cada vez mais complexos, diversos, realisticos e sociais em sua natureza \autocite{gamebenefits}.

Habilidades espaciais derivadas de jogar jogos de tiro comercialmente disponíveis são comparáveis aos efeitos de um curso universitário que busca melhorar as mesmas habilidades \autocite{gamebenefits}.


\subsection{Jogos Web}

Não há muito que os títulos de jogos da web residiam em jogos como Traviam, desprovidos de animações. Compostos basicamente por formulários, imagens e textos. Não obstante, publicar jogos baseados em texto é uma atividade cada vez mais rara, sendo assim, pode-se concluir que interface gráfica se tornou uma funcionalidade mandatória \autocite{browserGamesTechnologyAndFuture}.


\cite{browserGamesTechnologyAndFuture} afirma que:
\begin{quote}
Estudos sugerem que flexibilidade, em essência facilidade de entrada e saída, é uma das duas razões principais da utilização de jogos de navegadores. A outra razão primária é o fator social envolvido no jogo.
\end{quote}

%Mencionar algum jogo (como WOW) e como ele faz para prender a atenção dos usuários. Candy Crush saga

\subsection{GÊNEROS}

Uma classificação de jogos em gêneros é uma tarefa complexa. Segundo \autocite{gamebenefits}:

Segundo \cite[pp. 60]{gamebenefits}:
\begin{quote}
Pela diversidade  em itens e gêneros e a vasta quantidade de dimensões que os video games se encontram, uma taxonomia dos jogos contemporâneos é extremamente difícil de desenvolver (muitos já tentaram) .
\end{quote}

Não obstante alguns padrões são discerníveis quanto aos jogos da web.

Os primeiros jogos eram limitados a tecnologias presentes, um gênero de que se desenvolveu bem foram os jogos
de estratégia como o Travian.

Com as novas possibilidades do tecnológicas novas possibilidades e gêneros de jogos podem ser explorados na web.

\subsection{MECÂNICA}

A mecânica é composta pelas regras do jogo. Quais as ações
disponíveis aos usuários, é fortemente influenciada pela categoria do
jogo em questão.

\section{JOGOS MULTIPLATAFORMA}

Jogos em plataformas móveis trazem um novo conjunto de desafios para
produtores de jogos. Um destes desafios é fornecer feedback suficiente
para o jogador pois o dispositivo é limitado em proporções, som, tela
etc.

A interface tem que ser o mais intuitiva o possível. No caso de
dispositivos móveis, quanto menos gestos necessários melhor. Tornar
previsível causa e efeito é uma boa característica para os jogos.
Os desenvolvedores tem que evitar fazer o jogo para eles mesmos.
E pela falta de crítica os designs tendem a ser ruins. Afinal o
que os jogadores querem? LEMES (2009, pg XX) aponta alguns fatores procurados
pelos usuários de jogos: Desafio, socializar, experiência solitária,
respeito e fantasia.

Designers de jogos tem as seguintes possibilidades arquiteturais
quando em face de desenvolver um novo jogo: Criar um jogo web,
um jogo híbrido, ou nativo. As opções serão descritas abaixo.

\subsection{JOGOS WEB}

Um jogo web é um jogo que utiliza o HTML e
ferramentas correlacionadas para sua construção. Este tipo de jogo
é o que será abordado neste trabalho.

Entre seus pontos positivos pode-se listar:

\begin{itemize}
\item Necessitam de uma única base de código e pode rodar em todas as
plataformas;
\item Contém a mais vasta gama de desenvolvedores e muitos
interessados em aprendê-la;
\item Seus custos são inferiores, aos do desenvolvimento nativo devido a 
inexistência de duplicação da base de código;
\item  Não requerem instalação ou atualizações manuais
\item  Sua distribuição é superior ao estilo convencional de aplicações desktop\autocite{browserGamesTechnologyAndFuture}
\end{itemize}

Os pontos negativos dessa abordagem são o principal foco deste trabalho.

Mas a um nível macroscópico podemos citar:
\begin{itemize}
\item Programas que rodam na web são geralmente mais lentos que os
nativos;
\item Por falta de especificação ou incompletude de implementação.
\item Nem todos os recursos disponíveis através das SDK's nativas estão presentes através do HTML5.
\end{itemize}

Além dos jogos web, há a possibilidade de criar jogos híbridos e nativos.

\subsection{JOGOS HÍBRIDOS}

Jogos híbridos são jogos geralmente desenvolvidos com tecnologias da
web que rodam nativamente.

\subsection{DESENVOLVIMENTO DE JOGOS NATIVOS}

Pontos fortes:
\begin{itemize}
\item Habilita a melhor experiência de usuário pois permite utilizar ao
máximo os recursos e funcionalidades dos dispositivos.
\end{itemize}

Pontos fracos:
\begin{itemize}
\item Porém, devido a cada plataforma conter seu próprio sistema operacional,
com seus próprios *SDK's* totalmente incompatíveis, os desenvolvedores são
forçados a desenvolver uma versão do jogo para cada plataforma alvo.
\item Requer mais pessoas, e maior custo com possivelmente parte do mercado não atendido de qualquer forma.
\end{itemize}

%}}}
\section{WEB}
%{{{

\subsection{OPEN WEB}
A OWP (\textit{Open Web Platform}), uma coleção de tecnologias livres,
amplamente utilizadas e padronizadas.
Quando uma tecnologia se torna amplamente popular, através da
adoção de grandes empresas e desenvolvedores ela se torna candidata a
adoção pela OWP.

Mais do que um conjunto de tecnologias Open Web, é um conjunto de
filosofias as quais a web se baseia.

Neste conjunto inclui-se:

\begin{itemize}
\item Descentralização;
\item Transparência;
\item Relevância;
\item Imparcialidade;
\item Consenso;
\item Disponibilidade;
\item Manutibilidade;
\end{itemize}

A W3C é a emprese responsável por grande parte das especificações
da web como: HTML (em conjunto com a WHATWG), CSS, entre outros. 

O processo da W3C consiste na elaboração de rascunhos de
(\textit{working drafts}) que passam por vários passos de revisão
até se tornarem recomendações. As recomendações podem ser implementadas com
segurança de que a especiação não mudará substancialmente.
Apesar do processo ser rigoroso, está longe de perfeito. A
especificação final do HTML4 contava com quatro erros publicados via
errata \autocite{HTML5}.

Outras empresas estão envolvidas nas especificações da web, como a
ECMA, responsável pelo JavaScript; Kronos, responsável pelo WEBGL,
entre outros.

A tecnologia chave que inaugurou e alavancou este processo é o HTML.
%}}}
\section{HTML}
%{{{

HTML (\textit{Hyper Text Markup Language}) é uma linguagem de
marcação que define a estrutura semântica do conteúdo das páginas
da web. Criada por Tim Berners Lee em 1989 no CERN. HTML é a tecnologia
base para a criação de páginas web e aplicativos online. A parte
denominada: "Hipertexto", refere-se a links que conectam páginas umas
as outras, fazendo a Web como conhecemos hoje
\autocite{mdn2015}.

A última versão do HTML é o HTML5, iniciado pela WHATWG
e posteriormente desenvolvido em conjunto com a W3C.
Seu rascunho foi proposto em 2008 e ratificado em 2014.
Após 2011, a última chamada de revisão do HTML5,
a WHATWG decidiu renomear o HTML5 para HTML
\autocite{htmlIsTheNewHtml5}. Não obstante, o termo HTML5
permanece em utilização pela W3C.

Além da nomenclatura, exitem pequenas diferenças nas especificações
da W3C e WHATWG. A W3C vê a especificação do HTML5 como algo fechado,
inclusive já iniciou o desenvolvimento do HTML 5.1. Já a WHATWG vê o
HTML5 como uma especificação viva. A postura da W3C tende a criar uma
especificação mais estável, já a da W3C reflete mais a realidade dos
navegadores, que nunca implementam uma versão completamente. A Mozilla
utiliza a especificação da WHATWG no desenvolvimento do Firefox e
recomenda a da W3C para sistemas que requeiram maior estabilidade. Neste
trabalho optamos pela nomenclatura da WHATWG, utilizamos o termo HTML em
detrimento a HTML5, sempre que semanticamente viável.

HTML foi especificado baseando-se no padrão SGML (\textit{Standard Generalized
Markup Language}).

Alguns benefícios do SGML são:
\begin{itemize}
    \item Documentos declaram estrutura, diferentemente de aparência
, possibilitando otimizações nos ambientes de uso (tamanho de tela,
etc);
    \item São portáveis devido a definição de tipo de documento
(\textit{document type declaration});
\end{itemize}

Apesar de o SGML especificar a não definição de aparência, os criadores de
navegadores constantemente introduziam elementos de apresentação como o
piscar, itálico, e negrito, que eventualmente acabavam por serem inclusos
na especificação. Foi somente nas últimas versões que elementos de
apresentação voltaram a ser proibidos reforçando as propostas chave
do HTML como uma linguagem de conteúdo semântico, incentivando a
utilização de outras tecnologias como o CSS para responder as demandas de
apresentação.

Além do HTML, existe o XHTML, que é uma iniciativa de utilização de
XML nas páginas da web. O XML é um padrão mais rigoroso que SGML e
resulta em páginas sem problemas de sintaxe e tipografia. 
Alguns estimam que 99\% das paginas HTML de hoje
contenham ao menos um erro de estrutura \autocite{diveIntohtml}.
Uma das maiores vantagem do XML é que sistemas sem erros de sintaxe
que podem ser facilmente interpretadas por outras tecnologias como
sistemas de indexação, buscadores, etc.

Para transformar o HTML em algo visível os navegadores utilizam
motores de renderização. O primeiro passo efetuado por esses sistemas
é decodificar o documento HTML para sua representação em memória.
Este processo dá-se através da análise (\textit{parsing}) e posterior
tokenização, que é a separação do HTML em palavras chave que o
interpretador pode utilizar.

Diferentemente do XHTML, HTML não pode ser decodificado através de
tokenização tradicional. Deve-se ao HTML ser amigável ao programador,
aceitando erros de sintaxe, dependente de contexto, buscando entregar a
melhor aproximação possível. Esta característica deu origem a uma
especificação para renderizar HTML (\textit{HTML parser}).

Antes do HTML5 várias versões foram propostas, algumas radicais
em seus preceitos. O XHTML 2.0, por exemplo, quebrava com toda
a compatibilidade das versões anteriores e acabou por sendo descontinuado.
Outrossim, a maioria das versões HTML de grande sucesso foram versões de
retrospectiva (\textit{"retro-specs"}). Versões que não tentavam
idealizar a linguagem, buscando alinhar-se com os requerimentos do
mercado \autocite{diveIntohtml}. Não obstante, a ideia que a melhor forma
de ajustar o HTML é substituindo ele por outra coisa ainda aparece de tempos
em tempos \autocite{diveIntohtml}.

Uma página HTML consiste em elementos que podem ter seu comportamento
alterado através de atributos. Um elemento é o abrir fechar de
uma tag e todo o conteúdo que dentro dele reside \autocite[pp.
10--11]{htmlAndCssDucket}. Por exemplo, na figura \ref{fig:htmlSample} o elemento
meta (<meta>) tem um atributo \textit{charset}, que especifica o formato de 
codificação do documento.

Na sua versão inicial, o HTML contava com 18 elementos;
atualmente existem aproximadamente cem \autocite{diveIntohtml}.
Não obstante, foi no HTML5 que a maior parte dos elementos
que viabilizam a construção de jogos foram adicionados.

Uma das características do HTML que o torna tão popular
é seu interesse em manter manter a retrocompatibilidade.
Interpretadores HTML atingem isso ignorando os elementos que não
conhecem, tratando seu vocabulário exclusivamente. Esse mecanismo
permite que os desenvolvedores incluam marcação de reserva dentro
dos elementos que podem ser não suportados. O elemento \textit{span}
na figura \ref{fig:htmlSample} só aparecerá para o usuário caso seu
navegador não suporta a tag vídeo.

Além da convencional linguagem de marcação, HTML5 ou "HTML5 e amigos"
é muitas vezes interpretado como um conceito guarda chuva para designar
as tecnologias da web: HTML, CSS3 e JavaScript.

%}}}

\begin{figure}
\centering
\begin{verbatim}
<}!DOCTYPE HTML>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title></title>
</head>
<body>
    <video>
        <span>Seu navegador não suporta vídeo</span>
    </video>
</body>
</html>
\end{verbatim}
\caption{Exemplo de documento HTML}
\label{fig:htmlSample}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{html5.jpg}
    \caption{Suíte HTML}
\end{figure}
\subsection{DOM}
%{{{

O modelo de documento de objetos (\textit{Document Object Model}) é a representação
em memória de uma árvore de elementos HTML. Esta representação é definida por
um conjunto de padrões que torna interoperável a manipulação de elementos através de
JavaScript.

A primeira versão do DOM, DOM nível zero, foi parcialmente
especificada no HTML 4 e permitia manipulação parcial dos elementos.
Foi somente com a especificação do JavaScript em 1998 que o DOM nível 1 foi especificado,
permitindo a manipulação de qualquer elemento. DOM nível 2 e 3 seguiram com melhorias nas
consultas aos elementos e CSS.

A API de seletores do DOM permite alto nível de precisão e performance para buscar elementos.

\begin{figure}
\centering
\begin{verbatim}
    var elementos = document.querySelector( ".main, #sceen"  );
    var elementosB = document.querySelectorAll( "a.minhaClasse, p"  );
\end{verbatim}
\caption{Exemplo de utilização de seletores do DOM em JavaScript}
\label{fig:selectorsSample}
\end{figure}

A figura \ref{fig:selectorsSample} demonstra a utilização dos seletores do DOM em um documento
JavaScript. O método \textit{querySelector} seleciona o primeiro elemento em conformidade
com o padrão especificado. Já o método \textit{querySelectorAll} seleciona todos os elementos
que estão em acordo com o padrão especificado.

%}}}

\section{CSS}
%{{{

CSS (\textit{Cascading Style Sheets}) é uma linguagem de folhas de
estilo, criada por Håkon Wium Lie em 1994, com intuito de definir a
apresentação de páginas HTML. CSS juntamente com JavaScript e HTML
é peça central no desenvolvimento WEB tornando-se parte da OpenWeb,
sua especificação é atualmente mantida pela W3C.

O termo \textit{Cascading} refere-se ao fato de regras serem herdadas
pelos filhos de um elemento, eliminando grande parcela de duplicação.
Antes do CSS, a estilização das páginas era inclusa dentro do HTML.
Isso forçava que mudanças tivessem que ser replicadas em todas suas
ocorrências, e não permitia apresentações diferenciadas para
diferentes tipos de dispositivos.

A diferenciação entre apresentação e estrutura, sendo neste caso o
CSS responsável pela apresentação, é um dos pontos chave do SGML,
motivo que tornou a utilização do CSS tão difundida.

Com CSS também é possível que o usuário declare suas próprias
folhas de estilo, um recurso importante para acessibilidade.

Segundo \cite[pp. 23--24]{CascadingStyleSheets}:

\begin{quote}
CSS possibilita a ligação tardia (\textit{late biding}) com
páginas HTML. Essa característica é atrativa para os publicadores
por dois motivos. Primeiramente pois permite o mesmo estilo em várias
publicações, segundo pois os publicadores podem focar-se no conteúdo.
\end{quote}

CSS é formado por um conjunto de regras,
dentro de uma tag HTML denominada \textit{style}, que são agrupadas
por seletores em blocos de declaração. Os elementos selecionados são
denominados o assunto do seletor \autocite{cssSelectors}. Seletores tem
o intuito de definir quais partes do documento HTML serão afetadas por
determinado bloco de declaração.

A figura \ref{fig:CSSSample} exemplifica este processo. O seletor em
questão é o elemento p, simbolizando todos os parágrafos. O bloco de declaração
é o que está dentro das chaves, aplicando alinhamento e cores aos parágrafos.

\begin{figure}
\centering
\begin{verbatim}
<style>
p {
    text-align: center;
    color: red;
}
</style>
\end{verbatim}
\caption{Exemplo de Folha de Estilo}
\label{fig:CSSSample}
\end{figure}

O CSS é dividido em módulos, contendo aproximadamente 50 deles, cada
qual evoluindo separadamente. Além do módulos, CSS é organizado por perfis e níveis.
Os níveis inferiores representam as funcionalidades vitais do CSS, conforme os níveis
vão subindo utiliza-se os níveis predecessores para construir as funcionalidades.

A primeira especificação do CSS, CSS1 (ou nível 1) foi lançada em 1996. Em 1997 foi lançado o
 CSS2 com o intuito de ampliar a completude do CSS1. Em 1998 iniciou-se o desenvolvimento
 do CSS3 que ainda continua em 2015. Além do nível 3 existem módulos de nível 4 no CSS, apesar de a
versão do CSS não ter se alterado.

Os perfis do CSS dividem a especificação por dispositivo de utilização. Existem perfis
para dispositivos móveis, televisores, impressoras, etc.

Apesar da clara evolução das versões do CSS, esse processo nem sempre é linear.
Em 2005 o grupo de trabalho do CSS decidiu aumentar a restrição de suas especificações
rebaixando o CSS2.1, Seletores do CSS3 e Texto do CSS3 de recomendações para rascunhos.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{cssModules.png}
	\caption{The modules of CSS, 2014}
\end{figure}

O CSS3, introduziu várias funcionalidades relevantes para jogos, como
\textit{media-queries}: possibilitam regras para tamanhos de tela,
transformações 3D e animações.

\subsection{Media Queries}

Permitem aplicar regras de CSS específicas por tamanho de dispositivo e outras regras.
-falar de tamanhos absolutos vs relativos
sobre unidades em pixel, relativas e un.

Unidades vw e vh para tamanho do viewport

\subsection{Transições}

É uma forma de adicionar animações de mudança de estado, em uma
página web. Com o recurso de transições é possível controlar o
tempo da troca de estado de uma determinada propriedade em CSS para
outro valor.

Atualmente um conjunto finito de propriedades podem ser animados, e essas
lista tende a mudar com o tempo, cabe ao desenvolvedor assegurar-se que
determinada propriedade está disponível \autocite{mdnTransitions}.

Transições são interessantes em juntos, principalmente pois
muitos navegadores suportam aceleração de GPU (Unidade de
processamento gráfico) para elementos que tenham transformações 3D. Isso
garante grandes benefícios de performance sobre implementações diretamente
em JavaScript.

\begin{figure}
\centering
\begin{verbatim}
<style>
.test:hover
{
        -webkit-transform: scale(1.2);
        -ms-transform: scale(1.2);
        transform: scale(1.2);
}
</style>
\end{verbatim}
\caption{Exemplo de transição}
\label{fig:CSSTransition}
\end{figure}

A transição demonstrada na figura \ref{fig:CSSTransition} escala o
tamanho do elemento com a classe (\textit{test}) para vinte porcento a
mais do seu tamanho original. Perceba também os comandos repetidos com
o prefixo ms e webkit. Esse tipo de abordagem é comum para tecnologias
que não passam de rascunhos na especificação.

Navegadores por padrão tentam melhorar a experiência de navegação
de páginas de conteúdo HTML. Não obstante, jogos nem sempre
se beneficiam destes valores padrões, abaixo segue uma lista de
configurações interessantes para se fazer com CSS no contexto de
desenvolvimento de jogos.

\subsection{Otimizando o CSS para jogos}

Scroll é um recurso que a grande maioria das vezes não é útil em
jogos. Principalmente aqueles dependente de contato com a tela. Para
remover este comportamento deve-se utilizar o \textit{overflow:
hidden;} do seletor do corpo do documento (\textit{body}).

A barra de endereço é outro recurso de pouca utilidade no contexto de
jogos, e muitas vezes um empecilho para jogos em dispositivos móveis.

Para desabilitar a barra em dispositivos da Apple pode-se utilizar a
seguinte configuração:

\begin{verbatim}
<meta name="apple-mobile-web-app-capable" content="yes" />
\end{verbatim}


-touch-callout
-user select


O projeto cssnext http://cssnext.io/ é uma iniciativa para permitir a utilização
dos mais recentes recursos do CSS mesmo sem os recursos estarem implementados. 
O projeto funciona compilando o código nas últimas versões para as versões suportadas
pelos navegadores.

%}}}

Além da apresentação, recurso vital para jogos, e aplicativos web em geral, é a iteratividade. Com
as tecnologias da WEB esta iteratividade é atingida através do JavaScript.

\section{JAVASCRIPT}
%{{{

EMACScript, melhor conhecido como JavaScript, criada por Brendan Eich em
1992, é a linguagem de script da Web. Devido a tremenda popularidade
entre comunidade de desenvolvedores a linguagem foi abraçada pela W3C e
atualmente é um dos componentes da Open Web.

As definições da linguagem são descritas na especificação ECMA-262.
Esta possibilitou o desenvolvimento de outras implementações além da
original (SpiderMonkey) como o Rhino, V8 e TraceMonkey; bem como
outras linguagens similares como JScript da Microsoft e o ActionScript
da Adobe.

Segundo a \cite{ecmaSpecificaton}:
\begin{quote}
Uma linguagem de script é uma linguagem de programação que é
usada para manipular e automatizar os recursos presentes em um dado
sistema. Nesses sistemas funcionalidades já estão disponíveis
através de uma interface de usuário, uma linguagem de script é
um mecanismo para expor essas funcionalidades para um programa
protocolado.
\end{quote}

No caso de JavaScript na web, os recursos manipuláveis são o conteúdo
da página, elementos HTML, elementos de apresentação,
a própria janela do navegador e variados outros recursos que tem
suporte adicionado por novas especificações.

A intenção original era utilizar o JavaScript para dar suporte aos já
bem estabelecidos recursos do HTML, como para validação, alteração
de estado de elementos, etc. Em outras palavras, a utilização do
JavaScript era opcional e as páginas da web deveriam continuar
operantes sem a presença da linguagem.

Não obstante, mom a construção de projetos Web cada vez mais complexos, as
responsabilidades delegadas ao JavaScript aumentaram a ponto que a
grande maioria dos sistemas web não funcionarem sem ele.
JavaScript não evoluiu ao passo da demanda e muitas vezes carece de
definições expressivas, completude teórica, e outras características
de linguagens de programação mais bem estabelecidas, como o C++ ou
Java \autocite{crossPlatformMobileGame}.

A última do JavaScript, o JavaScript 6, é um esforço nessa direção.
JavaScript 6 ou EMACScript Harmonia, contempla vários conceitos de
orientação a objetos como classes, interfaces, herança, tipos, etc.
Não obstante o suporte ao JavaScript 6 é apenas parcial em todos
os navegadores. O site http://kangax.github.io/compat-table/es6/
apresenta um comparativo de suporte das funcionalidades do JavaScript.

Segundo \cite{ecmaSupport} o suporte no início de 2015 era o seguinte:

\begin{itemize}
    \item Chrome: 30%
    \item Firefox: 57%
    \item Internet Explorer : 15%
    \item Opera: 30%
    \item Safari: 19%
\end{itemize}

O projeto babel https://github.com/babel/babel é um compilador de JavaScript 6 para JavaScript 5. Permitindo que, mesmo sem suporte, os desenvolvedores possam usufruir dos benefícios da utilização do JavaScript 6 durante o tempo de desenvolvimento, gerando código em JavaScript 5 para rodar nos navegadores.

Estes esforços de padronização muitas vezes não são rápidos
o suficiente para produtores de software web, demora-se muito até
obter-se um consenso sobre quais as funcionalidades desejadas em
determinada versão e seus detalhes de implementação. Além da
espera por especificações, uma vez definidas, é necessário que os
distribuidores do JavaScript implementem o especificado.

Alternativamente, existe uma vasta gama de conversores de código -
(\textit{transpilers}) - para JavaScript; possibilitando programar
em linguagens formais e posteriormente gerar código JavaScript.
Entretanto, essa alternativa tem seus pontos fracos, necessita-se
de mais tempo de depuração, visto que o JavaScript gerado não é
conhecido pelo desenvolvedor, e provavelmente o código gerado não
será tão otimizado, nem utilizará os recursos mais recentes do
JavaScript.

Mesmo com suas fraquezas amplamente conhecidas, JavaScript está
presente em praticamente todo navegador atual. Sendo uma espécie de
denominador comum entre as plataformas. Essa onipresença torna-o
integrante vital no processo de desenvolvimento de jogos multiplataforma
em HTML5. Vários títulos renomeados já foram produzidos que fazem
extensivo uso de JavaScript, são exemplos: Candy Crush Saga, Angry
Birds, Dune II, etc.

Jogos Web são geralmente escritos na arquitetura cliente servidor,
JavaScript pode rodar em ambos estes contextos, para tanto, sua
especificação não define recursos de plataforma. Distribuidores do
JavaScript complementam a o JavaScript com recursos específicos para
suas plataformas alvo. Por exemplo, para servidores, define-se objetos como:
console, arquivos e dispositivos; no contexto de cliente,
são definidos objetos como: janelas, quadros, DOM, etc.

Para o navegador o código JavaScript geralmente é disposto no elemento
script dentro de arquivos HTML. Quando os navegadores encontram esse
elemento eles fazem a requisição para o servidor e injetam o código
retornado no documento, e a não ser que especificado de outra forma,
iniciam sua execução.

\subsection{JAVASCRIPT 7} 

Antes da finalização da especificação 6, algumas funcionalidades do 
JavaScript 7 já haviam sido propostas. Na página https://github.com/tc39/ecma262
pode-se conferir os itens propostos e seu estágio de evolução.

A figura \ref{fig:ecma7} é a tabela de funcionalidades sugeridas e seu estágio no caminho da especificação.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{ecma7.png}
	\caption{Propostas do ECMA 7}
	\source{https://github.com/tc39/ecma262}
    \label{fig:ecma7}
\end{figure}

\subsection{ASM.JS}
Asm.js é um subconjunto da sintaxe do JavaScript a qual permite grandes
aumentos de performance quando em comparação com JavaScript normal.
No contexto dos jogos performance é usualmente um recurso estimável,
asm.js consegue-o supra utilizando recursos que permitam otimizações
antes do tempo (\textit{ahead of time optimizations}). Entretanto, não é
trivial escrever código em asm.js e geralmente a geração de código
asm.js é feita através da conversão de outras linhagens como C.

Muita da performance adicional em relação ao JavaScript é devido
a consistência de tipo e a não existência de um coletor de lixo
(memória é gerenciada manualmente através de um grande vetor). Esse
modelo simples desprovido de comportamento dinâmico, sem alocação
e desalocação de memória, apenas um bem definido conjunto de
operações de inteiros e flutuantes possibilita grade performance e
abre espaço para otimizações.

%}}}
\section{DETECÇÃO DE RECURSOS}

Visto que nenhum navegador implementa a especificação completamente,
cabe ao desenvolvedor detectar os navegadores que não comportam as
necessidades tecnológicas dos aplicativos que cria. Ao deparar-se com uma funcionalidade
faltante o desenvolvedor tem duas possibilidades: notificar o usuário sobre o
problema ou utilizar polyfills.

Polyfills são recursos que simulam uma funcionalidade não disponível para
os navegadores que não suportam determinada especificação. A biblioteca
Gears é um exemplo. Esta serve para prover recursos de Geolocalização para
navegadores que não implementam a especificação do HTML5.

Algumas funcionalidades do HTML, como geolocalização e vídeo foram
primeiramente disponibilizadas através de plugins como o Gears ou
Flash. Outras funcionalidades, como o Canvas, podem ser totalmente
emuladas via JavaScript \autocite{diveIntohtml}.

Detectar suporte aos mais variados recursos do HTML5 no navegador
é uma tarefa entediante. Pode-se implementar testes para
cada funcionalidade utilizada abordando os detalhes de implementação
de cada uma ou então fazer uso de alguma biblioteca especializada
neste processo. O Modernizr é uma opção open-source deste tipo de
biblioteca, este gera uma lista de booleanos sobre grande variedade dos
recursos HTML5, dentre estes, geolocalização, canvas, áudio, vídeo e
armazenamento local.

Uma boa referência de recursos suportados pelos navegadores é o site
http://caniuse.com/.

\section{NAVEGADORES}
%{{{
Aplicações do lado do cliente geralmente se comunicam com um
servidor através de documentos em HTTP. Quado o navegador recebe um
destes pacotes em HTML ele começa o processo de renderização. A
renderização pode requisitar outros arquivos a fim de completar a
experiência desenvolvida para o endereço em questão.

Nos navegadores os usuários necessitam localizar a página que desejam,
sabendo o endereço, ou pesquisando em buscadores. Isso é um processo
árduo para a plataformas móveis pois necessitam maior interação
do usuários e não são “naturais” se comparado ao modo normal
de consumir aplicativos nestas mesmas plataformas – simplesmente
adquirindo o aplicativo na loja e abrindo-o no sistema operacional.
Alguns contornos para este problema serão descritos nas tecnologias
offline.

Para transformar as instruções retornadas pelo servidor em algo útil
para o usuário final os navegadores geralmente fazem uso de bibliotecas
externas capazes de interpretar HTML5 e gerar o conteúdo iterativo.

Os navegadores são geralmente compostos por um motor de renderização (engine)
e por um motor de JavaScript.

Alguns motores de renderização incluem:

\begin{itemize}
    \item Blink: Utilizada no Chromium e projetos relacionados, Opera
    \item Gecko: Utilizada nos produtos da Mozilla
    \item KHTML: Utilizada no navegador Konkeror, esta serviu de base para o Blink
    \item WebKit: Utilizada no Safari e versões antigas do Google Chrome.
\end{itemize}

Alguns motores de JavaScript incluem:

\begin{itemize}
    \item SpiderMonkey: Primeiro motor, desenvolvido por Brendan Eich, escrito em C++
    \item Rhino: Criada pela Netscape, escrito em Java
    \item Nitro: Criada pela Apple
    \item V8: Criada pelo Google
    \item TraceMonkey: Criada pela Mozilla
\end{itemize}

O suporte à HTML vem crescendo com o tempo, o site HTML5Test http://html5test.com/about.html, oferece um placar atualizado dinamicamente, conforme utilização dos navegaores, sobre os recursos do HTML.

A figura \ref{fig:audioCodecs} apresenta o gráfico de suporte por versões de navegadores em dezembro de 2015.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{htmlSupport.png}
	\caption{Suporte das especificações do HTML nos navegadores}
    \label{fig:htmlSupport}
\end{figure}

\section{ANDROID}
%{{{

É um sistema operacional *open-source* desenvolvido pela Google.
Utiliza o kernel Linux .
Softwares para Android são geralmente escritos em Java e executados
através da máquina virtual Dalvik.

É similar a máquina virtual Java, mas roda um
formato de arquivos diferenciado (dex), otimizados para consumir pouca
memória, que são agrupados em um único Android Package (apk) Android
permite a renderização de documentos HTML através de sua própria
API WEBVIEW. Ou através do navegador disponibilizado por padrão, ou
outros de terceiros como o Google Chrome, Firefox, Opera, etc.

No quesito jogos para dispositivos móveis é preferível disponibilizar
os jogos através da interface nativa pois dá a sensação de
continuidade para com os demais aplicativos instalados no dispositivo.

%}}}

\section{RENDERIZAÇÃO}
%{{

Renderização é parte fundamental de muitos jogos. As tecnologias atualmente existes são o SVG e Canvas.

\subsection{SVG}
%{{{
SVG (\textit{Gráficos de vetores escaláveis}), é uma linguagem baseada em XML especializada na criação de vetores bidimensionais \autocite{html5mostwanted}. Por usar XML SVG permite a utilização da API do DOM para manipular os elementos.

Entre os benefícios do SVG encontram-se:

\begin{itemize}
\item Não há diferença de qualidade em resoluções pois os vetores são escaláveis;
\item Suporta animações nativamente;
\item Conta com integração através da api do DOM. Tornando simples a integração com as outras tecnologias da web.
\end{itemize}

Um aspecto negativo do SVG é que é muito difícil atingir a perfeição na posição dos pixels, por ser uma linguagem vetorizada \autocite{html5mostwanted}.

\begin{figure}
\centering
\begin{verbatim}

<svg height="100" width="100">
  <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3"/>
  Sorry, your browser does not support inline SVG.
</svg>

\end{verbatim}
\caption{Círculo em SVG.}
\end{figure}
%}}}
\subsection{CANVAS}
%%{{{

A tag \textit{canvas} define uma camada de mapa de bits em documentos
HTML que pode ser usada para criar diagramas, gráficos e animações
2D. Foi criada pela Apple em 2004 para renderizar elementos de interface
no Webkit, logo foi adotado por outros navegadores e se tornou um
padrão.

A API canvas cresceu com o tempo, e algumas funcionalidades - como
suporte a texto, foram adicionadas tardiamente. E alguns navegadores
lançaram antes da especificação estar completa e hoje tem problema
de suporte para essas áreas \autocite{diveIntohtml}. Apesar de muitas
vezes incompleto, o canvas é suportado em todos os maiores navegadores
à partir do Internet Explorer 9.

Apesar de ser largamente suportado nos navegadores atuais, canvas ainda
sofre de problemas de performance. Para navegadores antigos - abaixo do
Internet Explorer 9 - existe o polyfill Explorer Canvas do Google, que
emula em JavaScript as funcionalidades do canvas. O FastCanvas é uma
iniciativa híbrida para Android que busca mitigar os problemas de
performance do Canvas com uma API nativa. Não obstante, o FastCanvas
não suporta a especificação do canvas completamente, não permite ser
integrado com outros elementos do DOM.

Em um documento HTML, Canvas é um retângulo onde pode-se usar
JavaScript para desenhar \autocite[pp. 113]{diveIntohtml}.

Canvas tem uma característica peculiar quanto ao seu tamanho.
Em suma existem dois tamanhos, o tamanho do elemento e da superfície de
desenho. Quando o tamanho do elemento é maior do que o da superfície
de desenho do documento escala a superfície de desenho para preencher o
elemento, o que pode gerar resultados inesperados.

Algumas outras fraquezas do canvas são:
\begin{itemize}
\item{Não há suporte a animações}
\item{Não é possível alterar uma parte já desenhada a não ser sobrescrevendo ou pintando o canvas novamente}
\item{Por ser um vetor de pixeis não existe possibilidade de utilização do DOM nem seus eventos, limitado muito a iteratividade}
\end{itemize}

O canvas até aqui descrito trata-se de sua forma, ou contexto 2D. A
especificação 3D do canvas é o WebGl.

https://github.com/google/canvas-5-polyfill Esta serve para
suprir aos navegadores que ainda não implementaram, os últimos recursos
da especificação CANVAS, como o recurso de desenhar elipses e o caminho 2D.
%}}}
\section{WEBGL}
%{{{
É Baseado em OpenGL, o órgão que especifica o WEGGL é o mesmoq que especifica o OpenGL: Kronos.

WebGL não foi utilizada no trabalho apesar de ser de grande
relevância no processo de jogos pois ainda não está completamente
especificada e a dificuldade e escopo do projeto aumentariam muito se
tivessem de incluir um jogos 3D. Versão da especificação atual?

CocoonJS é uma aplicativo híbrido que preenche a fraca implementação
de OPENGL nos dispositivos móveis possibilitando se desenvolver em
WEBGL.

%}}}
%}}}
\section{Codecs}
%{{{
Para falar sobre audio e vídeo precisamos primeiramente introduzir o conceito de codecs. Codec - é o algorítmo usado para encodificar o video em um conjunto de bits \cite{diveIntohtml}.

Codecs é uma área problemática do HTML5. Segundo \cite{diveIntohtml} não existe uma única combinação de containers e codecs que funcionem em todos os navegadores.


\section{AUDIO}
%{{{
Áudio é um componente vital para oferecer imersão e feddback aos
usuários de jogos. Efeitos de som e música podem servir como mecanismo. 
Por outro lado, jogadores tem baixa tolerância a volume, deve ser utilizado com cautela.

Segundo \cite{browserGamesTechnologyAndFuture} em sido difícil construir aplicações sofisticadas e interativas sem a utilização de plugins para áudio.

O componente de áudio é especialmente útil para jogos de ação \autocite{browserGamesTechnologyAndFuture}.

\subsection{TAG AUDIO}

A tag <audio> define um som dentro de um documento HTML. Quando o
elemento é renderizado pelos navegadores, ele carrega o conteúdo
que pode ser reproduzido pelo player de audio do navegador. Existem
muitas discrepâncias entre os formados aceitáveis pelos navegadores.
É um tanto limitada quanto comparada ao áudio de múltiplos canais
disponibilizados por SDKs nativas.

\subsection{API DE AUDIO}

É uma interface de audio experimental para JavaScript. Provê maior
flexibilidade na manipulação de audio. Essa tecnologia é muito mais
nova do que a tag áudio.


Abaixo segue alguns dos codecs de audio tradicionais:
\begin{itemize}
    \item{MP3: comum, mas não é livre de patentes}
    \item{ACC: advanced audio coding, is patent encumbered} \item{Vorbis - patent free}
\end{itemize}

A figura \ref{fig:audioCodecs} é um comparativo interessante sobre os formatos existentes, considerando o fator taxa de bits versus qualidade.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{codec.png}
	\caption{Comparação de codecs de áudio}
    \label{fig:audioCodecs}
\end{figure}


%}}}

\section{VIDEO}
%{{{
Antes do HTML5 era impossível adicionar vídeos nas páginas sem a utilização de algum plugin.

A especificação define uma tag \textit{video} que pode ser embida em uma página HTML. Segundo \cite{diveIntohtml} não existem restrições quando ao codec de vídeo ou áudio, um elemento vídeo pode fazer referência a múltiplos arquivos de vídeos, cabe ao navegador decidir qual arquivo de fato será executado.

Os navegadores não concordam em qual formato de vídeo suportar.
Uma tag vídeo pode apontar para vários arquivos em diversos formatos, e os navegadores que suportarem determinado irão escolhê-lo.

Um formato de vídeo é a combinação de várias tecnologias.

AVI e MP4 são apenas containers de formatos. Como um arquivo zip, podendo conter qualquer coisa dentro de si \autocite{diveIntohtml}.

Existem formatos desenvolvidos especificamente para a Web. Buscam uma razão de tamanho e qualidade aceitável, mas prezando por tamanho. A maioria dos codecs de vídeo não mudam todo o conteúdo de um quadro para o próximo, possibilitando maiores taxas de compressão, que resulta em arquivos menores \autocite{diveIntohtml}.

O projeto \textit{Vídeo for Everybody} \begin{verbatim} http://camendesign.com/code/video_for_everybody \end{verbatim} é um polyfill que recorre à flash quando o vídeo não é suportado pelo navegador.


Segue uma lista de alguns dos containers de video:
\begin{itemize}
    \item{MPEG4}
    \item{Flash Video}
    \item{Ogg} (for video Theora), (audio Vorbis)
    \item{WebM}
    \item{Matroska}
    \item{Audio Video Interleave}
\end{itemize}

Alguns codecs de vídeo
\begin{itemize}
    \item{H.264, is one of the video codecs mandated by the Blue-Ray specification}
    \item{Theora, native in Linux}
    \item{VP8 royality free from Google}
\end{itemize}

%}}}
%}}}
\section{OFFLINE E ARMAZENAMENTO}
Não é extraordinário que um jogo tenha que ser reverso para um estado
válido anterior por motivo de um erro na base de dados \autocite[pp. 5]{browserGamesTechnologyAndFuture}.

Uma das grades limitações do HTML era a ausência de capacidade
de armazenamento de dados. Armazenamento no lado do cliente é um
requerimento básico para qualquer aplicação moderna. Essa área
era ode as aplicações nativas detinham grande vantagem sobre as
aplicações web. O HTML5 solucionou este problema introduzindo várias
formas de armazenamento de dados \autocite{html5Tradeoffs}.

\subsection{Aplicações offline}
Na sua versão mais simples, um aplicativo offline é um conjunto de
URLs para arquivos HTML, CSS, JavaScript, imagens ou qualquer outro tipo
de recurso \autocite{diveIntohtml}.

\subsection{LOCAL STORAGE}
Também conhecido como Web Storage na especificação do HTML5. Provê
uma forma de armazenar os dados como chave valor dentro do navegador. Os
dados são persistido mesmo que o navegador seja fechado.

\subsection{WEB SQL}
Um banco de dados SQLite embebido no navegador. Permite
tabelas relacionais. O tamanho padrão do banco de dados é 5 megabytes
e pode ser estendido pelo usuário.

Segundo \cite{diveIntohtml}
\begin{quote}
Todos os implementadores interessados utilizaram a mesma tecnologia (Sqlite), mas
para a padronização ficar completa é necessário múltiplas implementações. Até outro implementador se interessar em desenvolver a especificação a descriação do dialeto SQL apenas referencia o SQLITE, o que não é aceitável para um padrão.
\end{quote}

Web Sql foi depreciado em favor da especificação do IndexedDb.
Não obstante, IndexedDb ainda é comummente utilizado em sistemas móveis \autocite{html5Test}.

\subsection{IndexedDb}
\section{ENTRADA DE COMANDOS}

Na construção da grande maioria dos jogos é muitas vezes
imprescindível alta flexibilidade na gestão de entrada de dados.
Este fator muito se amplia na criação de jogos multiplataforma,
seja através de teclado, tela sensível ou sensor de movimentos, o
importante é oferecer a melhor experiência possível por plataforma.
O HTML5 trata todos estes casos abstratamente na forma de eventos, os
quais podem ser escutados através de \textit{listeners}. Os eventos básicos
são: keydown (tecla baixa), keyup (tecla solta) e keypress (tecla
pressionada).

\subsection{DISPONIBILIZAÇÃO DA APLICAÇÃO}

Links com manifestos

Aplicativos baseados na web não requerem instalação ou atualizações manuais e sua distribuição é superior ao estilo convencional de aplicações desktop \autocite{browserGamesTechnologyAndFuture}.

\section{INSTALAÇÃO}
%{{{
Este método é benéfico pois possibilita ao usuário a mesma
experiência ao adquirir uma aplicação normal. Este tipo de
aplicação é comummente referido como "híbrido".
%}}}

\section{TRABALHOS SIMILARES}

\cite{crossPlatformMobileGame} elaborou uma revisão de aspectos do
HTML5 através da construção de um jogo. O autor foca muito nos
aspectos de criação de jogos e feedback do desenvolvimento. Troca
de tecnologias e não especificamente nas limitações conforme o meu
trabalho. Em outras palavras seu escopo é mais genérico e não tão
preciso quanto este

%}}}
