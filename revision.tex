\section{JOGOS}
%{{{

Segundo \citet{indieGamesLemes}, jogo digital constitui-se em uma
atividade lúdica composta por uma série de ações e decisões,
limitadas por regras e pelo universo do game, que resultam em uma
condição final.

Apesar da definição clara, uma taxonomia dos jogos não é tarefa
trivial. Pela diversidade em itens e gêneros e a vasta quantidade de
dimensões que os vídeos games se encontram, uma categorização dos
jogos contemporâneos é extremamente difícil de desenvolver (muitos
já tentaram) \autocite[p. 60]{gamebenefits}.

Para corroborar com essa complexidade, \citet{gamebenefits} afirmam que
a natureza dos jogos tem mudado drasticamente na última década, se
tornando cada vez mais complexos, diversos, realísticos e sociais em
sua natureza.

Com as inovações nas tecnologias relacionadas ao HTML, novas
mecânicas e gêneros de jogos podem ser explorados na WEB. Sendo
que cada gênero acompanha um conjunto de desafios específicos.
Jogos de FPS (tiro em primeira pessoa) requerem menor latência de
rede, já jogos de RPG podem requerer vastas quantidades de cache
\autocite{html5mostwanted}.

\subsection{Benefícios}

Assim como as tecnologias, um grupo emergente de pesquisas sobre os
benefícios do jogos vem se desenvolvendo \citet{gamebenefits}. Apesar
de a quantidade de estudos sobre os males dos jogos ser muito maior do
que os estudos sobre seus benefícios, a quantidade de benefícios já
correlacionados aos jogos é substancial.

\citet{gamebenefits} demostram que vídeo games melhoram as funções
cognitivas, as capacidades criativas, e motivam uma visão positiva
diante a falha. Também segundo \citet{gamebenefits}, postura positiva
em relação a falha correlaciona-se com melhor performance acadêmica.

Benefícios em habilidades práticas também são observados em
usuários de jogos. Jogadores de jogos de tiro demonstram maior
alocação de atenção, maior resolução espacial no processamento
visual e melhor habilidades de rotação \autocite{gamebenefits}.

Estes aspectos positivos muitas vezes não recebem a atenção devida.
Habilidades espaciais derivadas de jogar jogos de tiro comercialmente
disponíveis são comparáveis aos efeitos de um curso universitário
que busca melhorar as mesmas habilidades \autocite{gamebenefits}. Estas
habilidades derivadas dos jogos são centrais para muitas áreas de
interesse humano. \citet{gamebenefits} afirmam que habilidades espaciais
estão diretamente relacionadas com o sucesso em ciência, tecnologia,
engenharia e matemática.

Outra outro ponto importante dos jogos é seu aspecto social. Apesar de a
mídia ter criado uma perspectiva negativa sobre jogos, especialmente
os violentos, a realidade é mais complexa do que se pensa. Jogadores
de jogos violentos, cuja jogabilidade encoraje a cooperatividade, são
mais prováveis de exibir comportamento altruísta fora do contexto dos
jogos, do que jogadores de jogos não violentos \autocite{gamebenefits}.

Além dos aspectos benéficos, adiante serão abordados alguns aspectos
técnicos e gerenciais dos jogos.

\subsection{MECÂNICA}

\citet{html5mostwanted} ressalta a importância do planejamento antes do
desenvolvimento de jogos. Ao criar jogos deve-se planejar o que se
pretende atingir e como chegar lá antes de se escrever qualquer
código, definições quanto a mecânica é um passo vital neste planejamento.

A mecânica é composta pelas regras do jogo. Quais as ações
disponíveis aos usuários, e seu funcionamento, é fortemente
influenciada pela categoria do jogo em questão. Dedicar-se na
elaboração de uma mecânica é tarefa quintessencial para a
construção de um jogo de sucesso.

A mecânica não pode ser simplesmente boa, nos melhores jogos ela é
intuitiva. O processo de o jogador entender por si a mecânica do jogo
é um componente vital para a sua satisfação. Se ele não entender as
regras do jogo quase que instantaneamente muitas pessoas vão perder o
interesse e desistir rapidamente \autocite{crossPlatformMobileGame}.

Ainda sobre a importância da mecânica \citet{html5mostwanted}, afirma
que se os gráficos e áudio são espetaculares mas a jogabilidade
é chata o jogador vai parar de jogar. A substância do jogo é sua
mecânica, então não invista muito em visual ao menos que isso
desempenhe um papel essencial no jogo.

Os desenvolvedores tem que evitar fazer o jogo para eles mesmos.
Falta de crítica antes do desenvolvimento também tende a gerar jogos ruins.
Bons jogos são aqueles que ao menos suprem as expectativas dos usuário.
\citet{indieGamesLemes} aponta alguns fatores procurados pelos usuários
de jogos: desafio, socializar, experiência solitária, respeito e
fantasia. Jogos que conseguem integrar o maior número destes aspectos 
em sua mecânica serão os mais apreciados.

A elaboração da mecânica em jogos desenvolvidos profissionalmente
pode ser integrada dentro de um processo de engenharia de software
O sumário também conta com um resumo sobre metodologias de
desenvolvimento de software contextualizada para a criação jogos.

Depois dos preparativos efetuados, pode-se começar a construção
do jogo. 

\subsection{Laço}

Jogos digitais geralmente operam através um laço que executa uma série
de tarefas a cada frame, construindo a ilusão de um mundo animado
\autocite[p. 31]{gwt}. Da perspectiva da programação, a parte
principal de um jogo é o laço onde o jogo é executado \autocite[p.
17]{crossPlatformMobileGameDevelopment}. A cada iteração do 
laço o processamento de entrada de dados do usuário e
alterações da cena tem de ser computados, tornando a otimização deste processo
importantíssima para que o jogo não se torne lento.

Na seção Otimizações para jogos em JavaScript será abordada as
opções da WEB na hora de construir um laço de jogo.

Outra decisão técnica importante na hora de desenvolver jogos é a 
seleção das plataformas alvo mais adequadas. Neste trabalho o foco será 
em  HTML5 para desktops e dispositivos móveis inteligentes. Não obstante,
na sessão a seguir serão descritas, genericamente, as plataformas que os
desenvolvedores podem selecionar ao desenvolver jogos, juntamente com 
seus benefícios e fraquezas.

\section{JOGOS MULTIPLATAFORMA}

Jogos multiplataforma são jogos que rodam em mais de uma plataforma.
Cada plataforma contém sua própria API (\textit{Application
Programming Interface}), sendo que se um aplicativo foi criado para
uma plataforma ele não vai poder ser utilizado em outra pois as
APIs são diferentes \autocite{crossPlatformMobileGameDevelopment}.
Além da API, dispositivos de múltiplas plataformas variam em seus
recursos, capacidades e qualidade. Devido a essas características,
desenvolvedores de jogos que almejem múltiplas plataformas, deparam-se
com uma nova gama de oportunidades e desafios.

Um destes desafios é fornecer \textit{feedback} suficiente para o
jogador pois muitas vezes o dispositivo é limitado em proporções,
som, tela. Devido a estes requerimentos, tendências como WEB design
responsivo (RWD) emergiram. Requerendo que os desenvolvedores busquem
criar interfaces cada vez mais fluídas e intuitivas o possível. As
tecnologias da Web também tiveram que acompanhar a mudança. CSS3 media
queries, tamanhos relativos, são exemplos de tecnologias desenvolvidas
com o foco em multiplataforma.

Outro desafio multiplataforma é suportar os vários ecossistemas
de software com tecnologias diferenciadas e versões de
software divergentes. Para que um jogo multiplataforma tenha
sucesso é necessário definir com cautela suas tecnologias.
\citet{html5mostwanted} afirma que: o estágio mais complicado e crucial
do desenvolvimento de jogo é a escolha das tecnologias utilizadas.

Designers de jogos tem as seguintes possibilidades quando em face
de desenvolver um jogo multiplataforma: criar um jogo web, um jogo
híbrido, ou nativo. As opções serão descritas a seguir.

\subsection{JOGOS WEB}

Um jogo web é um jogo que utiliza o HTML e ferramentas correlacionadas
para sua construção e disponibilização. Não obstante, o objetivo
primário da WEB nunca foi o desenvolvimento de jogos. Por muito
tempo os títulos famosos de jogos da web residiam em jogos como
\textit{Traviam}, desprovidos de animações, compostos basicamente por
formulários, imagens e textos. Durante esse período o interesse em
jogos WEB residia principalmente nas de casualidade, flexibilidade, e o
fator social dos jogos.

Mais recentemente é que a WEB começou a ser vista como de fato um
ambiente com interatividade para criação de jogos dos mais variados
gêneros. Publicar jogos baseados em texto é uma atividade cada vez
mais rara, podendo-se concluir que interface gráfica se tornou uma
funcionalidade mandatória \autocite{browserGamesTechnologyAndFuture}.
Jogos como BrowserQuest, Angry Birds, entre outros títulos expandiram
os conceitos do que é possível se fazer utilizando as ferramentas
da WEB. Segundo \cite[p. 28]{gwt} um bom exemplo que tem alcançado
bastante sucesso entre o público são os jogos adicionados no logotipo
do Google, chamados doodles.

Quando comparados a outras abordagens de criar jogos, jogos da WEB
contém vários aspectos positivos. Talvez o mais reconhecível
é o fato de com uma única base de código poder suprir uma gama
praticamente inesgotável de dispositivos. 

Comparável a base de clientes está a quantidade de desenvolvedores
WEB, os quais podem reaproveitar grande parcela do conhecimento
adquirido através do desenvolvimento de páginas WEB na criação de
jogos.

Sua distribuição também é superior ao estilo convencional de
aplicações desktop \autocite{browserGamesTechnologyAndFuture}. 
Por serem criados à partir das tecnologias da WEB, jogos na WEB, se
beneficiam de uma arquitetura construída para um ambiente social, sendo
relativamente mais fácil criar experiências sociais.

A performance é um ponto negativo da WEB, é difícil chegar a
performance comparável a abordagem nativa. Não obstante, esse
problema é cada vez menor o hardware dos dispositivos são cada vez
melhores e as tecnologias tecnologias de software também avançam
substancialmente.

Existem inconsistências nas implementações das especificações
WEB o que leva a comportamento inesperados em alguns caos, sendo
necessário desenvolver regras específicas para dispositivos e versões
de navegadores.

Outro aspecto negativo da WEB é que nem todas as funcionalidades dos
dispositivos estão especificados com as tecnologias da WEB e muitas
vezes os recursos do dispositivo ficam sub utilizados.

Além dos jogos web, há a possibilidade de criar jogos nativos e híbridos.

\subsection{DESENVOLVIMENTO DE JOGOS NATIVOS}

Uma aplicação nativa é uma aplicação que foi desenvolvida para ser
utilizada em uma plataforma ou dispositivo específico \autocite[p.
7]{aSeriousContender}. Aplicativos nativos tendem a oferecer uma
experiência mais próxima com a do resto do sistema operacional o qual
está rodando. Potencialmente softwares nativos são mais rápidos
que suas alternativas da WEB, visto que interagem com o dispositivo
através do sistema operacional. Diferentemente dos jogos WEB, que
necessitam que o navegador interaja com o sistema operacional, para
por sua ver interagir com o dispositivo. Por terem acesso total ao
dispositivo, aplicativos nativos podem aproveitar o hardware da melhor
forma possível e oferecer ao usuário a melhor experiência possível
\autocite[p. 7]{aSeriousContender}.

Desenvolver jogos nativos tende a ser mais caro que a alternativa da WEB,
visto que é necessário duplicar funcionalidades em sistemas distintos
e manter um profissional por ambiente suportado. As versões nativas
são totalmente incompatíveis entre si, impossibilitando reúso em múltiplas plataformas.

A alternativa hibrida fica em meios ao desenvolvimento nativo e WEB e
será descrita abaixo.

\subsection{JOGOS HÍBRIDOS}

A alternativa híbrida é uma tentativa de beneficiar-se das melhores
características da abordagem nativa e o melhor do desenvolvimento
WEB. Muitas vezes desenvolve-se aplicações híbridas utilizando as
tecnologias da WEB só que ao invés de disponibilizar a aplicação
através de um navegador a aplicação WEB é instalada como um
aplicativo normal. A aplicação roda em uma WebWiew que é um
componente do sistema operacional capaz de rodar as tecnologias da
WEB. Desta forma o aplicativo WEB conversa diretamente com o sistema
operacional, não necessitando da intervenção de um software terceiro
para mediar a interação.

Outra possibilidade híbrida é escrever o software em uma linguagem
e gerar binários para as plataformas alvo. Utilizando o Xamarin é
possível desenvolver em C\# e compilar para diversas plataformas
nativamente. Através dessa abordagem é possível beneficiar-se de um
aplicativo nativo e eliminar grande parte da duplicação geralmente
imposta \footnote{Os frameworks multiplataforma dos apêndices contém
tecnologias similares ao Xamarin como o Titanium}.

Visto que a estratégia híbrida geralmente tem acesso ao sistema
operacional é possível criar APIs para acessar recursos não sempre
disponíveis para a plataforma WEB. Soluções como o PhoneGap
adotam essa estratégia para possibilitar granular controle sobre os
dispositivos através de APIs JavaScript implementadas nativamente.

Outro benefício da estratégia híbrida em relação a WEB é que
ela permite empacotar as aplicações com um experiência exata a dos
softwares nativos. Sendo imperceptível para o usuário final a
diferença ente um aplicativo híbrido e um nativo.

Não obstante, segundo \cite[p. 8]{aSeriousContender} a diferença
entre o que é possível com a estratégia híbrida e a WEB está
diminuindo devido ao grande esforço da comunidade WEB para prover
novas especificações.

%}}}
\section{WEB}
%{{{

\subsection{OPEN WEB}

A OWP (\textit{Open Web Platform}) é uma coleção de tecnologias
livres, amplamente utilizadas e padronizadas. Quando uma tecnologia
se torna amplamente popular, através da adoção de grandes empresas
e desenvolvedores, ela se torna candidata a adoção pela OWP. Os
benefícios de utilizar tecnologias da OWP são vários. \cite[p.
3]{svgTime} cita que o tecnologias padronizadas tem um maior ciclo de
vida e são mais fáceis de mudar. Da mesma maneira, as tecnologias
da WEB são benéficas devido sua grande adoção, permitindo que
aplicações baseadas nelas tenham impacto na maior quantidade de
clientes possível.

Não obstante, mais do que tecnologias a OWP é um conjunto de
filosofias as quais a WEB se fundamenta \autocite{openWebDefinition}. Entre outras, a Open Web
busca transparência, imparcialidade nos processos de criação
e padronização de novas tecnologias. Retro compatibilidade com
as especificações anteriores. Consenso entre o mercado e o meio
acadêmico, nunca um distanciando-se muito do outro \footnote{Mais
informações sobre a Open WEB podem ser encontradas no seguinte
endereço http://tantek.com/2010/281/b1/what-is-the-open-web}.

Várias pessoas, empresas e comunidades estão interessadas neste
processo, cada qual com seus próprios conjunto de ideias sobre como
a WEB deveria funcionar. Mas para que a crescente quantidade de
dispositivos possa acessar a riqueza que o HTML5 permite, padrões
precisam ser definidos \autocite[p. 5]{aSeriousContender}.

A W3C é uma comunidade responsável por boa parte das
especificações da web como: HTML (em conjunto com a WHATWG), CSS,
entre outras\footnote{Uma lista completa das especificações mantidas pela
W3C pode ser encontrada em: http://www.w3.org/TR/}. Outros grupos
detém responsabilidade por outras tecnologias da OWP, como a ECMA,
responsável pelo JavaScript; ou Kronos, responsável pelo WebGL.

Na W3C o processo de desenvolvimento de especificações consiste
na elaboração de rascunhos (\textit{working drafts}), criados por grupos
de trabalhos (\textit{workin groups}) de especialistas no
assunto, que passam por vários passos de revisão até se tornarem
recomendações. As recomendações podem ser implementadas com
segurança de que a especiação não mudará substancialmente.

Apesar do processo da W3C ser rigoroso, está longe de perfeito. A
especificação final do HTML4 contava com quatro erros publicados
via errata \autocite{HTML5}. Não obstante, o cenário é animador
\citet{html5mostwanted} cita que as tecnologias da Open WEB tem
evoluído desde os princípios da internet e já provaram sua robusteza
e estabilidade enquanto outras tecnologias crescem e morrem ao redor
dela.

A tecnologia chave que inaugurou e alavancou este processo é o HTML.
%}}}
\section{HTML}
%{{{

HTML (\textit{Hyper Text Markup Language}) é uma linguagem de
marcação que define a estrutura semântica do conteúdo das páginas
da web. Criada por Tim Berners Lee em 1989 no CERN. HTML é a tecnologia
base para a criação de páginas web e aplicativos online. A parte
denominada: "\textit{Hyper Text}", refere-se a links que conectam
páginas HTML umas as outras, fazendo a Web como conhecemos hoje
\autocite{mdn2015}.

A última versão do HTML é o HTML5, iniciado pela WHATWG e
posteriormente desenvolvido em conjunto com a W3C. Seu rascunho foi
proposto em 2008 e ratificado em 2014. Após 2011, a última chamada
de revisão do HTML5, a WHATWG decidiu renomear o HTML5 para HTML
\autocite{htmlIsTheNewHtml5}. Não obstante, o termo HTML5 permanece em
utilização pela W3C.

Além da nomenclatura, exitem pequenas diferenças nas especificações
da W3C e WHATWG. A W3C vê a especificação do HTML5 como algo fechado,
inclusive já iniciou o desenvolvimento do HTML 5.1. Já a WHATWG vê o
HTML5 como uma especificação viva. A postura da W3C tende a criar uma
especificação estável, já a da W3C reflete mais a realidade dos
navegadores, que nunca implementam uma versão completamente. A Mozilla
utiliza a especificação da WHATWG no desenvolvimento do Firefox e
recomenda a da W3C para sistemas que requeiram maior estabilidade. Neste
trabalho optamos pela nomenclatura da WHATWG, utilizamos o termo HTML em
detrimento a HTML5, sempre que semanticamente viável.

HTML foi especificado baseando-se no padrão SGML (\textit{Standard Generalized
Markup Language}).

Alguns benefícios do SGML são:
\begin{itemize}
    \item Documentos declaram estrutura, diferentemente de aparência
, possibilitando otimizações nos ambientes de uso (tamanho de tela,
etc);
    \item São portáveis devido a definição de tipo de documento
(\textit{document type declaration}).
\end{itemize}

Apesar de o SGML especificar a não definição de aparência, os criadores de
navegadores constantemente introduziam elementos de apresentação como o
piscar, itálico, e negrito, que eventualmente acabavam por serem inclusos
na especificação. Foi somente nas últimas versões que elementos de
apresentação voltaram a ser proibidos reforçando as propostas chave
do HTML como uma linguagem de conteúdo semântico, incentivando a
utilização de outras tecnologias como o CSS para responder as demandas de
apresentação.

Além do HTML, existe o XHTML, que é uma iniciativa de utilização de
XML nas páginas da web. O XML é um padrão mais rigoroso que SGML e
resulta em páginas sem problemas de sintaxe e tipografia. 
Alguns estimam que 99\% das paginas HTML de hoje
contenham ao menos um erro de estrutura \autocite{diveIntohtml}.
Uma das maiores vantagem do XML é que sistemas sem erros de sintaxe
que podem ser facilmente interpretadas por outras tecnologias como
sistemas de indexação, buscadores, etc.

Para transformar o HTML em algo visível os navegadores utilizam motores
de renderização. O primeiro passo efetuado por esses sistemas é
decodificar o documento HTML para sua representação em memória. Este
processo dá-se através da análise (\textit{parsing}) e posterior
tokenização, que é a separação do HTML em palavras chave que o
interpretador pode utilizar. Diferentemente do XHTML, HTML não pode
ser decodificado através de tokenização tradicional. Deve-se ao HTML
ser amigável ao programador, aceitando erros de sintaxe, dependente
de contexto, buscando entregar a melhor aproximação possível. 
Segundo \citet{howBrowsersWork} essa é a maior razão do HTML ser tão popular - 
ele perdoa os erros e torna a vida dos autores da WEB mais fácil. Esta
característica deu origem a uma especificação para renderizar HTML
(\textit{HTML parser}).

Antes do HTML5 várias versões foram propostas, algumas radicais
em seus preceitos. O XHTML 2.0, por exemplo, quebrava com toda
a compatibilidade das versões anteriores e acabou por sendo descontinuado.
Outrossim, a maioria das versões HTML de grande sucesso foram versões de
retrospectiva (\textit{retro-specs}). Versões que não tentavam
idealizar a linguagem, buscando alinhar-se com os requerimentos do
mercado \autocite{diveIntohtml}. Não obstante, a ideia que a melhor forma
de ajustar o HTML é substituindo ele por outra coisa ainda aparece de tempos
em tempos \autocite{diveIntohtml}.

Uma página HTML consiste em elementos que podem ter seu comportamento
alterado através de atributos. Um elemento é o abrir fechar de
uma tag e todo o conteúdo que dentro dele reside \autocite[p.
10--11]{htmlAndCssDucket}. Por exemplo, na figura \ref{fig:htmlSample} o elemento
meta (<meta>) tem um atributo \textit{charset}, que especifica o formato de 
codificação do documento.

\begin{figure}[H]
\centering
\begin{verbatim}
<}!DOCTYPE HTML>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title></title>
</head>
<body>
    <video>
        <span>Seu navegador não suporta vídeo</span>
    </video>
</body>
</html>
\end{verbatim}
\caption{Exemplo de documento HTML}
\label{fig:htmlSample}
\end{figure}

Na sua versão inicial, o HTML contava com 18 elementos; atualmente
existem aproximadamente cem \autocite{diveIntohtml}. Não obstante, foi
no HTML5 que a maior parte dos elementos que viabilizam a construção
de jogos foram adicionados.

Uma das características do HTML que o torna tão popular é seu
interesse em manter manter a retrocompatibilidade. Interpretadores
HTML atingem isso ignorando os elementos que não conhecem, tratando
seu vocabulário exclusivamente. Esse mecanismo permite que os
desenvolvedores incluam marcação de reserva dentro dos elementos
que podem não ser suportados. O elemento \textit{span} na figura
\ref{fig:htmlSample} só aparecerá para o usuário caso seu navegador
não suporta a tag vídeo.

Além da convencional linguagem de marcação, HTML é muitas vezes
interpretado como um conceito guarda chuva para designar as tecnologias
da web. Segundo \citet{diveIntohtml} algumas dessas tecnologias (como geolocalização) estão em especificações separadas mas são tratadas como HTML5 também. Outras
tecnologias foram removidas do HTML5 estritamente falando, mas são tratados
como HTML5 (como a API de armazenamento de dados).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{html5.jpg}
    \caption{Suíte HTML}
    \source{http://64vision.com/HTML5-what-is-it}
\end{figure}

Uma tecnologia fortemente entrelaçada com o HTML é o DOM.
Tendo uma relação próxima de um para um com a marcação
\autocite{howBrowsersWork}. DOM permite a interação entre documentos
HTML e as demais tecnologias da WEB de uma forma fácil e padronizada.

\subsection{DOM}
%{{{

O modelo de documento de objetos (\textit{Document Object Model}) é
a representação em memória de uma árvore de elementos HTML. Esta
representação é definida por um conjunto de objetos, unicamente
identificados e dispostos em forma de grafo, que busca facilitar a
manipulação de elementos através de JavaScript.

A primeira versão do DOM, DOM nível zero, foi especificada no
HTML 4 e permitia manipulação parcial dos elementos. Foi somente
com a especificação do JavaScript em 1998 que o DOM nível 1 foi
especificado, permitindo a manipulação de qualquer elemento. DOM
nível 2 e 3 seguiram com melhorias nas consultas aos elementos e CSS.

\begin{figure}[H]
\centering
\begin{verbatim}
    var elementos = document.querySelector( ".main, #sceen"  );
    var elementosB = document.querySelectorAll( "a.minhaClasse, p"  );
\end{verbatim}
\caption{Exemplo de utilização de seletores do DOM em JavaScript}
\label{fig:selectorsSample}
\end{figure}

A API de seletores (\textit{querySelector}) do DOM permite alto
nível de precisão e performance para buscar elementos. A figura
\ref{fig:selectorsSample} exemplifica a utilização dos seletores
do DOM em um documento JavaScript. O método \textit{querySelector}
seleciona o primeiro elemento em conformidade com o padrão
especificado. Já o método \textit{querySelectorAll} seleciona todos os
elementos que estão em acordo com o padrão especificado.

DOM também conta com uma API de eventos que possibilita que, através
de JavaScript, se saiba quando algum evento interessante aconteceu.
Cada evento é representado por um objeto baseado na interface
\textit{Event} e pode ter campos e funções adicionais para prover
maior informação do evento ocorrido \autocite{devdocs}.

Os eventos podem ser criados pelo usuário ou serem lançados pelo
navegador, possibilitando uma manipulação consistente dos mais
variados aspectos de uma aplicação.

Manipulação de entrada de comandos, e muitas varias outras APIs do
HTML, como o IndexedDB, se dá através de eventos, tornando o assunto
relevante aos jogos \footnote{O site http://devdocs.io/dom\_events/
contém uma lista dos eventos lançados automaticamente pelos
navegadores}.
%}}}

Fortemente entrelaçado com o HTML e o DOM está o CSS que possibilita
customizar a apresentação do markup possibilitando experiencias muito
mais ricas do que o conteúdo bruto.
%}}}
\section{CSS}
%{{{
CSS (\textit{Cascading Style Sheets}) é uma linguagem de folhas de
estilo criada por Håkon Wium Lie em 1994 com intuito de definir a
apresentação de páginas HTML. CSS, juntamente com JavaScript e HTML,
compõem as tecnologias centrais no desenvolvimento WEB tornando-se
parte da OWP; sua especificação é atualmente mantida pela W3C.

O termo \textit{Cascading} refere-se ao fato de regras serem
herdadas pelos filhos de um elemento, eliminando grande parcela de
duplicação antes necessária para estilizar uma página. Segundo
\citet{html5mostwanted} pode-se expressar regras gerais que são
"cascateadas" para muitos elementos, e então sobrescrever os elementos
específicos conforme a necessidade.

Segundo \citet[p. 23--24]{CascadingStyleSheets}:
\begin{quote}
CSS possibilita a ligação tardia (\textit{late biding}) com
páginas HTML. Essa característica é atrativa para os publicadores
por dois motivos. Primeiramente pois permite o mesmo estilo em várias
publicações, segundo pois os publicadores podem focar-se no conteúdo
ao invés de se preocuparem-se com detalhes de apresentação.
\end{quote}

Esta ligação tardia permitiu diferenciação entre apresentação e
estrutura, sendo neste caso o CSS responsável pela apresentação. Esta
característica é uma das ideias pioneiras do SGML, motivo que tornou a
utilização do CSS tão conveniente para o desenvolvimento WEB.
Antes do CSS era impossível ter estilos diferenciados para diferentes
tipos de dispositivos, limitando a aplicabilidade dos documentos.
Com CSS também tornou-se possível que o usuário declare suas próprias
folhas de estilo, um recurso importante para acessibilidade.

Estruturalmente falando, CSS é formado por um conjunto de regras,
dentro de uma tag HTML denominada \textit{style}, que são agrupadas
por seletores em blocos de declaração. Os elementos selecionados são
denominados o assunto do seletor \autocite{cssSelectors}. Seletores tem
o intuito de definir quais partes do documento HTML serão afetadas por
determinado bloco de declaração.

CSS é dividido em módulos, que representam conjuntos de
funcionalidades, contendo aproximadamente 50 deles. Cada módulo evolui
separadamente, esta abordagem é preferível pois permite uma maior
quantidade de entrega de novas funcionalidades. Visto que novos recursos
não dependem da aceitação de outros para serem disponibilizados.
Além do módulos, CSS também é organizado por perfis e níveis.

Os perfis do CSS organizam a especificação por dispositivo de
utilização. Existem perfis para dispositivos móveis, televisores,
impressoras, etc. A aplicabilidade das regras do CSS varia dependendo do
perfil. O conteúdo do elemento \textit{strong}, por exemplo, pode ser
traduzido em uma entonação mais forte em um leitor de telas, já em um
navegador convencional pode ser apresentado como negrito.

Já os níveis organizam o CSS por camadas de abstração. Os níveis
inferiores representam as funcionalidades vitais do CSS, os níveis
superiores dependem dos inferiores para construir as funcionalidades
elaboradas.

A primeira especificação do CSS, CSS1 (ou nível 1) foi lançada em
1996. Em 1997 foi lançado o CSS2 com o intuito de ampliar a completude
do CSS1. Em 1998 iniciou-se o desenvolvimento do CSS3 que ainda continua
em 2015. Além do nível 3 existem módulos de nível 4 no CSS, não
obstante o termo CSS3 ainda é o mais utilizado.

Apesar da clara evolução das versões do CSS, esse processo nem
sempre é linear. Em 2005 o grupo de trabalho do CSS decidiu aumentar a
restrição de suas especificações rebaixando o CSS 2.1, Seletores do
CSS3 e Texto do CSS3 de recomendações para rascunhos.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{cssModules.png}
    \caption{Os módulos do CSS}
    \source{https://commons.wikimedia.org/wiki/File:CSS3\_taxonomy\_and\_status-v2.png}
\end{figure}

A última versão do CSS, o CSS3, introduziu várias funcionalidades
relevantes para jogos, como \textit{media-queries}, transições,
transformações 3D, entre outros.

\subsection{Media Queries}

Media Queries permitem aplicar regras a dispositivos específicos,
dependendo de suas capacidades, como resolução, orientação, tamanho
de tela, entre outros. A especificação prevê a possibilidade de
condicionalmente carregar arquivos JavaScript ou CSS, ou utilizar
seletores dentro do CSS de acordo com regras de Media Queries.

Esse carregamento condicional  permite implementar fluidez e
adaptabilidade de layout para diferentes resoluções. Que segundo
\citet{HTML5CrossPlatformGameDevelopment} é o mais importante aspecto do
desenvolvimento de jogos multiplataforma com as tecnologias da WEB.

\begin{figure}[H]
\centering
\begin{verbatim}
@media only screen and (min-width: 1024px) {
    background-color: green;
}
\end{verbatim}
\caption{Exemplo de Media Query}
\label{fig:MediaQuery}
\end{figure}

A figura \ref{fig:MediaQuery} demostra a aplicação de uma regra via
seletor Media Query, aplicando o a cor de fundo para dispositivos com no
mínimo 1024 pixels de resolução.

CSS nível 4 permite a utilização de media queries (\textit{Custom
Media Queries}) criados pelo usuário, com regras e definições
customizadas. A figura \ref{fig:MediaQueryCustom} demostra as novas
possibilidades de definição de media queries tanto em CSS como em
JavaScript.

\begin{figure}[H]
\centering
\begin{verbatim}
@custom-media --narrow-window (max-width: 30em);

<script>
CSS.customMedia.set('--foo', 5);
</script>

\end{verbatim}
\caption{Exemplo de media queries customizados}
\label{fig:MediaQueryCustom}
\source{https://developer.mozilla.org/en-US/docs/Web/CSS/MediaQueries}
\end{figure}

%falar de tamanhos absolutos vs relativo
%Unidades vw e vh para tamanho do viewport

\subsection{Transições}

Transições são uma forma de adicionar animações em uma página
web. Estas animações são compostas por um estado inicial e um final.
A especificação de transições permite grande controle sobre seus
estados, habilitando o desenvolvedor a controlar o tempo de execução,
os estados intermediários, e efeitos aplicados uma transição.

Para utilizar transições, assim como em uma máquina de estados,
precisamos identificar estados e ações. Estados são seletores do CSS
e ações são modificações realizadas entre esses dois seletores CSS
\autocite{html5mostwanted}.

Transições são interessantes em jogos, especialmente pois muitos
navegadores suportam aceleração de GPU (Unidade de processamento
gráfico) para estas operações. Isso garante grandes benefícios de
performance sobre implementações diretamente em JavaScript.

Segundo \citet{html5mostwanted}, transições nos permitem construir jogos
degradáveis pois os interpretadores de CSS são amigáveis; se eles
encontrarem propriedades desconhecidas eles simplesmente as ignoram e
continuam a funcionar.

\begin{figure}[H]
\centering
\begin{verbatim}
div {
    width: 100px;
    height: 100px;
    background: red;
    transition: width 2s;
}

div:hover {
    width: 300px;
}

\end{verbatim}
\caption{Exemplo de transição}
\label{fig:CSSTransition}
%\soruce{http://www.w3schools.com/CSS/css3\_transitions.asp}
\end{figure}

A figura \ref{fig:CSSTransition} demostra a utilização de uma
transição de tamanho em uma \textit{div} quando o mouse está sobre o
elemento. No período de 2 segundos a largura da \textit{div} vai de 100
pixels ara 300 pixels.

Atualmente um conjunto finito de propriedades podem ser animadas
com transições, e essas lista tende a mudar com o tempo, cabe ao
desenvolvedor assegurar-se que determinada propriedade está disponível
\autocite{mdnTransitions}.

\subsection{Transformações 3D}

Transformações é outra tecnologia do CSS3 que permite grande
flexibilidade na construção de jogos. Transformações permitem que
elementos sejam traduzidos, rotacionados, escalados e distorcidos em um
espaço de duas dimensões \autocite{html5mostwanted}.

A transformação demonstrada na figura \ref{fig:CSSTransform} escala o
tamanho do elemento com a classe (\textit{test}) para vinte porcento a
mais do seu tamanho original. Perceba também os comandos repetidos com
o prefixo ms e WebKit. Esse tipo de abordagem é comum para tecnologias
que não passam de rascunhos na especificação.

Assim como transições, as transformações são muitas vezes aceleradas
via GPU incrementando a performance de animações criadas com a tecnologia.

\begin{figure}[H]
\centering
\begin{verbatim}
<style>
.test:hover
{
        -webkit-transform: scale(1.2);
        -ms-transform: scale(1.2);
        transform: scale(1.2);
}
</style>
\end{verbatim}
\caption{Exemplo de transformação}
\label{fig:CSSTransform}
\end{figure}

\subsection{CSS 4}

Apesar de o termo CSS 4 ser bastante utilizado, o grupo de trabalho do CSS
não considera mais a existência de versões, como foi até o CSS3.
Não obstante existem recursos cuja especificação está avançada e não estavam presentes
no CSS 3 quando este foi lançado, dentre estas funcionalidades inclui-se:

\begin{itemize}
\item Suporte a variáveis no CSS
\item Media queries customizadas
\item Funções de cores como: color(), hwb() e gray()
\item Suporte a filtros
\end{itemize}

Recursos recentes do CSS muitas vezes não estão presentes nos
navegadores, não obstante muitos deles são interessantes no contexto
de desenvolvimento de jogos, como o suporte a variáveis.

O projeto cssnext http://cssnext.io/ é uma iniciativa para permitir a
utilização dos recentes recursos do CSS mesmo sem os mesmos estarem
implementados nos navegadores. O projeto funciona compilando o código
não suportado em algo compatível com versões para as versões
implementadas pelos navegadores.

Além da apresentação, recurso vital para jogos, e aplicativos web em
geral, é a iteratividade. Com as tecnologias da WEB esta iteratividade
é atingida através do JavaScript.
%}}}
\section{JAVASCRIPT}
%{{{

EMACScript, melhor conhecida como JavaScript, criada por Brendan Eich em
1992, é a linguagem de script da Web. Devido a tremenda popularidade
entre comunidade de desenvolvedores a linguagem foi abraçada pela W3C e
atualmente é um dos componentes da Open Web.

As definições da linguagem são descritas na especificação ECMA-262.
Esta possibilitou o desenvolvimento de outras implementações além da
original (SpiderMonkey) como o Rhino, V8 e TraceMonkey; bem como
outras linguagens similares como JScript da Microsoft e o ActionScript
da Adobe.

Segundo a \citet{ecmaSpecificaton}:
\begin{quote}
Uma linguagem de script é uma linguagem de programação que é
usada para manipular e automatizar os recursos presentes em um dado
sistema. Nesses sistemas funcionalidades já estão disponíveis
através de uma interface de usuário, uma linguagem de script é
um mecanismo para expor essas funcionalidades para um programa
protocolado.
\end{quote}

No caso de JavaScript na web, os recursos manipuláveis são o conteúdo
da página, elementos HTML, elementos de apresentação,
a própria janela do navegador e variados outros recursos que tem
suporte adicionado por novas especificações.

A intenção original era utilizar o JavaScript para dar suporte aos já
bem estabelecidos recursos do HTML, como para validação, alteração
de estado de elementos, etc. Em outras palavras, a utilização do
JavaScript era opcional e as páginas da web deveriam continuar
operantes sem a presença da linguagem.

Não obstante, com a construção de projetos Web cada vez mais complexos, as
responsabilidades delegadas ao JavaScript aumentaram a ponto que a
grande maioria dos sistemas web não funcionarem sem ele.
JavaScript não evoluiu ao passo da demanda e muitas vezes carece de
definições expressivas, completude teórica, e outras características
de linguagens de programação mais bem estabelecidas, como C++ ou
Java \autocite{crossPlatformMobileGame}.

A última do JavaScript, o JavaScript 6, é um esforço nessa direção.
JavaScript 6 ou EMACScript Harmonia, contempla vários conceitos de
orientação a objetos como classes, interfaces, herança, tipos, etc.
Não obstante o suporte ao JavaScript 6 é apenas parcial em todos
os navegadores. O site http://kangax.github.io/compat-table/es6/
apresenta um comparativo de suporte das funcionalidades do JavaScript.

Segundo \citet{ecmaSupport}, o suporte no início de 2015 era o seguinte:

\begin{itemize}
    \item Chrome: 30\%
    \item Firefox: 57\%
    \item Internet Explorer : 15\%
    \item Opera: 30\%
    \item Safari: 19\%
\end{itemize}

Estes esforços de padronização muitas vezes não são rápidos
o suficiente para produtores de software web, demora-se muito até
obter-se um consenso sobre quais as funcionalidades desejadas em
determinada versão e seus detalhes de implementação. Além da
espera por especificações, uma vez definidas, é necessário que os
navegadores especificado.

O projeto babel https://github.com/babel/babel é um compilador de
JavaScript 6 para JavaScript 5. Permitindo que, mesmo sem suporte, os
desenvolvedores possam usufruir dos benefícios da utilização do
JavaScript 6 durante o tempo de desenvolvimento, gerando código em
JavaScript 5 para rodar nos navegadores.

Alternativamente, existe uma vasta gama de conversores de código
(\textit{transpilers}) para JavaScript; possibilitando programar
em outras linguagens posteriormente gerando código JavaScript
\footnote{Uma lista das tecnologias para converter código HTML pode ser encontrada nos apêndices}.
Entretanto, essa alternativa tem seus pontos fracos, necessita-se
de mais tempo de depuração, visto que o JavaScript gerado não é
conhecido pelo desenvolvedor, e provavelmente o código gerado não
será tão otimizado, nem utilizará os recursos mais recentes do
JavaScript.

Mesmo com suas fraquezas amplamente conhecidas, JavaScript está
presente em praticamente todo navegador atual. Sendo uma espécie de
denominador comum entre as plataformas. Essa onipresença torna-o
integrante vital no processo de desenvolvimento de jogos multiplataforma
em HTML5. Vários títulos renomeados já foram produzidos que fazem
extensivo uso de JavaScript, são exemplos: Candy Crush Saga, Angry
Birds, Dune II, etc.

Jogos Web são geralmente escritos na arquitetura cliente servidor,
JavaScript pode rodar em ambos estes contextos, para tanto, sua
especificação não define recursos de plataforma. Distribuidores do
JavaScript complementam a o JavaScript com recursos específicos para
suas plataformas alvo. Por exemplo, para servidores, define-se objetos como:
console, arquivos e dispositivos; no contexto de cliente,
são definidos objetos como: janelas, quadros, DOM, etc.

Para o navegador o código JavaScript geralmente é disposto no elemento
script dentro de arquivos HTML. Quando os navegadores encontram esse
elemento eles fazem a requisição para o servidor e injetam o código
retornado no documento, e a não ser que especificado de outra forma,
iniciam sua execução.

\subsection{JAVASCRIPT 7}

Antes da finalização da especificação 6, algumas funcionalidades
do JavaScript 7 já haviam sido propostas. Na página
https://github.com/tc39/ecma262 pode-se conferir os itens propostos e
seu estágio de evolução. A figura \ref{fig:ecma7} é a tabela de
funcionalidades sugeridas e seu estágio no caminho da especificação.

Alguns dos recursos esperados para o JavaScript 7 são: guards,
contratos e concorrência no laço de eventos \autocite{ecma7}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{ecma7.png}
	\caption{Propostas do ECMA 7}
	\source{https://github.com/tc39/ecma262}
    \label{fig:ecma7}
\end{figure}

\subsection{ASM.JS}% o correto é asm.js

Asm.js é um subconjunto da sintaxe do JavaScript a qual permite
grandes benefícios de performance quando em comparação com
JavaScript normal. Entretanto, não é trivial escrever código em
asm.js e geralmente a criação de código asm.js é feita através
da conversão de outras linhagens como C. O projeto Emscripten
https://github.com/kripken/emscripten pode ser utilizado para gerar
código em asm.js é utilizado pelo motor de jogos Unity 3D e Unreal.

No contexto dos jogos performance é um fator de extrema importância
asm.js se destaca por utilizar recursos que permitam otimizações
antes do tempo (\textit{ahead of time optimizations}). Grade parcela
da performance adicional, em relação ao JavaScript, é devido a
consistência de tipo e a não existência de um coletor de lixo
(\textit{garbage collector}) a memória é gerenciada manualmente
através de um grande vetor. Esse modelo simples desprovido de
comportamento dinâmico, sem alocação e desalocação de memória,
apenas um bem definido conjunto de operações de inteiros e flutuantes
possibilita grade performance e abre espaço para otimizações.

O desenvolvimento do asm.js iniciou-se no final de 2013 não obstante a
maioria dos navegadores não implementam ou implementam parcialmente o
rascunho. O motor JavaScript da Mozilla, SpiderMonkey, é a exceção,
implementando a grande maioria dos recursos do asm.js.

\subsection{WEB Assembly}
%{{{
Web Assembly é uma tecnologia que pretende definir um formato de
máquina da Web. A tecnologia ainda está em seus estágios iniciais
de desenvolvimento, nem conta com um grupo de trabalho. Não obstante,
sabe-se que WEB Assembly irá permitir que outras linguagens além do
JavaScript gerem código binário que rode nos navegadores com grande
ganhos de performance e flexibilidade.

Além da versão binária, otimizada para performance, uma versão em
texto também está prevista, ideal para desenvolvimento e depuração.
Bibliotecas aplicações que requeiram grande performance como
motores de física, simulações e jogos em geral vão se beneficiar
substancialmente com o Web Assembly.

A iniciativa do Web Assembly está sendo desenvolvida pelo Google,
Microsoft, Mozilla, entre outros, tornando a proposta uma possibilidade
promissora. Seu objetivo não é substituir o JavaScript, outrossim
habilitar que aplicações que necessitem de grande performance possam
ser inclusas na WEB. A ideia do WEB Assembly é uma continuação
do trabalho do asm.js, uma forma de trazer performance similar a
nativa eliminando grande parte das abstrações que o traz JavaScript
embutidas.

Visto que os desenvolvedores de motores JavaScript terão que colocar
o código do Web Assembly na mesma base que o do JavaScript as
expectativas são de que o JavaScript consiga aproveitar partes
da implementação do Web Assembly incrementando a performance do
JavaScript.

A aplicabilidade do Web Assembly em jogos em produção ainda
é praticamente nula. Até então apenas um polyfill do Web
Assembly está disponível e pode ser encontrado no seguinte link
https://github.com/Web\_Assembly/polyfill-prototype-1. Mas conforme a
especificação evolui a probabilidade é que as empresas interessadas
implementem a especificação em seus navegadores e os desenvolvedores
de jogos comecem a integrar a tecnologia em suas aplicações.

%}}}
\subsection{Web Animations}
%{{{

Web Animations é uma especificação em rascunho que define uma forma
imperativa de manipular animações através de JavaScript. Como
demonstrado na figura \ref{fig:webAnimations} a tecnologia vai permitir
manipular as animações de elementos do DOM, com a possibilidade de
filtrar por tipo de animação, alterar a taxa de animações, o tempo
de execução, entre outras propriedades de uma forma dinâmica -
através de scripts.

Visto que Web Animations lida diretamente com o DOM, animações podem
ser aplicadas para SVG além de CSS, servindo como uma tecnologia para
unificar animações.

Grande controle sobre animações é desejável para os
jogos, não obstante, visto que a especificação é muito
nova somente o Google Chrome a implementa. A biblioteca
\url{https://github.com/web-animations/web-animations-js} serve como
polyfill para os demais navegadores.

\begin{figure}[H]
    \centering
    \begin{verbatim}
elem.getAnimations().filter(
  animation =>
    animation.effect instanceof 
    KeyframeEffectReadOnly &&
    animation.effect.getFrames().some(
      frame => frame.hasOwnProperty('transform')
    )
).forEach(animation => {
  animation.currentTime = 0;
  animation.playbackRate = 0.5;
});
    \end{verbatim}
	\caption{Exemplo de utilização de WEB Animatios}
	\source{http://www.w3.org/TR/WEB-animations/}
    \label{fig:webAnimations}
\end{figure}

O site \url{http://web-animations.github.io/web-animations-demos/} contém uma
coleção de animações utilizando a tecnologia.

%}}}
%}}}
\section{NAVEGADORES}
%{{{
Navegadores são aplicações, onde as tecnologias da OWP são
interpretadas e geram um conteúdo útil para os usuários. São
os clientes em uma arquitetura cliente servidor. O servidor desta
arquitetura geralmente é um servidor WEB cujo objetivo principal é
fornecer páginas HTML para o navegador processar. A comunicação entre
o navegador e o servidor WEB se dá através da troca de mensagens no
protocolo HTTP.

Nos navegadores os usuários necessitam saber o endereço de determinado
servidor, ou utilizar buscadores para auxiliá-los. Este é um processo
árduo para as plataformas móveis pois necessitam maior interação dos
usuários, e não são “naturais” se comparado ao modo de consumir
aplicativos nestas mesmas plataformas. Simplesmente adquirindo
o aplicativo na loja e abrindo-o no sistema operacional. Algumas
formas de contornar este problema serão descritos nas seção de
Disponibilização da Aplicação.

Uma vez localizado o endereço o navegador manda uma mensagem em HTTP
requisitando o conteúdo de determinado endereço. O servidor responde a
mensagem HTTP com um documento HTML e o cliente, ao receber, começa o
processo de renderização.

O processo de renderização é complexo e a grande maioria dos
navegadores confia em bibliotecas especializadas para efetuar este
trabalho os motores de renderização.

Alguns motores de renderização incluem:

\begin{itemize}
    \item Blink: Utilizado no Opera, Google Chrome e projetos relacionados;
    \item Gecko: Utilizado nos produtos da Mozilla;
    \item KHTML: Utilizado no navegador Konkeror, esta serviu de base para o Blink;
    \item WebKit: Utilizado no Safari e versões antigas do Google Chrome;
\end{itemize}

A renderização consiste na decodificação de um documento em HTML
para sua representação memória e posterior pintura no espaço de tela
do navegador. Interpretar os documentos é processo árduo e alguns
motores dependem de bibliotecas externas para fazê-lo. 

Para interpretar HTML o motor WebKit utiliza a biblioteca Bison, já
o Gecko utiliza uma biblioteca própria \autocite{howBrowsersWork}.
Durante o processo de renderização o navegador pode requisitar outros
arquivos do servidor a fim de completar a experiência desejada para o
documento em questão.

Geralmente após a renderização do documento vem a execução de scripts.
As bibliotecas que executam JavaScript são chamadas de motores de JavaScript.
Abaixo segue uma lista dos motores de JavaScript mais comuns.

\begin{itemize}
    \item SpiderMonkey: Primeiro motor, desenvolvido por Brendan Eich, escrito em C++
    \item Rhino: Criada pela Netscape, escrito em Java
    \item Nitro: Criada pela Apple
    \item V8: Criada pelo Google
    \item TraceMonkey: Criada pela Mozilla
\end{itemize}

Cada um dos motores que compõem um navegador implementam partes da
especificação do HTML. E, operando em conjunto, tentam comportar
todas as tecnologias da WEB. Infelizmente a forma que as tecnologias
são suportadas varia e algumas não estão presentes de qualquer
forma nos navegadores. Não obstante o suporte vem crescendo. A figura
\ref{fig:audioCodecs} apresenta o gráfico de suporte por versões de
navegadores em dezembro de 2015.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{htmlSupport.png}
	\caption{Suporte das especificações do HTML nos navegadores}
    \label{fig:htmlSupport}
    \source{https://html5test.com/}
\end{figure}

%}}}
\section{ANDROID}
%{{{

É um sistema operacional open-source criado em 2003 pela Android
Inc e mantido pelo Google desde 2005. Android funciona em uma
variedade de dispositivos desde celulares a tablets, netbooks a
computadores desktop, mas seu foco é dispositivos com tela sensível
\autocite{chromeVsAndroid}. O sistema operacional é composto por
diversos projetos open-source, sendo o mais proeminente deles o kernel
Linux, utilizado como fundamento do sistema operacional. Além
da versão open-source (AOSP), existe a versão do Google que utiliza
ferramentas proprietárias  para adicionar funcionalidades aos dispositivos.

Softwares para Android são geralmente escritos em Java e executados
através da máquina virtual Dalvik. Dalvik é similar a máquina
virtual Java, mas roda um formato de arquivo diferenciado (.dex),
otimizados para consumir pouca memória, que são agrupados em um único
pacote (.apk). 

Aplicativos da WEB podem ser integrados no Android através de uma
arquitetura híbrida. Os arquivos da aplicação são empacotados dentro
de um apk utilizando um componente nativo do Android, a API WebView, para
executar as tecnologias da OWP.

Além da arquitetura híbrida, é possível executar jogos WEB em
dispositivos Android através dos navegadores presentes nestes
aparelhos. As novas versões do Android contam com o Google Chrome como navegador
padrão. Já a versões antigas contém um navegador próprio
que utiliza o motor de renderização LibWebCore, baseado no WebKit
\autocite{comparisonPlatforms}. Além do padrão outros navegadores como
o Firefox ou Opera também podem ser instalados.

Além do Android o sistema IOS é de grande relevância mercadológica
para o desenvolvimento de jogos. Não obstante, não será tratado neste
trabalho pelos motivos supracitados. A próxima seção deste trabalho
descreve como detectar recursos nas variadas plataformas que a WEB se
apresenta.

%}}}
\section{DETECÇÃO DE RECURSOS}
%{{{
Visto que nenhum navegador implementa as especificações HTML
completamente, cabe ao desenvolvedor detectar os navegadores que não
comportam as necessidades tecnológicas dos aplicativos que cria. Ao
deparar-se com uma funcionalidade faltante o desenvolvedor tem duas
possibilidades: notificar o usuário sobre o problema ou utilizar
polyfills.

Polyfills são recursos que simulam uma funcionalidade não
disponível nativamente nos navegadores. A biblioteca Gears
\url{https://developers.google.com/gears} é um exemplo. Gears
serve para prover recursos de Geolocalização para navegadores que
não implementam a especificação do HTML5.

Essa capacidade de suportar tecnologias que não estão ainda
disponíveis (ou nunca estarão no caso de dispositivos legados)
através de polyfills é uma das características que faz a WEB uma
plataforma de tão grande abrangência. Novas tecnologias são criadas a
todo o momento; entretanto, o suporte a essas funcionalidades geralmente
não acompanham o passo das inovações. E ainda assim os usuários
podem se beneficiar de uma taxa substancial delas através de polyfills.

Algumas funcionalidades do HTML, como geolocalização e vídeo
foram primeiramente disponibilizadas através de plugins. Outras
funcionalidades, como o canvas, podem ser totalmente emuladas via
polyfills em JavaScript \autocite{diveIntohtml}.

Detectar suporte aos variados recursos do HTML5 no navegador
pode ser uma tarefa entediante. É possível implementar testes para
cada funcionalidade utilizada abordando os detalhes de implementação
de cada uma ou então fazer uso de alguma biblioteca especializada
neste processo. O Modernizr é uma opção open-source deste tipo de
biblioteca, este gera uma lista de booleanos sobre grande variedade dos
recursos HTML5, dentre estes, geolocalização, canvas, áudio, vídeo e
armazenamento local.

A quantidade de especificações que um aplicativo complexo como um jogo
utiliza pode ser bem grande, e muitas vezes é difícil dizer qual quais
navegadores implementam o quê. Uma boa referência do suporte a recursos
nos navegadores é o site \url{http://caniuse.com/}.

%}}}
\section{RENDERIZAÇÃO}
Renderização é parte fundamental de muitos jogos. As tecnologias que
permitem renderização na WEB serão descritas abaixo.
\subsection{SVG}
%{{{
SVG (\textit{Gráficos de vetores escaláveis}), é uma linguagem
baseada em XML especializada na criação de vetores bidimensionais
\autocite{html5mostwanted}. Segundo \cite[p. 4]{svgTime} svg foi criada
em conjunto por empresas como: Adobe, Apple, AutoDesk, entre outas,
sendo que seus produtos contam com rápida integração a tecnologia.

Por descrever imagens utilizando vetores ao invés de mapas de bits
os tamanhos dos arquivos em SVG são geralmente pequenos e podem
ser comprimidos com grande eficiência. Talvez a característica mais
marcante do SVG é que não há diferença de qualidade em resoluções
visto que os vetores são escaláveis. Sendo que pequenos arquivos
servem igualmente bem um monitor com baixa resolução como um monitor
retina.

Por ser baseado em XML, uma das tecnologias da WEB, SVG permite a
utilização da API do DOM para manipular seus elementos. Tornando
simples a integração com outras tecnologias da WEB. Pode-se utilizar
arquivos CSS para customizar a apresentação, JavaScript para adicionar
interatividade, etc.

Além de grande integração com as demais tecnologias, SVG conta com
uma API nativa poderosa. Os elementos geométricos do SVG incluem
retângulos, círculos, elipses, linhas e polígonos \autocite[p.
5]{svgTime}. Também existe a possibilidade de declarar caminhos
customizados através do elemento \textit{path}, algo similar com o
\textit{Path2D} do Canvas.

E cada um dos elementos, ou agrupamento de elementos podem ser
transformados; traduzidos, redimensionados, rotacionados e distorcidos
\autocite[p. 5]{svgTime}.

Para ilustrar a utilização, a figura \ref{fig:svgCircle} demonstra um
círculo sendo definido em SVG.

\begin{figure}[H]
\centering
\begin{verbatim}

<svg width="100" height="100">
  <circle 
    cx="50" 
    cy="50" 
    r="40" 
    stroke="green" 
    stroke-width="4" 
    fill="yellow" 
  />
</svg>

\end{verbatim}
\caption{Círculo em SVG.}
\source{http://www.w3schools.com/svg/}
\label{img:svgCircle}
\end{figure}

Outra tecnologia popular da WEB para renderização que adota uma filosofia totalmente 
diferente do SVG é o canvas.
%}}}
\subsection{CANVAS}
%%{{{
O elemento \textit{canvas} define uma camada de mapa de bits em
documentos HTML que pode ser usada para criar diagramas, gráficos e
animações 2D. Foi criado pela Apple em 2004 para renderizar elementos
de interface no Webkit, logo foi adotado por outros navegadores e se
tornou um padrão da OWP.

Em um documento HTML, canvas é um retângulo onde pode-se usar
JavaScript para desenhar \autocite[p. 113]{diveIntohtml}. Mais
especificamente, o retângulo do canvas é um espaço vetorial cuja
origem se da na esquerda superior. Normalmente cada unidade do plano
cartesiano corresponde a um pixel no canvas \autocite{mdnCanvas}.

Manipular o retângulo é uma analogia de como desenhar manualmente,
move-se o "lápis" para o local desejado e traça-se os pontos onde
a linha (caminho) deve percorrer. Além da possibilidade de desenhar
linhas livremente também é possível criar retângulos nativamente.
Todas as demais figuras geométricas precisam ser feitas através da
junção de caminhos \autocite{mdnCanvas}. Para desenhar caminhos
curvos, de modo a criar círculos e elipses, existem funções especiais
de arco.

Escrever no canvas envolve a manipulação de diversos caminhos e
retângulos, em jogos que fazem extensivo uso do canvas a complexidade
de manipulação de linhas pode crescer muito. As últimas versões do
Canvas introduziram o objeto Path2D que possibilita o armazenamento e
composição de instruções de caminhos a fim de possibilitar o reuso
de formas. Ao invés de utilizar os métodos de caminhos diretamente no
contexto do canvas utiliza-se uma instancia do objeto \textit{Path2D}.
Todos os métodos relacionados aos caminhos como o \textit{moveTo},
\textit{arc} ou \textit{quadraticCurveTo} estão disponíveis no
objeto Path2D \autocite{mdnCanvas}. Também é possível utilizar a
notação do SVG na criação de uma instancia de Path2D possibilitando
a reutilização de conteúdo para ambas as tecnologias.

Além da possibilidade de desenhar programaticamente é possível
carregar gráficos. Muitos dos jogos HTML5 utilizam sprites ou padrões
recortáveis \textit{tiled}, bastante similar aos títulos antigos da
SNES e Game Boy \autocite{buildingHtml5Game}.

Apesar da API do canvas ser poderosa não é possível manipular
diretamente as camadas já desenhadas. Alternativamente pode-se limpar
o canvas inteiramente em pontos determinados ou então sobrescrever as
partes que se deseja alterar.

\begin{figure}[H]
\centering
\begin{verbatim}

var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
ctx.fillStyle = "#FF0000";
ctx.fillRect(0,0,150,75);

\end{verbatim}
\caption{Canvas}
\source{http://www.w3schools.com/html/html5\_canvas.asp}
\label{img:retangleOnCanvas}
\end{figure}

A figura \ref{img:retangleOnCanvas} demonstra a utilização do canvas 2d
para a criação de um retângulo. Note que o objeto canvas tem que carregar um
contexto que então é utilizado como API para manipular a mapa de bits em 2D.

O canvas até aqui descrito trata-se de sua forma, ou contexto 2D. A
especificação 3D do canvas é o WebGl.

%}}}
\subsection{WEBGL}
%{{{

WebGL é uma API JavaScript otimizada desenhar gráficos em três
dimensões. Ideal para a criação de ambientes virtuais, jogos e
simulações. Por ser uma tecnologia da OWP WebGL foi especificado
para funcionar nativamente nos navegadores sem a ajuda de plugins ou
ferramentas de terceiros.

WebGL foi desenvolvido baseando-se na especificação OpenGL a
qual trata de definir como renderizar gráficos multiplataforma.
Especificamente OpenGL ES, uma versão do OpenGL otimizada para
dispositivos móveis. O órgão que especifica o WebGL é o mesmo que
especifica o OpenGL, o grupo sem fins lucrativos Kronos. Os primeiros
rascunhos do WebGL iniciaram em 2006, não obstante o grupo de trabalho
não foi formado até 2009 e a primeira versão do foi lançada em 2011.

Apesar de ter sido desenvolvido com foco em 3D, WebGL pode ser
igualmente utilizado para criação de gráficos em duas
dimensões\autocite[p. 6]{3daps}. O elemento do DOM que provê a
interface do WebGL é o canvas, no contexto 3D. Essa integração com
o DOM via tag canvas permite que o WebGL seja manipulado assim como os
demais elementos HTML.

Especificação é composta por uma API de controle em JavaScript
e o processamento shaders do lado da GPU (Central de processamento
gráfico). 

Shaders são scripts que definem níveis de cor ou efeitos especiais
sobre um modelo 2D ou 3D. Contam com grande performance, possibilitando
conteúdo em tempo real como no caso de jogos. São utilizados no
cinema, em imagens geradas por computadores e vídeo games.

Existem dois shaders principais, de vértices e fragmentos. Shaders de
vértices são chamados para cada vértice sendo desenhado definindo
suas posições definitivas. Já shaders de fragmentos atuam na cor de
cada pixel a ser desenhado \autocite[p.15]{3daps}.

\citet{html5mostwanted} cita que conforme a habilidade do desenvolvedor
aumenta, mover funções antes delegadas ao JavaScript para os shaders
pode aumentar a performance e oferecer uma ampla coleção de efeitos e
realismo.

Um site interessante para explorar exemplos WebGL avançados é o blog
 \url{http://learningwebgl.com} que conta com tutoriais cobrindo áreas
como diferentes tipos de iluminação, carregamento de modelos em JSON,
gerenciando eventos do mouse e teclado; e como renderizar uma cena WebGL
em uma textura \autocite[p.42]{3daps}\footnote{Os apêndices contam.
com uma coleção de bibliotecas que facilitam a utilização de WebGL}.

Apesar da relevância, WebGL não foi utilizado no protótipo pois
ainda não está completamente suportado em navegadores populares como
o Firefox e a grande curva de aprendizado do WebGL puro é muito grande
para se encaixar no escopo deste projeto .

Uma tecnologia que se integra profundamente como ambientes virtuais
em três dimensões criados via OpenGL é o WebVR.
%}}}
\subsection{WEBVR}
%{{{ 
Segundo \citet{virtualReality} realidade virtual é uma experiência em
que o usuário é efetivamente imerso em um mundo virtual responsivo.
Realidade virtual é uma área nem tão nova mas que recebeu interesse
renovado recentemente. Isso se dá, pelo menos me parte, pela
massificação dos dispositivos móveis inteligentes. O hardware
necessário para fornecer uma experiência minimamente viável como
acelerômetros, câmeras e telas de alta resolução está disponível
em praticamente todos os dispositivos comercializados.

Realidade virtual é uma área de grande interessa para os produtores
de jogos, pois pode oferecer alto nível de imersão nos já
interativos e desafiadores ambientes dos jogos.

A WebVR é uma especificação que pretende trazer os benefícios
da realidade virtual para dentro do mundo da WEB. Em termos simples
a especificação define uma forma de traduzir movimentos de
acelerômetros e outros sensores de posição e movimentos para dentro
do contexto de uma um contexto 3D através de JavaScript.

Atualmente a especificação do WebVR se encontra em fase de rascunho e
as últimas versões do Firefox, e versões compiladas manualmente do
Google Chrome já permitem a utilização.
%}}}
\section{WebCL}
%{{{
É uma API em JavaScript para o recursos de OpenCL que permitem
computação paralela com grandes ganhos de performance. Aplicativos
como motores de física e renderizadores de imagens, ambos relevantes
para os jogos, podem se beneficiar grandemente de processamento feito
em paralelo, possivelmente na GPU. OpenCL é um framework para escrever
programas que funcionem em plataformas com diversas unidades de
processamento, assim como WebGL e WebCL é especificada e desenvolvida
pelo grupo Kronos.

A primeira versão da especificação foi no início de 2014 mas até
então nenhum navegador implementa o definido.
%}}}

Após a revisão de tecnologias de renderização serão abordadas
tecnologias de multimídia: áudio e vídeo. Mas para falar de ambos,
antes é necessário falar de codecs.

\section{CODECS}
%{{{

Codec é o algoritmo usado para codificar e decodificar vídeo ou
áudio em um conjunto de bits \autocite{diveIntohtml}. O termo Codec é
um acrônimo, significando o processo de codificar (\textit{coder}) um fluxo de dados
para armazenamento e decodificá-lo (\textit{decoder}) para ser consumido.

Dados multimídia são geralmente enormes, sem serem codificados,
um vídeo ou áudio consistiriam em uma vasta quantidade de dados
que seriam muito grandes para serem transmitidos pela Internet em um
período de tempo razoável \autocite[p. 66]{proHtml5}. O objetivo dos
codecs é diminuir o tamanho dos arquivos com a menor perda de qualidade
possível. Para isso os codecs utilizam de várias estratégias de
compressão ou descarte de dados; podendo rodar tanto em hardware quanto
em software.

Existem codecs desenvolvidos especificamente para a Web. Buscam
uma razão de tamanho e qualidade aceitável, mas prezando por
tamanho. Uma das otimizações realizadas por codecs de vídeo na
Web, é a não troca de todo conteúdo de um quadro para o próximo,
possibilitando maiores taxas de compressão, que resulta em arquivos
menores \autocite{diveIntohtml}.

O funcionamento de codecs pode variar muito, conforme as estratégias
de compressão utilizadas, a quantidade de bits por segundo suportada,
entre outros fatores. Visto que os algoritmos de compressão podem
adquirir grande complexidade muitos codecs são encobertos por licenças
que limitam sua utilização. Não obstante, também existem opções
livres de patentes e licenças.

Abaixo segue uma lista de alguns codecs populares para áudio segundo
\cite[p. 67]{proHtml5}.

\begin{itemize}
    \item ACC
    \item MPEG-3
    \item Vorbis
\end{itemize}

Ainda segundo \cite[p. 67]{proHtml5} abaixo segue uma lista de codecs populares para vídeo.
\begin{itemize}
    \item H.264
    \item VP8
    \item OggTheora
\end{itemize}

Após um fluxo de dados multimídia ter sido codificado através do
algoritmo de codec ele é armazenado em um contêiner. Contêiners
são um padrão de metadados sobre as informações codificadas
de modo a possibilitar que outros programas consigam interpretar
estas informações de forma padronizada. Como um arquivo
\textit{zip}, contêiners podem conter qualquer coisa dentro de si
\autocite{diveIntohtml}. Assim como codecs existem contêiners livres e
com restrições de licença.

Abaixo segue uma lista de alguns contêiners de áudio.
\begin{itemize}
    \item Audio Video Interleave (.avi)
    \item MPEG-2 Audio Layer III (.mp3)
    \item Matroska (.mkv)
    \item Vorbis (.ogg)
    \item Opus (.opus)
\end{itemize}

Abaixo segue uma lista de alguns contêiners de vídeo.
\begin{itemize}
    \item Audio Video Interleave (.avi)
    \item Flash Video (.flv)
    \item MPEG4 (.mp4)
    \item Matroska (.mkv)
    \item Ogg (.ogv)
    \item WebM (.webm)
\end{itemize}

O suporte a codecs e contêiners na WEB varia de navegador para
navegador, de acordo com as preferências mercadológicas, técnicas
ou filosofias das empresas por trás dos navegadores. Segundo
\citet{diveIntohtml} não existe uma única combinação de contêiner
e codecs que funcionem em todos os navegadores \footnote{A figura
\ref{fig:audioCodecs} apresenta um comparativo interessante sobre
os formatos populares de áudio considerando o fator taxa de bits
(quantidade de informação armazenável por segundo) versus qualidade
(perceptível por humanos).}.

%}}}
\section{ÁUDIO}
%{{{

Áudio é um componente vital para oferecer imersão e feedback aos
usuários de jogos. O componente de áudio é especialmente útil para
jogos de ação \autocite{browserGamesTechnologyAndFuture}. Efeitos
de som e música podem servir como parte da mecânica dos jogos.

Antes do HTML5 não havia como consumir áudio na WEB sem a utilização de
plugins de terceiros. A especificação do HTML define duas formas de
utilizar utilizar áudio na WEB: através do elemento HTML áudio ou
através da API JavaScript de áudio.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{codec.png}
	\caption{Comparação de codecs de áudio}
    \label{fig:audioCodecs}
    \source{https://www.opus-codec.org/comparison/}
\end{figure}

\subsection{ELEMENTO ÁUDIO}

O elemento \textit{audio} foi a primeira tecnologia de áudio nativa
para WEB, ele define um som dentro de um documento HTML. Quando o
elemento é renderizado pelos navegadores, ele carrega o conteúdo que
pode ser reproduzido pelo programa dentro do navegador.

\begin{figure}[H]
\centering
\begin{verbatim}
<audio controls>
<source src="horse.ogg" type="audio/ogg">
<source src="horse.mp3" type="audio/mpeg">
Your browser does not support the audio element.
</audio>
\end{verbatim}
\caption{Exemplo de utilização da tag áudio}
\label{fig:htmlAudio}
\source{http://www.w3schools.com/HTML/HTML5\_audio.asp}
\end{figure}

A imagem \ref{fig:htmlAudio} demonstra a utilização da tag
\textit{audio}. Os elementos \textit{source} demonstrados na figura
referenciam arquivos de áudio contendo um par de contêiner
e codec. Mais de um \textit{source } é necessário pois os
criadores de navegadores não chegaram a um consenso sobre qual
formato deve ser usado, sendo necessário utilizar vários para
suportar todos os navegadores populares \footnote{Com o site
\url{http://hpr.dogphilosophy.net/test/} é possível detectar os
formatos de codecs de áudio suportados pelo navegador sendo utilizado}.

A especificação declara que todo o conteúdo dentro de uma tag
\textit{audio}, que não sejam elementos \textit{source}, sejam ignoradas
pelo navegador. O que permite que seja adicionada marcação de reserva
para tratar os casos de quando não existe suporte a tag \textit{audio}
no navegador. Visto que os navegadores que não suportam áudio vão buscar
renderizar o conteúdo dentro da tag.

A figura \ref{fig:htmlAudio} ilustra este comportamento através da
mensagem \textit{Your browser does not support the audio element } que
só será apresentada se o navegador do usuário não tiver suporte a
tag \textit{audio}.

O objetivo inicial da tag \textit{audio} é reproduzir um som e parar.
Ideal para ouvir música, como um som de fundo. Por conseguinte, a tag
\textit{audio} não é o suficiente para comportar aplicações de
áudio complexas \autocite{audioApiSpec}. A grande maioria de jogos
muitas vezes precisam lançar múltiplos sons derivados de ações
de usuário e outros eventos, nestes casos a API de áudio é mais
adequada.

\subsection{API DE ÁUDIO}

É uma interface experimental (ainda em rascunho) em JavaScript para
criar e processar áudio. O objetivo da especificação é incluir
capacidades encontradas em motores de jogos modernos e também permitir
o processamento, mistura e filtragem, funcionalidades que estão
presentes nas aplicações de processamento de áudio modernas para
desktop \autocite{audioApiSpec}.

A API especificada provê uma interface para manipular nodos de
áudio que podem ser conectados permitindo refinado controle sobre os
efeitos sonoros. O processamento se dará primeiramente em uma cada
inferior (tipicamente código Assembly / C / C++), mas síntese e
processamento em JavaScript também será suportado \autocite{audioApiSpec}.

Essa tecnologia é muito mais nova do que o elemento \textit{audio}.
Diferentemente dos demais navegadores o Internet Explorer não
dá nenhum nível de suporte a API. O polyfill AudioContext
suporta as partes básicas da API e pode ser utilizada nos
casos onde não existe suporte para a API do HTML \footnote{O
polyfill AudioContext pode ser encontrado no seguinte endereço
\url{https://github.com/shinnn/AudioContext-Polyfill}}.

As últimas versões da especificação da Audio API contam com a
possibilidade de manipular a API de áudio através de WEB Workers, o
que traz oportunidades interessantes para aplicações que dependam de
muito processamento de áudio, visto que o processamento pode ser
feito em uma thread separada.

Além de grande flexibilidade com áudio alguns jogos requerem a
disponibilidade de vídeo para utilizar como introdução, cinemáticas,
entre outros recursos que habilitam uma experiência mais rica ao
usuário. Abaixo será feita uma revisão sobre a tecnologia de vídeo
em HTML.

%}}}
\section{VÍDEO}
%{{{

O elemento \textit{video} define uma forma de adicionar vídeos na
WEB nativamente, sem a necessidade de utilizar plugins de terceiros
como o Flash Player. Assim como com o elemento \textit{audio} pode-se
adicionar um arquivo através do atributo \textit{src} do elemento
ou adicionar vários formatos de contêiner e codec dentro da tag
através de elementos \textit{source}. O navegador decidirá em tempo de
execução qual formato executar dependendo de suas capacidades.

\begin{figure}[H]
\centering
\begin{verbatim}
<video controls style="width:640px;height:360px;" poster="poster.png">
  <source src="devstories.webm" 
          type='video/webm;codecs="vp8, vorbis"' />
  <source src="devstories.mp4" 
          type='video/mp4;codecs="avc1.42E01E, mp4a.40.2"' />
  <track src="devstories-en.vtt" label="English subtitles" 
         kind="subtitles" srclang="en" default></track>
</video>
\end{verbatim}
\caption{Exemplo de utilização de vídeo}
\source{http://www.html5rocks.com/en/tutorials/video/basics/}
\label{fig:video}
\end{figure}

A figura \ref{fig:video} demonstra a utilização de algumas
funcionalidades do elemento \textit{video}. Como demonstrado na figura,
além do elemento \textit{source}, a tag \textit{video} suporta o
elemento \textit{track}. O qual permite informar subtítulos para os
vídeos sendo apresentados. Também é possível habilitar controles de
vídeo nativos dos navegadores, como demonstrado através do atributo
\textit{controls}.

Como o elemento vídeo se encontra no HTML é possível manipulá-lo com
uma gama de tecnologias. Com CSS é possível aplicar escala de cinza do
sobre o elemento vídeo gerando um efeito preto e branco interessante.
A especificação do elemento \textit{video} também permite controlar
quais partes do vídeo serão mostradas através de parâmetros de tempo
passados como argumentos junto ao nome do arquivo. Ou capturar 
frames de vídeo dentro do elemento canvas.

Além de ser flexível nas tecnologias de multimídia jogos um
requerimento comum em jogos é haver uma forma de armazenar dados
eficientemente e buscá-los com agilidade. Abaixo serão discutidas as
tecnologias de armazenamento disponíveis para a WEB.
%}}}
\section{ARMAZENAMENTO}
%{{{
Uma das grades limitações do HTML era a ausência de capacidade de
armazenamento de dados no lado do cliente. Antes do HTML5 a única
alternativa era usar cookies, os quais tem um armazenamento de no
máximo 4k e trafegam em toda a requisição, tornando o processo lento.
Essa área era ode as aplicações nativas detinham grande vantagem
sobre as aplicações web. O HTML5 solucionou este problema introduzindo
várias formas de armazenamento de dados \autocite{html5Tradeoffs}.

Armazenamento local é um recurso importante para jogos, tanto por
diminuir a latência da persistência na rede, quanto para possibilitar
um experiência offline.

Existem algumas especificações sobre armazenamento, mas a grande
parte delas não conta como suporte completo em todos os navegadores
comuns, um polyfill interessante para Web Storage  e IndexedDB é o
projeto localForge \textit{https://github.com/mozilla/localForage} da
Mozilla.

\subsection{WEB SQL}

A especificação Web SQL introduz uma API para manipular banco de dados
relacionais em SQL. A especificação suporta transações, operações
assíncronas e um tamanho de armazenamento substancial: 5 megabytes, o
qual pode ser estendido pelo usuário.

O grupo de trabalho do Web SQL iniciou-se em 2010 e foi suspendido ainda
como rascunho. Apesar de ser um recurso desejável para muitos
desenvolvedores, foi descontinuada pelos motivos descritos abaixo.

Segundo \citet{diveIntohtml}
\begin{quote}
Todos os implementadores interessados em Web SQL utilizaram a mesma
tecnologia (Sqlite), mas para a padronização ficar completa é
necessário múltiplas implementações. Até outro implementador se
interessar em desenvolver a especificação a descrição do dialeto SQL
apenas referencia o SQLITE, o que não é aceitável para um padrão.
\end{quote}

Não obstante, a especificação ainda é suportada pelo Google
Chrome, Safari, Opera e Android, entre outros. Mas até que outros
implementadores se prontifiquem a especificação continuará suspensa.
No lugar do Web SQL a W3C recomenda a utilização do Web Storage e do
IndexedDB.

\subsection{WEB STORAGE}

Web Storage, também conhecido como Local Storage, provê uma forma de
armazenar dados no formato chave valor dentro do navegador. Os dados são
persistidos mesmo que o usuário feche a página ou o navegador.

Web Storage é um recurso similar a cookies, contudo algumas diferenças
substanciais são perceptíveis. Web Storage não requer que os dados
sejam trafegados como cabeçalhos nas requisições. Também provê
maiores espaços de armazenamento quando comparado a cookies.

A tecnologia começou como parte da especificação do HTML5 mas agora
conta com um documento próprio mantido pela W3C. A especificação é
suportada pela grande maioria dos navegadores populares.

A especificação oferece duas áreas de armazenamento, o armazenamento
local e de sessão. O armazenamento local é persistido por domínio
e outros scripts provindos deste mesmo domínio poderão fazer uso da
informação. O armazenamento de sessão é para informações que podem
variar de aba para aba e que não é interessante que sejam persistidos
para demais acessos além do atual.

A API do Web Storage é simples, consistindo em uma interface para
buscar dados e outra para armazenar, no formato chave/valor.

\begin{figure}[H]
\centering
\begin{verbatim}
// Store value on browser for duration of the session
sessionStorage.setItem('key', 'value');

// Retrieve value (gets deleted when browser is closed and re-opened)
alert(sessionStorage.getItem('key'));

// Store value on the browser beyond the duration of the session
localStorage.setItem('key', 'value');

// Retrieve value (persists even after closing and re-opening the browser)
alert(localStorage.getItem('key'));

\end{verbatim}
\caption{Web Storage na prática}
\label{fig:WebStorage}
\source{https://en.wikipedia.org/wiki/Web\_storage\#usage}
\end{figure}

A figura \ref{fig:WebStorage} exemplifica a utilização do Web
Storage, para utilizar o armazenamento de sessão utiliza-se o objeto
\textit{sessionStorage}. Já para utilizar o armazenamento local utiliza-se o
objeto \textit{localStorage}.

Web Storage é uma solução simples que comporta muitos casos de uso.
Não obstante muitas vezes é necessário um controle mais refinado
sobre os dados, ou mais performance em uma base de dados massiva. Para
responder a estes desafios existe a especificação do IndexedDB.

\subsection{IndexedDB}
%{{{
IndexedDB é um banco de dados que suporta o armazenamento de grandes
quantidades de dados no formato de chave/valor o qual  permite alta
performance em buscas baseadas em índices. A tecnologia é uma recomendação
da W3C desde janeiro de 2015 e suportada, pelo menos parcialmente, por
praticamente todos os navegadores populares.

Inicialmente IndexedDB permitia operações síncronas e assíncronas.
Não obstante, a versão síncrona foi removida devido a falta de
interesse da comunidade. Operações assíncronas permitem que
aplicativos JavaScript nunca esperam pelo resultado para continuar a
execução. Outrossim, cada interação com o banco de dados é uma
transação que pode retornar um resultado ou um erro. Os eventos da
transação são internamente eventos DOM cuja propriedade \textit{type}
do elemento foi setada para \textit{success} ou \textit{error}.

Ao invés de tabelas, IndexedDB trabalha com repositórios de objetos.
Cada entrada, tupla em SQL, de um determinado repositório pode ser de
um formato diferenciado, com exceção da chave única que deve estar
presente em cada uma das entradas.

\begin{figure}[H]
\centering
\begin{verbatim}
	var db;
	var request = window.indexedDB.open("Mydb", 9);
	request.onsuccess = function(event) {
		db = event.target.result;
		var transaction = db.transaction(["customers"], "readwrite");
		var objectStore = transaction.objectStore("customers");
		var request = objectStore.add({email: "mymail@domain.com", name: "foo"});
		request.onsuccess = function(event) {
			console.log('customer added')
		};
	}
\end{verbatim}
\caption{Adicionando um cliente em IndexedDB.}
\label{fig:IndexedDB}
\end{figure}

A figura \ref{fig:IndexedDB} demonstra um exemplo simplificado da
utilização do IndexedDB, como cada iteração com o banco de dados é
construído através de uma nova requisição e o tratamento do resultado
é dado dentro de eventos.

Apesar de ser desenvolvido com objetivo de ser uma solução para todas
as necessidades de armazenamento no Frontend IndexedDB ainda sofre
algumas limitações.

Abaixo segue uma lista com algumas das limitações do IndexedDB.

\begin{itemize}
\item Tem limites de armazenamento e as regras variam de navegador para navegador.
\item O comportamento em abas anônimas não está especificado e os resultados também variam.
\item Existe uma pequena probabilidade de os dados se perderem, no caso do Firefox a API não espera confirmação do sistema operacional para considerar um dado válido, essa foi uma escolha em detrimento de performance.
\item Não existe a possibilidade de fazer buscas em textos como o \textit{LIKE} do SQL.
\item o usuário pode configurar o navegador para não aceitar armazenamento local para determinado domínio.
\end{itemize}

%}}}

A característica assíncrona do IndexedDB, é fundamentada na
premissa de não perturbar o fluxo principal da aplicação enquanto
processamento não vital, e possivelmente demorado, ocorre. Outra
tecnologia da web que utiliza os mesmos princípios é o Web Workers.

%}}}
\section{WEB WORKERS}
%{{{

É uma API que possibilita executar vários scripts
(\textit{threads}) JavaScript ao mesmo tempo. O script que cria uma
thread é chamado de pai da thread, e a comunicação entre pai e filhos
pode acontecer de ambos os lados através de mensagem encapsuladas
em eventos. Um script que não seja pai de uma thread não pode se
comunicar com ela, a não ser que a thread seja em modo compartilhado.

O contexto global (objeto \textit{window}) não existe em uma
thread, no seu lugar o objeto \textit{DedicatedWorkerGlobalScope}
pode ser utilizado. Workers compartilhados podem utilizar o
\textit{SharedWorkerGlobalScope}. Estes objetos contém grande parte das
funcionalidades proporcionadas pelo window com algumas exceções, por
exemplo threads não podem fazer alterações no DOM.

%}}}
\section{OFFLINE}
%{{{
Disponibilizar aplicações WEB offline é uma característica
introduzida no HTML5. Uma nova gama de aplicativos WEB foram
possibilitados devido as tecnologias offline. A importância de gestão
offline é tanta em alguns nichos que os avaliadores do mercado
de software do IOs consideram quase uma obrigação da gestão da
aplicação offline \autocite{publishHtml5}.

Jogos de usuário único podem se beneficiar enormemente de aplicativos
offline, tornando possível utilizar a aplicação com ou sem a
presença de rede. Para tanto é necessário poder armazenar dados
locais, tecnologias como IndexedDB e Web Storage permitem isso. O outro
requerimento para estar offline é uma forma de armazenar os arquivos
da WEB localmente de forma que sejam utilizados quando não houver uma
conexão a rede.

HTML5 conta com uma especificação estável de APIs de cache offline
mantida pela W3C. Esta especificação determina que uma arquivo de
manifesto contenha quais arquivos serão guardados para utilização
offline e possivelmente quais serão usados pela rede.

A figura \ref{fig:offline} exemplifica um arquivo de manifesto. Os
arquivos abaixo da palavra \textit{CACHE MANIFEST} serão armazenados
em cache e não serão buscados na rede a não ser que o arquivo
de manifesto seja modificado. Já os arquivos abaixo da palavra
\textit{NETWORK:} serão utilizados exclusivamente com rede e serão
buscados todas as vezes. Ainda exite a palavra chave \textit{FALLBACK}
onde todos os itens abaixo dela serão utilizados para substituir
arquivos de rede.

É uma boa prática colocar um comentário com a versão do arquivo de
manifestos. Desse modo quando um arquivo for modificado incrementa-se a
versão do arquivo de manifestos e as modificações serão baixadas nos
navegadores clientes.

\begin{figure}[H]
\centering
\begin{verbatim}
CACHE MANIFEST
index.html
help.html
style/default.css
images/logo.png
images/backgound.png

NETWORK:
server.cgi
\end{verbatim}
\caption{Exemplo de arquivo de manifesto offline}
\source{http://www.w3.org/TR/offline-webapps/}
\label{fig:offline}
\end{figure}

%}}}
\section{ENTRADA DE COMANDOS}
%{{{
Na construção da grande maioria dos jogos é muitas vezes
imprescindível grande flexibilidade na gestão de entrada comandos.
Esta necessidade amplia na criação de jogos multiplataforma, em
determinadas plataformas a entrada de comandos pode-se dar través de
teclado, em dispositivos móveis através tela sensível ou sensor de
movimentos.

O HTML5 trata todos estes casos abstratamente na forma de eventos, os
quais podem ser escutados através de \textit{listeners}. JavaScript
pode ser configurado para escutar cada vez que um evento ocorre seja um
clique do mouse o pressionar de uma tecla ou o mover de um eixo em um
joystick.

Quando um evento de interação é disparado, um \textit{listener}
que esteja ouvindo a este evento pode invocar uma função e realizar
qualquer controle desejado \autocite{buildingHtml5Game}.

O teclado é um periférico comum no caso de jogos da WEB, para existem
os eventos \textit{keyup} e \textit{keydown} que representam uma tecla
sendo solta e pressionada respectivamente. A \ref{fig:keyboardEvents}
demostra a captura do pressionar das setas em JavaScript. Cada
número corresponde a um botão do teclado especificado através da tabela ASCII.

\begin{figure}[H]
\centering
\begin{verbatim}
window.addEventListener('keydown', function(event) {
  switch (event.keyCode) {
    case 37: // Left
      Game.player.moveLeft();
    break;

    case 38: // Up
      Game.player.moveUp();
    break;

    case 39: // Right
      Game.player.moveRight();
    break;

    case 40: // Down
      Game.player.moveDown();
    break;
  }
}, false);
\end{verbatim}
\caption{Utilização dos eventos do teclado}
\label{fig:keyboardEvents}
\source{\url{http://nokarma.org/2011/02/27/javascript-game-development-keyboard-input/}}
\end{figure}

\subsection{Gamepad}

Atualmente a única forma de utilizar gamepads na WEB é
através software de terceiros. E sua utilização é limitada
restringida a emulação de mouse e teclado subutilizando seus
recursos \autocite{gamepad}.

Em 2015 a W3C introduziu uma API de Gamepads, atualmente em rascunho,
que pretende solucionar estes problemas. A especificação define um
conjunto de eventos e um objeto \textit{Gamepad} que, em conjunto,
permitem manipular os estados de um Gamepad eficientemente.

Exitem eventos para atividades esporádicas como a conexão de
desconexão de dispositivos. Já acontecimentos mais frequentes, como o
pressionar de botões, é detectado através da inspeção dos objetos
aninhados ao principal \textit{Gamepad}. Cada objeto botão contém um 
atributo \textit{pressed} que pode ser utilizado para saber se foi pressionado.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{gamepad.png}
    \caption{Objetos de um Gamepad}
    \label{fig:gamepad}
    \source{https://w3c.github.io/gamepad}
\end{figure}

A figura \ref{fig:gamepad} contém os objetos tradicionais de um Gamepad.

%}}}
\section{ORIENTAÇÃO}
%{{{
Muitos dispositivos móveis contam com tecnologias que permitem detectar
a orientação física e movimento como acelerômetros e giroscópios.
Visto que são comuns em dispositivos móveis, jogos podem se beneficiar
deste tipo de ferramenta para criar experiências peculiares para seus
usuários.

A W3C tem uma especificação em rascunho que abstrai as diferenças dos
dispositivos e prove uma API padronizada para consumir informações
de orientação. A especificação define dois eventos de DOM
principais: \textit{deviceorientation} e \textit{devicemotion}. 

O evento \textit{deviceorientation} prove a orientação do
dispositivo expressa como uma série de rotações a partir de um
ponto de coordenadas locais \autocite{orientationSpec}. Para colocar
claramente, a o evento lançado em uma mudança de orientação provê
variáveis correspondentes a eixos (alfa, beta, gama) que podem ser
consultadas para determinar a orientação do dispositivo.

Já o evento \textit{devicemotion} dispõe de informações de
orientação, como o evento \textit{deviceorientation} com o adicional
de informar a aceleração do dispositivo. A aceleração também é descrita
em eixos e sua unidade de medida é metros por segundo.

%}}}
\section{HTTP/2}
%{{
HTTP/2 é a última verão do protocolo de trocas de documentos entre
cliente e servidor na WEB. Quando um navegador requisita algum documento
de esta requisição é geralmente feita através do protocolo HTTP. O
foco da nova versão do HTTP é performance; especialmente a latência
percebida pelos usuários e o uso de rede e servidores \autocite{http2}.

A forma que os documentos trafegam do servidor para o
cliente afeta diretamente a performance de uma aplicação, nos jogos
esse fator se amplia devido a grande quantidade de arquivos geralmente
necessários para montar uma cena de jogo.

Diferentemente do HTTP/1, HTTP/2 abre apenas uma conexão por servidor.
Usando a mesma para trafegar todos os dados necessários para montar
a página HTML. Dessa forma o HTTP/2 não necessita repetir as
negociações de protocolo nem aguardar parado quando o limite de
requisições que os navegadores suportam concorrentemente é atingido.
Segundo \citet{gameAssetManagement} o limite concorrente de conexões por
servidor é geralmente 5. Jogos que muitas vezes trafegam muitos objetos
via rede, podem se beneficiar substancialmente.

Outro benefício do HTTP/2 em relação a seu predecessor é que
os cabeçalhos das requisições são comprimidos, diminuindo
substancialmente o tamanho das requisições. HTTP/2 também permite
mensagens do servidor para o cliente (\textit{full-duplex}), o
que abre um leque de novas oportunidades que antes só podiam ser
obtidas através de requisições de tempos em tempos ao servidor
(\textit{pooling}) ou através de WebSockets.

HTTP/2 não recomenda a utilização de minificação nos arquivos,
visto que não existe abertura de novas conexões, trafegar múltiplos
arquivos se tornou barato. Dessa forma, algumas práticas, antes
recomendadas no desenvolvimento WEB, tem de ser revistas depois do
HTTP/2.

Dentro do navegador as requisições HTTP/2 não convertidas em
equivalentes do HTTP/1, mantendo a retrocompatibilidade em aplicações
legadas. Sendo assim, os fatores que justifiquem a utilização do HTTP/1
são escassos e a tendência é observarmos cada vez mais aplicações
utilizando com o HTTP/2.

%}}}
\section{DEBUG}
%{{{

Depuração (\textit{debug}) é o processo de encontrar e reduzir defeitos
em um aplicativo de software ou mesmo hardware \autocite{depuracao}.
As ferramentas de desenvolvimento do Google Chrome (\textit{DevTools})
são uma boa opção para depurar aplicações feitas utilizando as
tecnologias da WEB.

Dos depuradores para navegadores o do Google Chrome é o mais fácil
de utilizar e já vem integrado nativamente junto com o software
\autocite{gamesDebug}.

\citet{chromeDevTools} cita algumas funcionalidades do DevTools:
\begin{quote}
Provê aos desenvolvedores profundo acesso as camadas internas do
navegador e aplicações WEB. É possível utilizar o DevTools
para eficientemente detectar problemas de layout, adicionar
breakpoints em JavaScript, e pegar dicas de otimização de código.
\end{quote}

Estas características são comuns na maioria dos depuradores dos
navegadores como o do Internet Explorer (Visual Studio For Web) e do
Firefox (FireBug) \autocite{gamesDebug}.

Com o DevTools também é possível emular dispositivos alvo da
aplicação ou conectar-se a um dispositivo Android real, ideal para
testar ambientes multiplataforma. Para conectar-se a um dispositivo real
é necessário habilitar a depuração via USB no dispositivo, conectar
o dispositivo via cabo, e rodar o aplicativo no dispositivo através
do Google Chrome ou habilitando o modo depuração nos aplicativos
híbridos. Dessa forma é possível visualizar a aplicação dentro
Google Chrome do computador e utilizar as já mencionadas tecnologias do
DevTools.

O DevTools também permite depuração do elemento canvas. Segundo
\citet{html5mostwanted} com o inspetor WebGl é possível conferir os
estados dos buffers, informações de texturas, frames individuais e
outras informações úteis. Todos os recursos mencionados acima estão
disponíveis tanto para o contexto 2d quanto o 3d do canvas (WebGL).

Especificamente para WebGl existe o plugin independente WebGL Inspector.
A ferramenta permite fazer inspeção da execução de métodos
WebGL, observar o estado de texturas, buffers, controlar o tempo de
execução entre outras funcionalidades \footnote{Mais informações
sobre o WebGL Inspector podem ser encontradas no seguinte endereço
\url{http://benvanik.github.io/WebGL-Inspector/}}.

\subsection{Source Maps}

Source Maps é uma tecnologia que permite mapear códigos fontes
minificados para seus respectivos originais. Este recurso é
interessante pois permite que os desenvolvedores visualizem o código
fonte em sua versão original, legível e fácil de depurar, enquanto
entregam ao usuário final a versão minificada, optimizada para
performance. Para o usuário final não há diferença pois Source Maps
são carregados apenas se as ferramentas de desenvolvimento estão
abertas e com a funcionalidade de Source Maps habilitada.

Source Maps foi desenvolvido como um trabalho em conjunto entre a
Mozilla e Google em 2010, atualmente na terceira revisão o projeto é
considerado estável e não recebe modificações na especificação
desde 2013. Sendo suportado por diversas ferramentas de desenvolvimento
como Google Chrome (DevTools) e Firefox.

A especificação prevê a existência de um arquivo \textit{.map} o
qual contém o mapeamento dos arquivos fonte e outros metadados. Este
arquivo é referenciado pelos arquivos minificados de modo a permitirem
o navegador a realizar o mapeamento.

É possível informar o navegador a localização do arquivo de metadados
seguindo a seguinte sintaxe.

\begin{verbatim}
//# sourceMappingURL=/path/to/script.JavaScript.map
\end{verbatim}

Ou através de cabeçalhos HTTP como demostrado abaixo.

\begin{verbatim}
X-SourceMap: /path/to/script.JavaScript.map
\end{verbatim}

Para os arquivos de Source Maps é possível utilizar ferramentas
especializadas ou integrá-los ao processo de \textit{build} como Grunt ou Gulp
\footnote{A biblioteca https://github.com/mishoo/UglifyJS2 é uma
ferramenta de minificação capaz de gerar Source Maps}.

Após ter o jogo ter sido depurado e seus erros minimizados, pode-se
disponibilizar para ser consumido por seus usuários finais.
Abaixo será abordada algumas formas de disponibilizar jogos web em
ambientes multiplataforma.
%}}}
%}}}
\section{DISPONIBILIZAÇÃO DA APLICAÇÃO} %{{{

Os aplicativos puramente em HTML não requerem instalação e
funcionam apenas acessando o endereço através de um navegador.
\autocite{browserGamesTechnologyAndFuture} cita à respeito de
aplicações WEB: por não requererem instalação, sua distribuição é
superior ao estilo convencional de aplicações desktop.

Não obstante, se o objetivo é fornecer uma experiência similar aos
demais aplicativos mobile ou integrar um sistema de compras, geralmente
feitos através de um mercado como o GooglePlay, pode-se adotar a
alternativa híbrida criando um pacote para o software.

O PhoneGap é uma tecnologia que permite encapsular um código em
HTML e disponibilizá-lo nativamente. Não obstante, para empacotar
os aplicativos localmente é necessária configuração substancial
e só é possível empacotar para IOS em um computador da Apple.
Alternativamente o PhoneGap disponibiliza um serviço de empacotamento
na nuvem que soluciona estes problemas o PhoneGap Build.

Através do PhoneGap Build pode-se carregar um arquivo zip, seguindo
determinado formato, o qual contenha os arquivos escritos com as
ferramentas da web, que o PhoneGap Build se responsabiliza por
empacotá-los nos formatos requeridos para serem instalados em Android,
IOS e Windows Phone.

\citet{publishHtml5} descreve os passos que são feitos pelo PhoneGap para 
disponibilizar a aplicação nativamente.

\begin{itemize}
\item É criada uma aplicação nativa utilizando a WebView da plataforma;
\item Todos os recursos da aplicação são armazenados dentro da aplicação nativa;
\item O PhoneGap carrega o HTML dentro da WebView;
\item A WebView mostra a aplicação para o usuário;
\end{itemize}

No endereço https://github.com/phonegap/phonegap-start encontra-se um
template no formato requerido pelo PhoneGap Build que pode ser utilizado
para começar aplicações que serão servidas através da solução.
%}}}
\section{TRABALHOS SIMILARES}
%{{{
\citet{crossPlatformMobileGame} elaborou uma revisão de aspectos do
HTML5 através da construção de um jogo. O autor foca muito nos
aspectos de criação de jogos e feedback do desenvolvimento. Troca
de tecnologias e não especificamente nas limitações conforme o meu
trabalho. Em outras palavras seu escopo é mais genérico e não tão
preciso quanto este

\citet{aSeriousContender} realizou uma pesquisa através de questionário
e protótipo sobre a viabilidade de aplicativos em HTML5, concluindo que
no geral desenvolvimento de aplicativos em HTML5 são opções viáveis
e lucrativas. Seu trabalho difere a este por não focar no contexto dos
jogos, não observando muitas das nuances e necessidades específicas
para o desenvolvimento de jogos. Outra diferença substancial é que o
autor foca apenas na viabilidade não ressaltando as limitações da
plataforma.

\citet{crossPlatformMobileGameDevelopment} revisa algumas tecnologias
da web e constrói um jogo protótipo para aprender um framework que
possibilita a construção de jogos multiplataforma. Não obstante
o autor foca em um framework de compilação múltipla, não usando
diretamente as tecnologias da WEB. O autor também não foca na experiência do
desenvolvimento ou em coletar limitações como este projeto se propõe.

\citet{viabilityBusinessApplications} estuda a viabilidade de
aplicações comerciais multiplataforma em HTML5 através da
construção de um aplicativo comercial em Sencha Touch. É construída
uma lista de recursos interessantes no desenvolvimento comercial
de aplicações e cada um destes recursos é revisado depois do
desenvolvimento, assemelhando-se muito a metodologia deste trabalho. Em
seu estudo o autor utiliza uma ferramenta de desenvolvimento em C\# que
compila nativamente o que se distancia da proposta deste trabalho de
avaliar as limitações com a construção de um protótipo diretamente
em HTML. O autor também não se foca em tecnologias dos jogos,
outrossim aplicações genéricas.

%}}}
