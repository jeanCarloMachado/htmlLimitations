\section{Jogos Digitais}
%{{{

Segundo \citet{indieGamesLemes}, jogo digital ou videogame constitui-se em uma
atividade lúdica composta por uma série de ações e decisões,
limitadas por regras e pelo universo do game, que resultam em uma
condição final. Apesar da definição clara, uma taxonomia dos jogos
não é tarefa trivial. Pela diversidade em itens e gêneros e a
vasta quantidade de dimensões que os videogames se encontram, uma
categorização dos jogos contemporâneos é extremamente difícil de
desenvolver (muitos já tentaram) \textsc{\autocite[p. 60]{gamebenefits}}.

Para corroborar com essa complexidade, \citet{gamebenefits} afirmam
que a natureza dos jogos tem mudado drasticamente na última década,
tornando-se cada vez mais complexos, diversos, realísticos e sociais
em sua natureza. No contexto Web, com as inovações nas tecnologias
relacionadas ao HTML, novos gêneros de jogos podem ser
explorados. Cada gênero acompanha um conjunto de desafios
específicos. Jogos de FPS (tiro em primeira pessoa) requerem menor
latência de rede, já jogos de RPG (interpretação de personagens)
podem requerer vastas quantidades de cache \textsc{\autocite{html5mostwanted}}.

\subsection{Benefícios}

Em conjunto com as tecnologias, \citet{gamebenefits} afirma que:
\textquotedbl um grupo emergente de pesquisas sobre os benefícios
dos jogos vem se desenvolvendo\textquotedbl{}. Apesar de a quantidade
de estudos sobre os males dos jogos ser muito maior do que os estudos
sobre seus benefícios, a quantidade de benefícios já correlacionados
aos jogos é substancial. Os autores demostram que videogames melhoram
as funções cognitivas, as capacidades criativas, e motivam uma
visão positiva diante a falha, fator que correlaciona-se com melhor
desempenho acadêmico.

Benefícios em habilidades práticas também são observados em
usuários de jogos. Os autores afirmam que jogadores de jogos de tiro demonstram maior
alocação de atenção, maior resolução espacial no processamento
visual e melhores habilidades de rotação.
Estes aspectos positivos muitas vezes não recebem a atenção devida.
Habilidades espaciais derivadas de jogos de tiro, comercialmente
disponíveis, são comparáveis aos efeitos de um curso universitário
que busca melhorar as mesmas habilidades, segundo os autores. Estas
habilidades, derivadas dos jogos, são centrais para muitas áreas de
interesse humano. Os autores por fim afirmam que habilidades espaciais
estão diretamente relacionadas com o sucesso em ciência, tecnologia,
engenharia e matemática.

Outro ponto importante dos jogos é seu aspecto social. Apesar de a
mídia ter criado uma perspectiva negativa sobre jogos, especialmente
os violentos, a realidade é mais complexa do que se pensa. Jogadores
de jogos violentos, cuja jogabilidade encoraje a cooperatividade, são
mais prováveis de exibir comportamento altruísta fora do contexto dos
jogos, do que jogadores de jogos não violentos \textsc{\autocite{gamebenefits}}.

Além dos aspectos benéficos, adiante serão abordados alguns aspectos
técnicos e gerenciais dos jogos.

\subsection{Mecânica}

\citet{html5mostwanted} ressalta a importância do planejamento antes
do desenvolvimento. Ao criar jogos deve-se planejar o que se pretende
atingir e como chegar lá antes de se escrever qualquer código;
definições quanto à mecânica ão um passo vital neste planejamento.

A mecânica é composta pelas regras do jogo. Quais as ações
disponíveis aos usuários e seu funcionamento são fortemente
influenciadas pela categoria do jogo em questão. Dedicar-se na
elaboração de uma mecânica é tarefa quintessencial para a
construção de um jogo de sucesso. A mecânica não pode ser
simplesmente boa, nos melhores jogos ela é intuitiva. O processo de
o jogador entender por si a mecânica do jogo é um componente vital
para a sua satisfação. Se as regras do jogo não forem assimiladas quase
que instantaneamente, muitas pessoas vão perder o interesse e desistir
rapidamente \textsc{\autocite{crossPlatformMobileGame}}.

Ainda sobre a importância da mecânica, \citet{html5mostwanted} afirma
que se os gráficos e áudio são espetaculares, mas a jogabilidade
é chata, o jogador vai parar de jogar. A substância do jogo é
sua mecânica, então não invista muito em visual ao menos que
isso desempenhe um papel essencial no jogo. Os desenvolvedores tem
que evitar fazer o jogo para eles mesmos. Falta de crítica antes
do desenvolvimento também tende a gerar jogos ruins. Bons jogos
são aqueles que ao menos suprem as expectativas dos usuário.
\citet{indieGamesLemes} aponta alguns fatores procurados pelos usuários
de jogos: desafio, socializar, experiência solitária, respeito e
fantasia. Jogos que conseguem integrar o maior número destes aspectos
em sua mecânica serão os mais apreciados. A elaboração da mecânica
em jogos desenvolvidos profissionalmente pode ser integrada dentro de um
processo de engenharia de software.

Depois dos preparativos efetuados, pode-se começar a construção
do jogo.

\subsection{Laço}

Jogos digitais geralmente operam através um laço que executa uma
série de tarefas a cada iteração, construindo a ilusão de um mundo
animado \textsc{\autocite[p. 31]{gwt}}. Da perspectiva da programação, a parte
principal de um jogo é o laço onde o jogo é executado \autocite[p.
17]{crossPlatformMobileGameDevelopment}. A cada iteração do laço
o processamento de entrada de dados do usuário e alterações da
cena tem de ser computados, tornando a otimização deste processo
importantíssima para que o jogo não se torne lento\footnote{Na seção
\ref{optimizations} foram descritas as opções da Web
na hora de construir um laço de jogo.}.

Outra decisão técnica importante na hora de desenvolver jogos é a
seleção das plataformas alvo mais adequadas. Neste trabalho o foco será
em  HTML para desktops e dispositivos móveis inteligentes. Não obstante,
na seção a seguir serão descritas as plataformas que os
desenvolvedores podem selecionar ao desenvolver jogos, juntamente com
seus benefícios e fraquezas.

\section{Jogos Multiplataforma}

Jogos multiplataforma são jogos que rodam em mais de uma plataforma.
Cada plataforma contém sua própria API (\textit{Application
Programming Interface}), sendo que se um aplicativo foi criado para
uma plataforma ele não vai poder ser utilizado em outra pois as
APIs são diferentes \textsc{\autocite{crossPlatformMobileGameDevelopment}}.
Além da API, dispositivos de múltiplas plataformas variam em seus
recursos, capacidades e qualidades. Devido a essas características,
desenvolvedores de jogos que almejem múltiplas plataformas, deparam-se
com uma nova gama de oportunidades e desafios.

Um destes desafios é fornecer \textit{feedback} suficiente para o
jogador, pois muitas vezes o dispositivo é limitado em proporções,
som e tela. Devido a estes requerimentos, tendências como Web design
responsivo (RWD) emergiram. Requerendo que os desenvolvedores busquem
criar interfaces cada vez mais fluídas e intuitivas. As tecnologias
da Web também tiveram que acompanhar a mudança. CSS3 media queries
e tamanhos relativos, tratadas adiante, são exemplos de tecnologias
desenvolvidas com o foco em multiplataforma.

Outro desafio multiplataforma é suportar os vários ecossistemas
de software com tecnologias diferenciadas e versões de
software divergentes. Para que um jogo multiplataforma tenha
sucesso é necessário definir com cautela suas tecnologias.
\citet{html5mostwanted} afirma que: o estágio mais complicado e crucial
do desenvolvimento de jogo é a escolha das tecnologias utilizadas.
Designers de jogos tem as seguintes possibilidades quando em face
de desenvolver um jogo multiplataforma: criar um jogo Web, um jogo
híbrido ou nativo. As opções serão descritas a seguir.

\subsection{Jogos Web}

Um jogo Web utiliza o HTML e ferramentas correlacionadas
para sua construção e disponibilização. No entanto, o objetivo
primário da Web nunca foi o desenvolvimento de jogos. Por muito
tempo, os títulos famosos de jogos da Web residiam em jogos como
\textit{Traviam}, desprovidos de animações, compostos basicamente por
formulários, imagens e textos. Durante esse período, o interesse em
jogos Web residia principalmente na casualidade, flexibilidade, e no
fator social.

Mais recentemente é que a Web começou a ser vista como de fato um
ambiente com interatividade para criação de jogos dos mais variados
gêneros. Publicar jogos baseados em texto é uma atividade cada vez
mais rara, podendo-se concluir que interface gráfica se tornou uma
funcionalidade mandatória \textsc{\autocite{browserGamesTechnologyAndFuture}}.
Jogos como BrowserQuest, Angry Birds, entre outros títulos expandiram
os conceitos do que é possível se fazer utilizando as ferramentas
da Web. Segundo \citet[p. 28]{gwt} um bom exemplo que tem alcançado
bastante sucesso entre o público são os jogos adicionados no logotipo
do Google, chamados doodles.

Quando comparados a outras abordagens de criar jogos, jogos na Web
contém vários aspectos positivos. Talvez o mais reconhecível
é o fato de com uma única base de código poder suprir uma gama
praticamente inesgotável de dispositivos. Comparável a base de
clientes está a quantidade de desenvolvedores Web, os quais podem
reaproveitar grande parcela do conhecimento adquirido através
do desenvolvimento de páginas Web na criação de jogos. Sua
distribuição também é superior ao estilo convencional das
aplicações desktop \textsc{\autocite{browserGamesTechnologyAndFuture}}. Por
serem criados a partir das tecnologias da Web, jogos Web se beneficiam
de uma arquitetura construída para um ambiente em rede, sendo
relativamente mais fácil criar experiências sociais.

A performance é um ponto negativo da Web, é difícil chegar a
performance comparável a abordagem nativa. Contudo, esse problema
é cada vez menor, visto que o hardware dos dispositivos são cada
vez mais potentes e as tecnologias de software também avançam
substancialmente em performance. Outro problema da abordagem Web é que
existem inconsistências nas implementações das especificações que
formam a Web o que leva a comportamento inesperados em alguns caos,
sendo necessário desenvolver regras específicas para dispositivos
e versões de navegadores. Outra fraqueza notável da Web é que nem
todas as funcionalidades dos dispositivos estão especificados com as
tecnologias da Web e muitas vezes os recursos dos dispositivos ficam
subutilizados.

Além dos jogos web, há a possibilidade de criar jogos nativos e híbridos.

\subsection{Desenvolvimento de Jogos Nativos}

Uma aplicação nativa é uma aplicação que foi desenvolvida para ser
utilizada em uma plataforma ou dispositivo específico \autocite[p.
7]{aSeriousContender}. Aplicativos nativos tendem a oferecer uma
experiência mais próxima com a do resto do sistema operacional a qual
estão rodando. Potencialmente, softwares nativos são mais rápidos
que suas alternativas da Web, visto que interagem com o dispositivo
através do sistema operacional. Diferentemente dos jogos Web, que
necessitam que o navegador interaja com o sistema operacional, para
por sua vez interagir com o dispositivo. Por terem acesso total ao
dispositivo, aplicativos nativos podem aproveitar o hardware da melhor
forma possível e oferecer ao usuário a melhor experiência possível
\textsc{\autocite[p. 7]{aSeriousContender}}.

Um dos pontos negativos da abordagem nativa, é que tende a ser mais
caro que a alternativa da Web, visto que é necessário duplicar
funcionalidades em sistemas distintos e possivelmente manter um
profissional por ambiente suportado.

A alternativa hibrida fica em meio ao desenvolvimento nativo e Web e
será descrita abaixo.

\subsection{Jogos Híbridos}

A alternativa híbrida é uma tentativa de beneficiar-se das melhores
características da abordagem nativa e o melhor do desenvolvimento
Web. Muitas vezes desenvolve-se aplicações híbridas utilizando as
tecnologias da Web só que ao invés de disponibilizar a aplicação
através de um navegador a aplicação Web é instalada como um
aplicativo normal. A aplicação roda em uma WebView que é um
componente do sistema operacional capaz de rodar as tecnologias da
Web. Desta forma o aplicativo Web conversa diretamente com o sistema
operacional, não necessitando da intervenção de um software terceiro
para mediar a interação.

Outra possibilidade híbrida é escrever o software em uma linguagem
e gerar binários para as plataformas alvo. Utilizando o Xamarin é
possível desenvolver em C\# e compilar para diversas plataformas
nativamente. Através dessa abordagem é possível beneficiar-se de um
aplicativo nativo e eliminar grande parte da duplicação geralmente
imposta \footnote{Os frameworks multiplataforma dos apêndices contém
tecnologias similares ao Xamarin como o Titanium}.

Visto que a estratégia híbrida geralmente tem acesso ao sistema
operacional, é possível criar APIs para acessar recursos não sempre
disponíveis para a plataforma Web. Soluções como o PhoneGap
adotam essa estratégia para habilitar controle refinado sobre os
recursos dos dispositivos através de APIs JavaScript.
Outro benefício da estratégia híbrida em relação à Web é que
ela permite empacotar as aplicações com um experiência exata a
dos softwares nativos. Tornando imperceptível para o usuário final a
diferença ente um aplicativo híbrido e um nativo.

Todavia, segundo \citet[p. 8]{aSeriousContender}, a diferença entre o
que é possível com a estratégia híbrida e a Web está diminuindo
devido ao grande esforço da comunidade Web para prover novas
especificações.

%}}}
\section{Web}
%{{{

A Web (World Wide Web) é uma plataforma de compartilhamento de
documentos que funciona sobre a Internet. Criada por Tim Berners-Lee
em 1989, enquanto trabalhava para o CERN, sendo que hoje desempenha papel
vital na proliferação de informações da civilização moderna.
Em 1990 Berners-Lee havia criado todas as ferramentas necessárias
para viabilizar a Web: o primeiro navegador, o primeiro servidor
Web e a primeira página, que era utilizada para descrever o projeto
\textsc{\autocite{www}}.

Os documentos na Web são identificados por URLs (\textit{uniform
resource locator}), sendo que cada documento pode referenciar outros,
criando a \textquotedbl teia\textquotedbl{} que o nome Web se refere.
Na época de sua criação tanto Hipertexto quanto a internet já eram
coisas comuns. A grande inovação da Web é que Tim ligou ambos criando
uma experiência totalmente revolucionária.

\subsection{Open Web}

A OWP (\textit{Open Web Platform}) é uma coleção de tecnologias
livres, amplamente utilizadas e padronizadas que viabilizam a Web.
Quando uma tecnologia se torna amplamente popular, através da adoção
de grandes empresas e desenvolvedores, ela se torna candidata a adoção
pela OWP. Os benefícios de utilizar tecnologias da OWP são vários.
\citet[p. 3]{svgTime} cita que as tecnologias padronizadas tem um maior
ciclo de vida e são mais fáceis de dar manutenção. Da mesma maneira,
as tecnologias da Web são benéficas devido a sua grande adoção,
permitindo que aplicações baseadas nelas tenham impacto na maior
quantidade de clientes possível.

Não obstante, mais do que tecnologias a OWP é um conjunto de
filosofias as quais a Web se fundamenta \textsc{\autocite{openWebDefinition}}.
Entre outras, a Open Web busca transparência, imparcialidade nos
processos de criação e padronização de novas tecnologias,
respeito ao usuário, retro compatibilidade com as especificações
anteriores e consenso entre o mercado e o meio acadêmico, nunca
um distanciando-se muito do outro \footnote{Mais informações
sobre a Open Web podem ser encontradas no seguinte endereço
\url{http://tantek.com/2010/281/b1/what-is-the-open-web}}.

Várias pessoas, empresas e comunidades estão interessadas neste
processo, cada qual com seu próprio conjunto de ideias sobre como
a Web deveria funcionar. E para que a crescente quantidade de
dispositivos possa acessar a riqueza que o HTML5 permite, padrões
precisam ser definidos \textsc{\autocite[p. 5]{aSeriousContender}}.

A W3C é a organização responsável por boa parte das especificações
da Web como: HTML (em conjunto com a WHATWG), CSS, entre
outras\footnote{Uma lista completa das especificações mantidas pela
W3C pode ser encontrada em: \url{http://www.w3.org/TR/}}. Outros grupos
detém responsabilidade por outras tecnologias da OWP, como a ECMA,
responsável pelo JavaScript; ou Kronos, responsável pelo WebGL. Na
W3C o processo de desenvolvimento de especificações consiste na
elaboração de rascunhos (\textit{working drafts}), criados por grupos
de trabalhos (\textit{working groups}) de especialistas no assunto, que
passam por vários passos de revisão até se tornarem recomendações.
As recomendações podem ser implementadas com segurança de que a
especificação não mudará substancialmente.

Apesar do processo da W3C ser rigoroso, está longe de perfeito. A
especificação final do HTML4 contava com quatro erros publicados
via errata \textsc{\autocite{diveIntohtml}}. Mesmo assim o cenário é animador,
\citet{html5mostwanted} cita que as tecnologias da Open Web tem
evoluído desde os princípios da internet e já provaram sua robusteza
e estabilidade enquanto outras tecnologias crescem e morrem ao redor
dela.

A tecnologia chave que inaugurou e alavancou este processo é o HTML.
%}}}
\section{HTML}
%{{{

HTML (\textit{Hyper Text Markup Language}) é uma linguagem de
marcação que define a estrutura semântica do conteúdo das páginas
da Web. É a tecnologia base para a criação de páginas Web e
aplicativos online. A parte denominada: \textquotedbl \textit{Hyper Text}\textquotedbl{}, refere-se
a links que conectam páginas HTML umas as outras, fazendo a Web como
conhecemos hoje \textsc{\autocite{mdn2015}}.

A última versão do HTML é o HTML5, iniciado pela WHATWG e
posteriormente desenvolvido em conjunto com a W3C. Seu rascunho foi
proposto em 2008 e ratificado em 2014. Após 2011, a última chamada
de revisão do HTML5, a WHATWG decidiu renomear o HTML5 para HTML
\textsc{\autocite{htmlIsTheNewHtml5}}. Todavia, o termo HTML5 permanece em
utilização pela W3C.

Além da nomenclatura, existem pequenas diferenças nas especificações
da WHATWG e W3C. A W3C vê a especificação do HTML5 como algo fechado,
inclusive já iniciou o desenvolvimento do HTML 5.1. Já a WHATWG vê o
HTML5 como uma especificação viva. A postura da W3C tende a criar uma
especificação estável. Já a postura da WHATWG reflete a realidade dos
navegadores: que nunca implementam uma versão do HTML completamente. A Mozilla
utiliza a especificação da WHATWG no desenvolvimento do Firefox e
recomenda a da W3C para sistemas que requeiram maior estabilidade. Neste
trabalho optamos pela nomenclatura da WHATWG, utilizamos o termo HTML em
detrimento a HTML5, sempre que semanticamente viável.

HTML foi especificado baseando-se no padrão SGML (\textit{Standard Generalized
Markup Language}). Alguns benefícios do SGML são:

\begin{itemize}
    \item Documentos declaram estrutura, diferentemente de aparência
, possibilitando otimizações nos ambientes de uso (tamanho de tela,
etc);
    \item São portáveis devido a definição de tipo de documento
(\textit{document type declaration}).
\end{itemize}

Apesar de o SGML especificar a não definição de aparência, os criadores de
navegadores constantemente introduziam elementos de apresentação como o
piscar, itálico, e negrito, que eventualmente acabavam por serem inclusos
na especificação. Foi somente nas últimas versões que elementos de
apresentação voltaram a ser proibidos reforçando as propostas chave
do HTML como uma linguagem de conteúdo semântico, incentivando a
utilização de outras tecnologias como o CSS para responder as demandas de
apresentação.

Além do HTML, existe o XHTML, que é uma iniciativa de utilização de
XML nas páginas da web. O XML é um padrão mais rigoroso que SGML e
resulta em páginas sem problemas de sintaxe e tipografia. 
Alguns estimam que 99\% das paginas HTML de hoje
contenham ao menos um erro de estrutura \textsc{\autocite{diveIntohtml}}.
Uma das maiores vantagens do XML é que sistemas sem erros de sintaxe
podem ser facilmente interpretadas por outras tecnologias como
sistemas de indexação, buscadores, etc.

Para transformar o HTML em algo visível, os navegadores utilizam motores
de renderização. O primeiro passo efetuado por esses sistemas é
decodificar o documento HTML para sua representação em memória. Este
processo dá-se através da análise (\textit{parsing}) e posterior
tokenização, que é a separação do HTML em palavras chave que o
interpretador pode utilizar. Diferentemente do XHTML, HTML não pode
ser decodificado através de tokenização tradicional. Isso deve-se ao fato do HTML
ser amigável ao programador, aceitando erros de sintaxe, dependente
de contexto, buscando entregar a melhor aproximação possível. 
Segundo \citet{howBrowsersWork} essa é a maior razão do HTML ser tão popular - 
ele perdoa os erros e torna a vida dos autores da Web mais fácil. Esta
característica deu origem a uma especificação para renderizar HTML
(\textit{HTML parser}).

Antes do HTML5 várias versões foram propostas algumas radicais
em seus preceitos. O XHTML 2.0, por exemplo, quebrava com toda
a compatibilidade das versões anteriores e acabou por sendo descontinuado.
Outrossim, a maioria das versões HTML de grande sucesso foram versões de
retrospectiva (\textit{retro-specs}). Versões que não tentavam
idealizar a linguagem, buscando alinhar-se com os requerimentos do
mercado \textsc{\autocite{diveIntohtml}}. Não obstante, a ideia que a melhor forma
de ajustar o HTML é substituindo ele por outra coisa ainda aparece de tempos
em tempos \textsc{\autocite{diveIntohtml}}.

Uma página HTML consiste em elementos que podem ter seu comportamento
alterado através de atributos. Um elemento é o abrir e fechar de
uma tag e todo o conteúdo que dentro dela reside \autocite[p.
10--11]{htmlAndCssDucket}. Na sua versão inicial, o HTML
contava com 18 elementos; atualmente existem aproximadamente 100
\textsc{\autocite{diveIntohtml}}. Entretanto, foi no HTML5 que a maior parte dos
elementos que viabilizam a construção de jogos foram adicionados.

Uma das características do HTML que o torna tão popular é seu
interesse em manter a retrocompatibilidade. Interpretadores
HTML atingem isso ignorando os elementos que não conhecem, tratando
seu vocabulário exclusivamente. Esse mecanismo permite que os
desenvolvedores incluam marcação de reserva dentro dos elementos
que podem não ser suportados.

Além da convencional linguagem de marcação, HTML é muitas vezes
interpretado como um conceito guarda chuva para designar as tecnologias
da Web. Segundo \citet{diveIntohtml} algumas dessas tecnologias (como
geolocalização) estão em especificações separadas mas são
tratadas como HTML5 também. Outras tecnologias foram removidas do
HTML5 estritamente falando, mas são tratados como HTML5 (como a API de
armazenamento de dados).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{html5.jpg}
    \caption{Suíte HTML}
    \source{http://64vision.com/HTML5-what-is-it}
\end{figure}

Uma tecnologia fortemente entrelaçada com o HTML é o DOM.
Tendo uma relação próxima de um para um com a marcação
\textsc{\autocite{howBrowsersWork}}. DOM permite a interação entre documentos
HTML e as demais tecnologias da Web de uma forma fácil e padronizada.

\subsection{DOM}
%{{{

O modelo de documento de objetos (\textit{Document Object Model}) é
a representação em memória de uma árvore de elementos HTML. Esta
representação é definida por um conjunto de objetos, unicamente
identificados e dispostos em forma de grafo, que busca facilitar a
manipulação de elementos através de JavaScript.

A primeira versão do DOM, DOM nível zero, foi especificada no
HTML 4 e permitia manipulação parcial dos elementos. Foi somente
com a especificação do JavaScript em 1998 que o DOM nível 1 foi
criado, permitindo a manipulação de qualquer elemento. DOM
nível 2 e 3 seguiram com melhorias nas consultas aos elementos e CSS.

A API de seletores (\textit{querySelector}) do DOM permite alto
nível de precisão e performance para buscar elementos. Os métodos
\textit{querySelector} e \textit{querySelectorAll} buscam aproximar-se
do funcionamento do jQuery, habilitando filtrar por classes, elementos,
identificadores ou uma junção destes.

DOM também conta com uma API de eventos que possibilita que, através
de JavaScript, se saiba quando algum evento interessante aconteceu.
Cada evento é representado por um objeto baseado na interface
\textit{Event} e pode ter campos e funções adicionais para prover
maior quantidade de informações \textsc{\autocite{devdocs}}. Os eventos
podem ser criados pelo usuário ou serem lançados pelo navegador,
possibilitando uma manipulação consistente dos mais variados
aspectos de uma aplicação. Manipulação de entrada de comandos e
muitas outras APIs do HTML, como o IndexedDB, se dão através
de eventos DOM tornando o assunto relevante aos jogos \footnote{O site
http://devdocs.io/dom\_events/ contém uma lista dos eventos lançados
automaticamente pelos navegadores}.
%}}}

Fortemente entrelaçado com o HTML e o DOM está o CSS que possibilita
customizar a apresentação do markup habilitando experiências muito
mais ricas do que conteúdo bruto.
%}}}
\section{CSS}
%{{{
CSS (\textit{Cascading Style Sheets}) é uma linguagem de folhas de
estilo criada por Håkon Wium Lie em 1994 com intuito de definir a
apresentação de páginas HTML. CSS, juntamente com JavaScript e HTML,
compõem as tecnologias centrais no desenvolvimento Web tornando-se
parte da OWP; sua especificação é atualmente mantida pela W3C.

O termo \textit{Cascading} refere-se ao fato de regras serem
herdadas pelos filhos de um elemento, eliminando grande parcela de
duplicação antes necessária para estilizar uma página. Segundo
\citet{html5mostwanted} pode-se expressar regras gerais que são
\textquotedbl cascateadas\textquotedbl{} para muitos elementos, e então sobrescrever os elementos
específicos conforme a necessidade.

Segundo \citet[p. 23--24]{CascadingStyleSheets}:
\begin{quote}
CSS possibilita a ligação tardia (\textit{late biding}) com
páginas HTML. Essa característica é atrativa para os publicadores
por dois motivos. Primeiramente pois permite o mesmo estilo em várias
publicações, segundo pois os publicadores podem focar-se no conteúdo
ao invés de se preocuparem com detalhes de apresentação.
\end{quote}

Esta ligação tardia permitiu diferenciação entre apresentação e
estrutura, sendo neste caso o CSS responsável pela apresentação. Esta
característica é uma das ideias pioneiras do SGML, motivo que tornou a
utilização do CSS tão conveniente para o desenvolvimento Web.
Antes do CSS era impossível ter estilos diferenciados para diferentes
tipos de dispositivos, limitando a aplicabilidade dos documentos.
Com CSS também tornou-se possível que o usuário declare suas próprias
folhas de estilo, um recurso importante para acessibilidade.

Estruturalmente falando, CSS é formado por um conjunto de regras,
dentro de uma tag HTML denominada \textit{style}, que são agrupadas
por seletores em blocos de declaração. Os elementos selecionados são
denominados o assunto do seletor \textsc{\autocite{cssSelectors}}. Seletores tem
o intuito de definir quais partes do documento HTML serão afetadas por
determinado bloco de declaração.

CSS é dividido em módulos, que representam conjuntos de
funcionalidades, contendo aproximadamente 50 deles. Cada módulo evolui
separadamente, esta abordagem é preferível pois permite uma maior
quantidade de entrega de novas funcionalidades. Visto que novos recursos
não dependem da aceitação de outros para serem disponibilizados.
Além do módulos, CSS também é organizado por perfis e níveis.

Os perfis do CSS organizam a especificação por dispositivo de
utilização. Existem perfis para dispositivos móveis, televisores,
impressoras, etc. A aplicabilidade das regras do CSS varia dependendo do
perfil. O conteúdo do elemento \textit{strong}, por exemplo, pode ser
traduzido em uma entonação mais forte em um leitor de telas, já em um
navegador convencional pode ser apresentado como negrito.

Já os níveis organizam o CSS por camadas de abstração. Os níveis
inferiores representam as funcionalidades vitais do CSS, os níveis
superiores dependem dos inferiores para construir funcionalidades
mais elaboradas.

A primeira especificação do CSS, CSS1 (ou nível 1), foi lançada em
1996. Em 1997 foi lançado o CSS2 com o intuito de ampliar a completude
do CSS1. Em 1998 iniciou-se o desenvolvimento do CSS3 que ainda continua
em 2015. Além do nível 3 existem módulos de nível 4 no CSS, não
obstante o termo CSS3 ainda é o mais utilizado.

Apesar da clara evolução das versões do CSS, esse processo nem
sempre é linear. Em 2005 o grupo de trabalho do CSS decidiu aumentar a
restrição de suas especificações rebaixando funcionalidades do CSS
2.1 e CSS3 de recomendações para rascunhos.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{cssModules.png}
    \caption{Os módulos do CSS}
    \source{https://commons.wikimedia.org/wiki/File:CSS3\_taxonomy\_and\_status-v2.png}
\end{figure}

A última versão do CSS, o CSS3, introduziu várias funcionalidades
relevantes para jogos, como \textit{media-queries}, transições,
transformações 3D, entre outros.

\subsection{Media Queries}

Media Queries permitem aplicar regras a dispositivos específicos,
dependendo de suas capacidades, como resolução, orientação, tamanho
de tela, entre outros. A especificação prevê a possibilidade de
condicionalmente carregar arquivos JavaScript ou CSS, ou utilizar
seletores dentro do CSS de acordo com regras de Media Queries.

Esse carregamento condicional  permite implementar fluidez e
adaptabilidade de layout para diferentes resoluções. Que segundo
\citet{HTML5CrossPlatformGameDevelopment} é o mais importante aspecto do
desenvolvimento de jogos multiplataforma com as tecnologias da Web.

\begin{figure}[H]
\centering
\begin{verbatim}
@media only screen and (min-width: 1024px) {
    background-color: green;
}
\end{verbatim}
\caption{Exemplo de Media Query}
\label{fig:MediaQuery}
\end{figure}

A figura \ref{fig:MediaQuery} demostra a aplicação de uma regra
via seletor Media Query, aplicando a cor de fundo para dispositivos
com no mínimo 1024 pixels de resolução. 


Além das propriedades convencionais, CSS nível 4 permite a
utilização de media queries criadas pelo usuário (\textit{Custom
Media Queries}), com regras e definições customizadas. A figura
\ref{fig:MediaQueryCustom} demostra as novas possibilidades de
definição de media queries tanto em CSS como em JavaScript.

\begin{figure}[H]
\centering
\begin{verbatim}
@custom-media --narrow-window (max-width: 30em);

<script>
CSS.customMedia.set('--foo', 5);
</script>

\end{verbatim}
\caption{Exemplos de media queries customizadas}
\label{fig:MediaQueryCustom}
\source{https://developer.mozilla.org/en-US/docs/Web/CSS/MediaQueries}
\end{figure}

\subsection{Transições}

Transições são uma forma de adicionar animações em uma página
web. Estas animações são compostas por um estado inicial e um final.
A especificação de transições permite grande controle sobre seus
estados, habilitando o desenvolvedor a controlar o tempo de execução,
os estados intermediários, e efeitos aplicados a uma transição.
Para utilizar transições, assim como em uma máquina de estados,
precisamos identificar estados e ações. Estados são seletores do CSS
e ações são modificações realizadas entre esses dois seletores CSS
\textsc{\autocite{html5mostwanted}}.

Transições de CSS são interessantes em jogos, especialmente pois muitos
navegadores suportam aceleração de GPU (Unidade de processamento
gráfico) para estas operações. Isso garante grandes benefícios de
performance sobre implementações diretamente em JavaScript.

Segundo \citet{html5mostwanted}, transições nos permitem construir jogos
degradáveis pois os interpretadores de CSS são amigáveis; se eles
encontrarem propriedades desconhecidas eles simplesmente as ignoram e
continuam a funcionar.

\begin{figure}[H]
\centering
\begin{verbatim}
div {
    width: 100px;
    height: 100px;
    background: red;
    transition: width 2s;
}

div:hover {
    width: 300px;
}

\end{verbatim}
\caption{Exemplo de transição}
\label{fig:CSSTransition}
%\soruce{http://www.w3schools.com/CSS/css3\_transitions.asp}
\end{figure}

A figura \ref{fig:CSSTransition} demostra a utilização de uma
transição de tamanho em uma \textit{div} quando o mouse está sobre o
elemento. No período de 2 segundos a largura da \textit{div} vai de 100
pixels para 300 pixels.

Atualmente um conjunto finito de propriedades podem ser animadas
com transições, e essa lista tende a mudar com o tempo, cabe ao
desenvolvedor assegurar-se que determinada propriedade está disponível
\textsc{\autocite{mdnTransitions}}.

\subsection{Transformações 3D}

Transformações é outra tecnologia do CSS3 que permite grande
flexibilidade na construção de jogos. Transformações permitem que
elementos sejam traduzidos, rotacionados, escalados e distorcidos em um
espaço de duas dimensões \textsc{\autocite{html5mostwanted}}.

A transformação demonstrada na figura \ref{fig:CSSTransform} escala o
tamanho do elemento com a classe (\textit{test}) para vinte porcento a
mais do seu tamanho original. Perceba também os comandos repetidos com
o prefixo ms e WebKit. Esse tipo de abordagem é comum para tecnologias
que não passam de rascunhos na especificação.

Assim como transições, as transformações são muitas vezes aceleradas
via GPU incrementando a performance de animações criadas com a tecnologia.

\begin{figure}[H]
\centering
\begin{verbatim}
<style>
.test:hover
{
        -webkit-transform: scale(1.2);
        -ms-transform: scale(1.2);
        transform: scale(1.2);
}
</style>
\end{verbatim}
\caption{Exemplo de transformação}
\label{fig:CSSTransform}
\end{figure}

\subsection{CSS 4}

Apesar de o termo CSS 4 ser bastante utilizado, o grupo de trabalho do CSS
não considera mais a existência de versões, como foi até o CSS3.
Todavia, existem recursos cuja especificação está avançada e não estavam presentes
no CSS 3 quando este foi lançado, dentre estas funcionalidades inclui-se:

\begin{itemize}
\item Suporte a variáveis no CSS;
\item Media queries customizadas;
\item Funções de cores como: color(), hwb() e gray();
\item Suporte a filtros.
\end{itemize}

Recursos recentes do CSS muitas vezes não estão presentes nos
navegadores. Conquanto, muitos deles são interessantes no contexto de
desenvolvimento de jogos, como o suporte a variáveis. O projeto cssnext
\url{http://cssnext.io/} é uma iniciativa para permitir a utilização
dos recentes recursos do CSS mesmo sem eles estarem implementados nos
navegadores. O projeto funciona compilando o código não suportado em
algo compatível com as versões implementadas pelos navegadores.

Além da apresentação, recurso vital para jogos, e aplicativos Web em
geral, é a interatividade. Com as tecnologias da Web esta interatividade
é atingida através do JavaScript.
%}}}
\section{JavaScript}
%{{{

EMACScript, melhor conhecida como JavaScript, criada por Brendan
Eich em 1992, é a linguagem de script da Web. Devido a tremenda
popularidade na comunidade de desenvolvedores, a linguagem foi
abraçada pela W3C e atualmente é um dos componentes da Open Web. As
definições da linguagem são descritas na especificação ECMA-262.
Esta possibilitou o desenvolvimento de outras implementações além da
original (SpiderMonkey) como o Rhino, V8 e TraceMonkey; bem como outras
linguagens similares como JScript da Microsoft e o ActionScript da
Adobe.

Segundo a \citet{ecmaSpecificaton}:
\begin{quote}
Uma linguagem de script é uma linguagem de programação que é
usada para manipular e automatizar os recursos presentes em um dado
sistema. Nesses sistemas funcionalidades já estão disponíveis
através de uma interface de usuário, uma linguagem de script é
um mecanismo para expor essas funcionalidades para um programa
protocolado.
\end{quote}

No caso de JavaScript na web, os recursos manipuláveis são o conteúdo
da página, elementos HTML, elementos de apresentação, a própria
janela do navegador e o crescente número de outras funcionalidades que
tem seu suporte adicionado por novas especificações.

A intenção original era utilizar o JavaScript para dar suporte aos já
bem estabelecidos recursos do HTML, como para validação, alteração
de estado de elementos, etc. Em outras palavras, a utilização do
JavaScript era opcional e as páginas da Web deveriam continuar
operantes sem a presença da linguagem.

Entretanto, com a construção de projetos Web cada vez mais
complexos, as responsabilidades delegadas ao JavaScript aumentaram a
ponto que a grande maioria dos sistemas Web não funcionarem sem ele.
JavaScript não evoluiu ao passo da demanda e muitas vezes carece de
definições expressivas, completude teórica, e outras características
de linguagens de programação mais bem estabelecidas, como C++ ou
Java \textsc{\autocite{crossPlatformMobileGame}}. A última versão do JavaScript, o
JavaScript 6, é um esforço nessa direção. JavaScript 6 ou EMACScript
Harmonia, contempla vários conceitos de orientação a objetos como
classes, interfaces, herança, tipos, etc. Infelizmente, por hora, o suporte
ao JavaScript 6 é apenas parcial em todos os navegadores. O site
\url{http://kangax.github.io/compat-table/es6/} apresenta um comparativo de
suporte das funcionalidades do JavaScript, inclusive o 6, nos navegadores.

Segundo \citet{ecmaSupport}, o suporte no início de 2015 era o seguinte:

\begin{itemize}
    \item Chrome: 30\%
    \item Firefox: 57\%
    \item Internet Explorer : 15\%
    \item Opera: 30\%
    \item Safari: 19\%
\end{itemize}

Estes esforços de padronização muitas vezes não são rápidos
o suficiente para produtores de software Web. Demora-se muito até
obter-se um consenso sobre quais as funcionalidades desejadas em
determinada versão e seus detalhes técnicos. Além da
espera por especificações, uma vez definidas, é necessário que os
navegadores implementem o especificado.

O projeto babel \url{https://github.com/babel/babel} é um compilador de
JavaScript 6 para JavaScript 5. Permitindo que, mesmo sem suporte, os
desenvolvedores possam usufruir dos benefícios da utilização do
JavaScript 6 durante o tempo de desenvolvimento, gerando código em
JavaScript 5 para rodar nos navegadores.

Alternativamente, existe uma vasta gama de conversores de código
(\textit{transpilers}) para JavaScript; possibilitando programar
em outras linguagens, posteriormente gerando código JavaScript .
Entretanto, essa alternativa tem seus pontos fracos, necessita-se
de mais tempo de depuração, visto que o JavaScript gerado não é
conhecido pelo desenvolvedor, e provavelmente o código gerado não
será tão otimizado, nem utilizará os recursos mais recentes do
JavaScript.

Mesmo com suas fraquezas amplamente conhecidas, JavaScript está
presente em praticamente todo navegador atual. Sendo uma espécie de
denominador comum entre as plataformas. Essa onipresença torna-o
integrante vital no processo de desenvolvimento de jogos multiplataforma
em HTML5. Vários títulos renomeados já foram produzidos que fazem
extensivo uso de JavaScript, são exemplos: Candy Crush Saga, Angry
Birds, Dune II, etc.

Jogos Web são geralmente escritos na arquitetura cliente servidor,
JavaScript pode rodar em ambos estes contextos, para tanto, sua
especificação não define recursos de plataforma. Distribuidores do
JavaScript complementam o JavaScript com recursos específicos para
suas plataformas alvo. Por exemplo, para servidores, define-se objetos como:
terminal, arquivos e dispositivos; no contexto de cliente,
são definidos objetos como: janelas, quadros, DOM, etc.

Para o navegador o código JavaScript geralmente é disposto no elemento
\textit{script} dentro de arquivos HTML. Quando os navegadores encontram esse
elemento eles fazem a requisição para o servidor e injetam o código
retornado no documento e, a não ser que especificado de outra forma,
iniciam sua execução.

\subsection{JavaScript 7}

Antes da finalização da especificação 6, algumas funcionalidades
do JavaScript 7 já haviam sido propostas. Na página
\url{https://github.com/tc39/ecma262} pode-se conferir os itens
propostos e seu estágio de evolução. A figura \ref{fig:ecma7} é
a tabela de funcionalidades sugeridas e seu estágio no processo da
especificação. Alguns dos recursos esperados para o JavaScript 7 são:
guards, contratos e concorrência no laço de eventos \textsc{\autocite{ecma7}}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{ecma7.png}
	\caption{Propostas do ECMA 7}
	\source{https://github.com/tc39/ecma262}
    \label{fig:ecma7}
\end{figure}

\subsection{Asm.js}

Asm.js é um subconjunto da sintaxe do JavaScript a qual permite
grandes benefícios de performance quando em comparação com
JavaScript normal. Entretanto, não é trivial escrever código em
Asm.js e geralmente a criação é feita automaticamente através
da conversão de outras linhagens como C. O projeto Emscripten
\url{https://github.com/kripken/emscripten} pode ser utilizado para gerar
código em Asm.js é utilizado pelo motor de jogos Unity 3D e Unreal.

No contexto dos jogos performance é um fator de extrema importância,
Asm.js se destaca por utilizar recursos que permitam otimizações
antes do tempo (\textit{ahead of time optimizations}). Outra grande
parcela da performance adicional, em relação ao JavaScript, é
devido a consistência de tipo e a não existência de um coletor de
lixo (\textit{garbage collector}); a memória é gerenciada manualmente
através de um grande vetor. Esse modelo simples, desprovido de
comportamento dinâmico, sem alocação e desalocação de memória,
apenas um bem definido conjunto de operações de inteiros e flutuantes,
possibilita grade performance e abre espaço para otimizações.

O desenvolvimento do Asm.js iniciou-se no final de 2013; não obstante,
a maioria dos navegadores não implementam ou implementam parcialmente o
rascunho. O motor JavaScript da Mozilla, SpiderMonkey, é a exceção,
implementando a grande maioria dos recursos do Asm.js.

\subsection{Web Assembly}
%{{{
Web Assembly é uma tecnologia que pretende definir um formato de
máquina da Web. A tecnologia ainda está em seus estágios iniciais de
desenvolvimento, nem contando com um grupo de trabalho. Mesmo assim,
sabe-se que Web Assembly irá permitir que outras linguagens além do
JavaScript gerem código binário que rode nos navegadores com grande
ganhos de performance e flexibilidade.

Além da versão binária, otimizada para performance, uma versão em
texto também está prevista, ideal para desenvolvimento e depuração.
Bibliotecas e aplicações que requeiram grande performance como
motores de física, simulações e jogos em geral vão se beneficiar
substancialmente com o Web Assembly.

A iniciativa do Web Assembly está sendo desenvolvida pelo Google,
Microsoft, Mozilla, entre outros, tornando a proposta uma possibilidade
promissora. Seu objetivo não é substituir o JavaScript, outrossim
habilitar que aplicações que necessitem de grande performance possam
ser inclusas na Web. A ideia do Web Assembly é uma continuação
do trabalho do Asm.js, uma forma de trazer performance similar a
nativa eliminando grande parte das abstrações que o JavaScript
traz embutidas.

Visto que os desenvolvedores de motores JavaScript terão que colocar
o código do Web Assembly na mesma base que o do JavaScript, as
expectativas são de que o JavaScript consiga aproveitar partes
da implementação do Web Assembly incrementando a performance do
JavaScript, sendo assim uma situação onde ambos ganham.

A aplicabilidade do Web Assembly em jogos em produção ainda
é praticamente nula. Até então apenas um polyfill do Web
Assembly está disponível e pode ser encontrado no seguinte link
https://github.com/Web\_Assembly/polyfill-prototype-1. Mas conforme a
especificação evolui a probabilidade é que as empresas interessadas
implementem a especificação em seus navegadores e os desenvolvedores
de jogos comecem a integrar a tecnologia em suas aplicações.

%}}}
\subsection{Web Animations}
%{{{

Web Animations é uma especificação em rascunho que define uma forma
imperativa de manipular animações através de JavaScript. Como
demonstrado na figura \ref{fig:webAnimations} a tecnologia vai permitir
manipular as animações de elementos do DOM, com a possibilidade
de filtrar por tipo de animação, alterar a taxa de animações, o
tempo de execução, entre outras propriedades de uma forma dinâmica,
através de scripts. Visto que Web Animations lida diretamente com o
DOM, animações podem ser aplicadas para SVG além de CSS, servindo
como uma tecnologia para unificar animações.

Grande controle sobre animações é desejável para os
jogos; não obstante, visto que a especificação é muito
nova, somente o Google Chrome a implementa. A biblioteca
\url{https://github.com/web-animations/web-animations-js} serve como
polyfill para os demais navegadores.

\begin{figure}[H]
    \centering
    \begin{verbatim}
elem.getAnimations().filter(
  animation =>
    animation.effect instanceof 
    KeyframeEffectReadOnly &&
    animation.effect.getFrames().some(
      frame => frame.hasOwnProperty('transform')
    )
).forEach(animation => {
  animation.currentTime = 0;
  animation.playbackRate = 0.5;
});
    \end{verbatim}
	\caption{Exemplo de utilização de Web Animatios}
	\source{http://www.w3.org/TR/Web-animations/}
    \label{fig:webAnimations}
\end{figure}

O site \url{http://web-animations.github.io/web-animations-demos/} contém uma
coleção de animações utilizando a tecnologia.

%}}}
%}}}
\section{Navegadores}
%{{{
Navegadores são aplicações, onde as tecnologias da OWP são
interpretadas e geram um conteúdo útil para os usuários. São
os clientes em uma arquitetura cliente servidor. O servidor desta
arquitetura geralmente é um servidor Web cujo objetivo principal é
fornecer páginas HTML para o navegador processar. A comunicação entre
o navegador e o servidor Web se dá através da troca de mensagens no
protocolo HTTP.

Nos navegadores, os usuários necessitam saber o endereço de determinado
servidor, ou utilizar buscadores para auxiliá-los. Este é um processo
árduo para as plataformas móveis pois necessitam maior interação
dos usuários, e não são “naturais” se comparado ao modo de
consumir aplicativos nestas mesmas plataformas. Simplesmente adquirindo
o aplicativo na loja e abrindo-o no sistema operacional\footnote{Algumas
formas de contornar este problema serão descritos nas seção
\ref{disponibilization}.}.

Uma vez localizado o endereço, o navegador manda uma mensagem em HTTP
requisitando o conteúdo de determinado local. O servidor responde a
mensagem HTTP com um documento HTML e o cliente, ao receber, começa o
processo de renderização. O processo de renderização é complexo e a
grande maioria dos navegadores confia em bibliotecas especializadas para
efetuar este trabalho, estas bibliotecas são denominadas motores de renderização.

Alguns motores de renderização incluem:

\begin{itemize}
    \item Blink: Utilizado no Opera, Google Chrome e projetos relacionados;
    \item Gecko: Utilizado nos produtos da Mozilla;
    \item KHTML: Utilizado no navegador Konkeror, esta serviu de base para o Blink;
    \item WebKit: Utilizado no Safari e versões antigas do Google Chrome.
\end{itemize}

A renderização consiste na decodificação de um documento em HTML
para sua representação na memória e posterior pintura no espaço de tela
do navegador. Interpretar os documentos é processo árduo e alguns
motores dependem de bibliotecas externas para fazê-lo. 

Para interpretar HTML o motor WebKit utiliza a biblioteca Bison, já
o Gecko utiliza uma biblioteca própria \textsc{\autocite{howBrowsersWork}}.
Durante o processo de renderização o navegador pode requisitar outros
arquivos do servidor a fim de completar a experiência desejada para o
documento em questão. Geralmente após a renderização do documento
vem a execução de scripts. As bibliotecas que executam JavaScript são
chamadas de motores de JavaScript. Abaixo segue uma lista dos motores de
JavaScript mais comuns.

\begin{itemize}
    \item SpiderMonkey: Primeiro motor, desenvolvido por Brendan Eich, escrito em C++;
    \item Rhino: Criada pela Netscape, escrito em Java;
    \item Nitro: Criada pela Apple;
    \item V8: Criada pelo Google;
    \item TraceMonkey: Criada pela Mozilla.
\end{itemize}

Cada um dos motores citados acima são partes que compõem um
navegador e em conjunto buscam cobrir as especificações da Web.
Infelizmente a forma que as tecnologias são suportadas varia e algumas
não estão presentes de qualquer forma nos navegadores. Conquanto,
o suporte vem crescendo. A figura \ref{fig:audioCodecs} apresenta o
gráfico de suporte por versões de navegadores em dezembro de 2015.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{htmlSupport.png}
	\caption{Suporte das especificações do HTML nos navegadores}
    \label{fig:htmlSupport}
    \source{\url{https://html5test.com/}}
\end{figure}

%}}}
\section{Android}
%{{{

É um sistema operacional open-source criado em 2003 pela Android
Inc e mantido pelo Google desde 2005. Android funciona em uma
variedade de dispositivos de celulares, tablets, netbooks a
computadores desktop, mas seu foco é dispositivos com tela sensível
\textsc{\autocite{chromeVsAndroid}}. O sistema operacional é composto por
diversos projetos open-source, sendo o mais proeminente deles o kernel
Linux, utilizado como fundamento do sistema operacional. Além
da versão open-source (AOSP), existe a versão do Google que utiliza
ferramentas proprietárias  para adicionar funcionalidades aos dispositivos.

Softwares para Android são geralmente escritos em Java e executados
através da máquina virtual Dalvik. Dalvik é similar a máquina
virtual Java, mas roda um formato de arquivo diferenciado (.dex),
otimizados para consumir pouca memória, que são agrupados em um único
pacote (.apk).

Aplicativos da Web podem ser integrados no Android através de uma
arquitetura híbrida. Os arquivos da aplicação são empacotados dentro
de um apk utilizando um componente nativo do Android, a API WebView, que
se responsabiliza por interpretá-los.

Além da arquitetura híbrida, é possível executar jogos Web em
dispositivos Android através dos navegadores presentes nestes
aparelhos. As novas versões do Android contam com o Google Chrome como
navegador padrão. Já a versões antigas contém um navegador próprio
que utiliza o motor de renderização LibWebCore, baseado no WebKit
\textsc{\autocite{comparisonPlatforms}}. Além do padrão, outros navegadores
como o Firefox ou Opera também podem ser instalados.

Além do Android o sistema IOS é de grande relevância
para o desenvolvimento de jogos. Entretanto, não será tratado neste
trabalho pelos motivos supracitados. A próxima seção deste trabalho
descreve como detectar recursos nas variadas plataformas que a Web se
apresenta.

%}}}
\section{Detecção de Recursos}
%{{{
Visto que nenhum navegador implementa as especificações HTML
completamente, cabe ao desenvolvedor detectar os navegadores que não
comportam as necessidades tecnológicas dos aplicativos que cria. Ao
deparar-se com uma funcionalidade faltante o desenvolvedor tem duas
possibilidades: notificar o usuário sobre o problema ou utilizar
polyfills.

Polyfills são recursos que simulam uma funcionalidade não
disponível nativamente nos navegadores. A biblioteca Gears
\url{https://developers.google.com/gears} é um exemplo. Gears
serve para prover recursos de Geolocalização para navegadores que
não implementam a especificação do HTML5. Essa capacidade de
suportar tecnologias que não estão ainda disponíveis (ou nunca
estarão no caso de dispositivos legados) através de polyfills é
uma das características que faz a Web uma plataforma de tão grande
abrangência. Novas tecnologias são criadas a todo o momento;
entretanto, o suporte a essas funcionalidades geralmente não
acompanham o passo das inovações. E ainda assim os usuários podem
se beneficiar de uma taxa substancial delas através de polyfills.
Algumas funcionalidades do HTML, como geolocalização e vídeo
foram primeiramente disponibilizadas através de plugins. Outras
funcionalidades, como o canvas, podem ser totalmente emuladas via
polyfills em JavaScript \textsc{\autocite{diveIntohtml}}.

Detectar suporte aos variados recursos do HTML5 no navegador
pode ser uma tarefa entediante. É possível implementar testes para
cada funcionalidade utilizada abordando os detalhes de implementação
de cada uma ou então fazer uso de alguma biblioteca especializada
neste processo. O Modernizr é uma opção open-source deste tipo de
biblioteca, este gera uma lista de booleanos sobre grande variedade dos
recursos HTML5, dentre estes, geolocalização, canvas, áudio, vídeo e
armazenamento local.

A quantidade de especificações que um aplicativo complexo
como um jogo utiliza pode ser bem grande, e muitas vezes é
difícil dizer quais navegadores implementam o quê. Uma
boa referência do suporte a recursos nos navegadores é o site
\url{http://caniuse.com/}. E uma lista com vasta quantidade de
polyfills para as tecnologias da Web pode ser encontrada no site
\url{https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Pol
yfills}.

%}}}
\section{Renderização}
Renderização é parte fundamental de muitos jogos. As tecnologias que
permitem renderização na Web serão descritas abaixo.
\subsection{SVG}
%{{{
SVG (\textit{Gráficos de vetores escaláveis}), é uma linguagem
baseada em XML especializada na criação de vetores bidimensionais
\textsc{\autocite{html5mostwanted}. Segundo \citet[p. 4]{svgTime}} SVG foi criada
em conjunto por empresas como: Adobe, Apple, AutoDesk, entre outas,
sendo que seus produtos contam com rápida integração a tecnologia.

Por descrever imagens utilizando vetores ao invés de mapas de bits,
os tamanhos dos arquivos em SVG são geralmente pequenos e podem
ser comprimidos com grande eficiência. Talvez a característica mais
marcante do SVG é que não há diferença de qualidade em resoluções
visto que os vetores são escaláveis. Sendo que pequenos arquivos
servem igualmente bem um monitor com baixa resolução como um monitor
retina.

Por ser baseado em XML, uma das tecnologias da Web, SVG permite a
utilização da API do DOM para manipular seus elementos. Tornando
simples a integração com outras tecnologias da Web. Pode-se utilizar
arquivos CSS para customizar a apresentação, JavaScript para adicionar
interatividade, etc.

Além de grande integração com as demais tecnologias, SVG conta com
uma API nativa poderosa. Os elementos geométricos do SVG incluem
retângulos, círculos, elipses, linhas e polígonos \autocite[p.
5]{svgTime}. Também existe a possibilidade de declarar caminhos
customizados através do elemento \textit{path}, algo similar com o
\textit{Path2D} do Canvas. E cada um dos elementos, ou agrupamento
de elementos podem ser transformados; traduzidos, redimensionados,
rotacionados e distorcidos \textsc{\autocite[p. 5]{svgTime}}. Para ilustrar a
utilização, a figura \ref{fig:svgCircle} demonstra um círculo sendo
definido em SVG.

\begin{figure}[H]
\centering
\begin{verbatim}

<svg width="100" height="100">
  <circle 
    cx="50" 
    cy="50" 
    r="40" 
    stroke="green" 
    stroke-width="4" 
    fill="yellow" 
  />
</svg>

\end{verbatim}
\caption{Círculo em SVG.}
\source{http://www.w3schools.com/svg/}
\label{fig:svgCircle}
\end{figure}

Outra tecnologia popular da Web para renderização que adota uma filosofia totalmente 
diferente do SVG é o Canvas.
%}}}
\subsection{Canvas}
%%{{{
O elemento \textit{canvas} define uma camada de mapa de bits em
documentos HTML que pode ser usada para criar diagramas, gráficos e
animações 2D. Foi criado pela Apple em 2004 para renderizar elementos
de interface no Webkit, logo foi adotado por outros navegadores e se
tornou um padrão da OWP.

Em um documento HTML, canvas é um retângulo onde pode-se usar
JavaScript para desenhar \textsc{\autocite[p. 113]{diveIntohtml}}. Mais
especificamente, o retângulo do canvas é um espaço vetorial cuja
origem se dá na esquerda superior. Normalmente cada unidade do plano
cartesiano corresponde a um pixel no canvas \textsc{\autocite{mdnCanvas}}.
Manipular o retângulo é uma analogia de como desenhar manualmente,
move-se o \textquotedbl lápis\textquotedbl{} para o local desejado e traça-se os pontos onde
a linha (caminho) deve percorrer. Além da possibilidade de desenhar
linhas livremente também é possível criar retângulos nativamente.
Todas as demais figuras geométricas precisam ser feitas através da
junção de caminhos \textsc{\autocite{mdnCanvas}}. Para desenhar caminhos
curvos, de modo a criar círculos e elipses, existem funções especiais
de arco.

Escrever no canvas envolve a manipulação de diversos caminhos e
retângulos, em jogos que fazem extensivo uso do canvas a complexidade
de manipulação de linhas pode crescer muito. As últimas versões do
Canvas introduziram o objeto Path2D que possibilita o armazenamento e
composição de instruções de caminhos a fim de possibilitar o reuso
de formas. Ao invés de utilizar os métodos de caminhos diretamente no
contexto do canvas utiliza-se uma instância do objeto \textit{Path2D}.
Todos os métodos relacionados aos caminhos como o \textit{moveTo},
\textit{arc} ou \textit{quadraticCurveTo} estão disponíveis no
objeto Path2D \textsc{\autocite{mdnCanvas}}. Também é possível utilizar a
notação do SVG na criação de uma instancia de Path2D possibilitando
a reutilização de conteúdo para ambas as tecnologias.

Além da possibilidade de desenhar programaticamente é possível
carregar gráficos. Muitos dos jogos HTML5 utilizam sprites ou padrões
recortáveis \textit{tiled}, técnicas bastante similares aos títulos antigos da
SNES e Game Boy \textsc{\autocite{buildingHtml5Game}}.

Apesar da API do canvas ser poderosa não é possível manipular
diretamente as camadas já desenhadas. Alternativamente pode-se limpar
o canvas inteiramente em pontos determinados ou então sobrescrever as
partes que se deseja alterar.

\begin{figure}[H]
\centering
\begin{verbatim}

var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
ctx.fillStyle = "#FF0000";
ctx.fillRect(0,0,150,75);

\end{verbatim}
\caption{Canvas}
\source{http://www.w3schools.com/html/html5\_canvas.asp}
\label{img:retangleOnCanvas}
\end{figure}

A figura \ref{img:retangleOnCanvas} demonstra a utilização do canvas 2D
para a criação de um retângulo. Note que o objeto canvas tem que carregar um
contexto que então é utilizado como API para manipular a mapa de bits em 2D.

O canvas até aqui descrito trata-se de sua forma, ou contexto 2D. A
especificação 3D do canvas é o WebGl .

%}}}
\subsection{WebGL}
%{{{

WebGL é uma API JavaScript otimizada para desenhar gráficos em três
dimensões. Ideal para a criação de ambientes virtuais, jogos e
simulações. Por ser uma tecnologia da OWP WebGL foi especificado
para funcionar nativamente nos navegadores sem a ajuda de plugins ou
ferramentas de terceiros.

WebGL foi desenvolvida baseando-se na especificação OpenGL a
qual trata de definir como renderizar gráficos multiplataforma.
Especificamente OpenGL ES, é uma versão do OpenGL otimizada para
dispositivos móveis. O órgão que especifica o WebGL é o mesmo que
especifica o OpenGL, o grupo sem fins lucrativos Kronos. Os primeiros
rascunhos do WebGL iniciaram em 2006; não obstante, o grupo de trabalho
não foi formado até 2009 e a primeira versão foi lançada em 2011.

Apesar de ter sido desenvolvida com foco em 3D, WebGL pode
ser igualmente utilizada para criação de gráficos em duas
dimensões\textsc{\autocite[p. 6]{3daps}}. O elemento do DOM que provê a
interface do WebGL é o canvas, no contexto 3D. Essa integração com
o DOM via tag canvas permite que o WebGL seja manipulado assim como os
demais elementos HTML. A especificação é composta por uma API de
controle em JavaScript e o processamento shaders do lado da GPU (Central
de processamento gráfico).

Shaders são scripts que definem níveis de cor ou efeitos especiais
sobre um modelo 2D ou 3D. Contam com grande performance, possibilitando
conteúdo em tempo real como no caso de jogos. São utilizados no
cinema, em imagens geradas por computadores e videogames.

Existem dois shaders principais, de vértices e fragmentos. Shaders de
vértices são chamados para cada vértice sendo desenhado definindo
suas posições definitivas. Já shaders de fragmentos atuam na cor de
cada pixel a ser desenhado \textsc{\autocite[p.15]{3daps}}.

\citet{html5mostwanted} cita que conforme a habilidade do desenvolvedor
aumenta, mover funções antes delegadas ao JavaScript para os shaders
pode aumentar a performance e oferecer uma ampla coleção de efeitos e
realismo.

Um endereço interessante para explorar exemplos WebGL do iniciante ao avançado é o blog
 \url{learningwebgl.com} que conta com tutoriais cobrindo áreas
como diferentes tipos de iluminação, carregamento de modelos em JSON,
gerenciando eventos; e como renderizar uma cena WebGL
em uma textura \textsc{\autocite[p.42]{3daps}}\footnote{Os apêndices contam
com uma coleção de bibliotecas que facilitam a utilização de WebGL}.

Apesar da relevância, WebGL não foi utilizado no protótipo pois
ainda não está completamente suportado em navegadores populares como
o Firefox e a grande curva de aprendizado do WebGL puro é muito grande
para se encaixar no escopo deste projeto.

Uma tecnologia que se integra profundamente como ambientes virtuais
em três dimensões criados via WebGL é o WebVR.
%}}}
\subsection{WebVR}
%{{{ 
Segundo \citet{virtualReality} realidade virtual é uma experiência em
que o usuário é efetivamente imerso em um mundo virtual responsivo.
Realidade virtual é uma área nem tão nova mas que recebeu interesse
renovado recentemente. Isso se dá, pelo menos em parte, pela
massificação dos dispositivos móveis inteligentes. O hardware
necessário para fornecer uma experiência minimamente viável como
acelerômetros, câmeras e telas de alta resolução está disponível
em praticamente todos os dispositivos comercializados.

Realidade virtual é uma área de grande interesse para os produtores de
jogos, pois pode oferecer alto nível de imersão nos já interativos
e desafiadores ambientes dos jogos. WebVR é uma especificação que
pretende trazer os benefícios da realidade virtual para dentro do mundo
da Web. Em termos simples, a especificação define uma forma de traduzir
movimentos de acelerômetros e outros sensores de posição e movimento
para dentro do contexto de uma câmera em um ambiente 3D WebGL.

Atualmente a especificação do WebVR se encontra em fase de rascunho e
as últimas versões do Firefox, e versões compiladas manualmente do
Google Chrome já permitem a utilização.
%}}}
\section{WebCL}
%{{{
É uma API em JavaScript para o recursos de OpenCL que permitem
computação paralela com grandes ganhos de performance. Aplicativos
como motores de física e renderizadores de imagens, ambos relevantes
para os jogos, podem se beneficiar grandemente de processamento feito
em paralelo, possivelmente na GPU. OpenCL é um framework para escrever
programas que funcionem em plataformas com diversas unidades de
processamento. Assim como WebGL a WebCL é especificada e desenvolvida
pelo grupo Kronos. A primeira versão da especificação foi no início
de 2014 mas até então nenhum navegador implementa o definido.
%}}}

Após a revisão de tecnologias de renderização serão abordadas
tecnologias de multimídia: áudio e vídeo. Mas para falar de ambos,
antes é necessário falar de codecs.

\section{Codecs}
%{{{

Codec é o algoritmo usado para codificar e decodificar vídeo ou
áudio em um conjunto de bits \textsc{\autocite{diveIntohtml}}. O termo Codec é
um acrônimo, significando o processo de codificar (\textit{coder}) um fluxo de dados
para armazenamento e decodificá-lo (\textit{decoder}) para ser consumido.

Dados multimídia são geralmente enormes, sem serem codificados,
um vídeo ou áudio consistiriam em uma vasta quantidade de dados
que seriam muito grandes para serem transmitidos pela Internet em um
período de tempo razoável \textsc{\autocite[p. 66]{proHtml5}}. O objetivo dos
codecs é diminuir o tamanho dos arquivos com a menor perda de qualidade
possível. Para isso os codecs utilizam de várias estratégias de
compressão ou descarte de dados; podendo rodar tanto em hardware quanto
em software.

Existem codecs desenvolvidos especificamente para a Web. Buscam
uma razão de tamanho e qualidade aceitável, mas prezando por
tamanho. Uma das otimizações realizadas por codecs de vídeo na
Web, é a não troca de todo conteúdo de um quadro para o próximo,
possibilitando maiores taxas de compressão, que resulta em arquivos
menores \textsc{\autocite{diveIntohtml}}.

O funcionamento de codecs pode variar muito, conforme as estratégias
de compressão utilizadas, a quantidade de bits por segundo suportada,
entre outros fatores. Visto que os algoritmos de compressão podem
adquirir grande complexidade muitos codecs são encobertos por licenças
que limitam sua utilização. Embora, também existem opções
livres de patentes e licenças.

Abaixo segue uma lista de alguns codecs populares para áudio segundo
\citet[p. 67]{proHtml5}.

\begin{itemize}
    \item ACC;
    \item MPEG-3;
    \item Vorbis.
\end{itemize}

Ainda segundo \citet[p. 67]{proHtml5} abaixo segue uma lista de codecs populares para vídeo.
\begin{itemize}
    \item H.264;
    \item VP8;
    \item OggTheora.
\end{itemize}

Após um fluxo de dados multimídia ter sido codificado através do
algoritmo de codec ele é armazenado em um contêiner. Contêiners
são um padrão de metadados sobre as informações codificadas
de modo a possibilitar que outros programas consigam interpretar
estas informações de forma padronizada. Como um arquivo
\textit{zip}, contêiners podem conter qualquer coisa dentro de si
\textsc{\autocite{diveIntohtml}}. Assim como codecs, existem contêiners livres e
com restrições de licença.

\noindent Abaixo segue uma lista de alguns contêiners de áudio.
\begin{itemize}
    \item Audio Video Interleave (.avi);
    \item MPEG-2 Audio Layer III (.mp3);
    \item Matroska (.mkv);
    \item Vorbis (.ogg);
    \item Opus (.opus).
\end{itemize}

\noindent Abaixo segue uma lista de alguns contêiners de vídeo.
\begin{itemize}
    \item Audio Video Interleave (.avi);
    \item Flash Video (.flv);
    \item MPEG4 (.mp4);
    \item Matroska (.mkv);
    \item Ogg (.ogv);
    \item WebM (.webm).
\end{itemize}

O suporte a codecs e contêiners na Web varia de navegador para
navegador, de acordo com as preferências mercadológicas, técnicas
ou filosofias das empresas por trás dos navegadores. Segundo
\citet{diveIntohtml} não existe uma única combinação de contêiner
e codecs que funcione em todos os navegadores \footnote{A figura
\ref{fig:audioCodecs} apresenta um comparativo interessante sobre
os formatos populares de áudio considerando o fator taxa de bits
(quantidade de informação armazenável por segundo) versus qualidade
(perceptível por humanos).}.

%}}}
\section{Áudio}
%{{{

Áudio é um componente vital para oferecer imersão e feedback aos
usuários de jogos. O componente de áudio é especialmente útil para
jogos de ação \textsc{\autocite{browserGamesTechnologyAndFuture}}. Efeitos
de som e música podem servir como parte da mecânica dos jogos.

Antes do HTML5 não havia como consumir áudio na Web sem a utilização de
plugins de terceiros. A especificação do HTML define duas formas de
utilizar utilizar áudio na Web: através do elemento HTML áudio ou
através da API JavaScript de áudio.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{codec.png}
	\caption{Comparação de codecs de áudio}
    \label{fig:audioCodecs}
    \source{https://www.opus-codec.org/comparison/}
\end{figure}

\subsection{Elemento Áudio}

O elemento \textit{audio} foi a primeira tecnologia de áudio nativa
para Web, ele define um som dentro de um documento HTML. Quando o
elemento é renderizado pelos navegadores, ele carrega o conteúdo que
pode ser reproduzido pelo programa dentro do navegador.

\begin{figure}[H]
\centering
\begin{verbatim}
<audio controls>
<source src="horse.ogg" type="audio/ogg">
<source src="horse.mp3" type="audio/mpeg">
Your browser does not support the audio element.
</audio>
\end{verbatim}
\caption{Exemplo de utilização da tag áudio}
\label{fig:htmlAudio}
\source{http://www.w3schools.com/HTML/HTML5\_audio.asp}
\end{figure}

A imagem \ref{fig:htmlAudio} demonstra a utilização da tag
\textit{audio}. Os elementos \textit{source} demonstrados na figura
referenciam arquivos de áudio contendo um par de contêiner
e codec. Mais de um \textit{source } é necessário pois os
criadores de navegadores não chegaram a um consenso sobre qual
formato deve ser usado, sendo necessário utilizar vários para
suportar todos os navegadores populares \footnote{Com o site
\url{http://hpr.dogphilosophy.net/test/} é possível detectar os
formatos de codecs de áudio suportados pelo navegador sendo utilizado}.

A especificação declara que todo o conteúdo dentro de uma tag
\textit{audio}, que não sejam elementos \textit{source}, seja
ignorado pelo navegador. O que permite que seja adicionada marcação
de reserva para tratar os casos de quando não existe suporte a tag
\textit{audio} no navegador. Visto que os navegadores que não suportam
áudio vão buscar renderizar o conteúdo dentro da tag. A figura
\ref{fig:htmlAudio} ilustra este comportamento através da mensagem
\textit{Your browser does not support the audio element } que só
será apresentada se o navegador do usuário não tiver suporte a tag
\textit{audio}.

O objetivo inicial da tag \textit{audio} é reproduzir um som e parar.
Ideal para ouvir música ou como um som de fundo de um site. Por
conseguinte, a tag \textit{audio} não é o suficiente para comportar
aplicações de áudio complexas \textsc{\autocite{audioApiSpec}}. A grande
maioria de jogos muitas vezes precisam lançar múltiplos sons derivados
de ações de usuário e outros eventos, nestes casos a API de áudio é
mais adequada.

\subsection{API de Áudio}

É uma interface experimental (ainda em rascunho) em JavaScript para
criar e processar áudio. O objetivo da especificação é incluir
capacidades encontradas em motores de jogos modernos e também permitir
o processamento, mistura e filtragem de som, funcionalidades que estão
presentes nas aplicações de processamento de áudio modernas para
desktop \textsc{\autocite{audioApiSpec}}.

A API especificada provê uma interface para manipular nodos de áudio
que podem ser conectados permitindo refinado controle sobre os efeitos
sonoros. O processamento se dará primeiramente em uma camada inferior
(tipicamente código Assembly / C / C++), mas a síntese e processamento
em JavaScript também serão suportadas \textsc{\autocite{audioApiSpec}}.

Essa tecnologia é muito mais nova do que o elemento \textit{audio}.
Diferentemente dos demais navegadores o Internet Explorer não
dá nenhum nível de suporte a API. O polyfill AudioContext
suporta as partes básicas da API e pode ser utilizado nos
casos onde não existe suporte para a API do HTML \footnote{O
polyfill AudioContext pode ser encontrado no seguinte endereço
\url{https://github.com/shinnn/AudioContext-Polyfill}}.

As últimas versões da especificação da Audio API contam com a
possibilidade de manipular áudio através de Web Workers, o
que traz oportunidades interessantes para aplicações que dependam de
muito processamento de áudio, visto que o processamento pode ser
feito em uma \textit{thread} separada.

Além de grande flexibilidade com áudio alguns jogos requerem a
disponibilidade de vídeo para utilizar como introdução, cinemáticas,
entre outros recursos que habilitam uma experiência mais rica ao
usuário. Abaixo será feita uma revisão sobre a tecnologia de vídeo
em HTML.

%}}}
\section{Vídeo}
%{{{

O elemento \textit{video} define uma forma de adicionar vídeos na
Web nativamente, sem a necessidade de utilizar plugins de terceiros
como o Flash Player. Assim como com o elemento \textit{audio} pode-se
adicionar um arquivo através do atributo \textit{src} do elemento
ou adicionar vários formatos de contêiner e codec dentro da tag
através de elementos \textit{source}. O navegador decidirá em tempo de
execução qual formato executar dependendo de suas capacidades.

\begin{figure}[H]
\centering
\begin{verbatim}
<video controls style="width:640px;height:360px;" poster="poster.png">
  <source src="devstories.webm" 
          type='video/webm;codecs="vp8, vorbis"' />
  <source src="devstories.mp4" 
          type='video/mp4;codecs="avc1.42E01E, mp4a.40.2"' />
  <track src="devstories-en.vtt" label="English subtitles" 
         kind="subtitles" srclang="en" default></track>
</video>
\end{verbatim}
\caption{Exemplo de utilização de vídeo}
\source{http://www.html5rocks.com/en/tutorials/video/basics/}
\label{fig:video}
\end{figure}

A figura \ref{fig:video} demonstra a utilização de algumas
funcionalidades do elemento \textit{video}. Como demonstrado na figura,
além do elemento \textit{source}, a tag \textit{video} suporta o
elemento \textit{track}. O qual permite informar subtítulos para os
vídeos sendo apresentados. Também é possível habilitar controles de
vídeo nativos dos navegadores, como demonstrado através do atributo
\textit{controls}.

Como o elemento vídeo se encontra no HTML é possível manipulá-lo com
uma gama de tecnologias. Com CSS é possível aplicar escala de cinza do
sobre o elemento vídeo gerando um efeito preto e branco interessante.
A especificação do elemento \textit{video} também permite controlar
quais partes do vídeo serão mostradas através de parâmetros de tempo
passados como argumentos junto ao nome do arquivo. Ou capturar 
frames de vídeo dentro do elemento canvas.

Além de ser flexível nas tecnologias de multimídia, um
requerimento comum em jogos é haver uma forma de armazenar dados
eficientemente e buscá-los com agilidade. Abaixo serão discutidas as
tecnologias de armazenamento disponíveis para a Web.
%}}}
\section{Armazenamento}
%{{{
Uma das grades limitações do HTML era a ausência de capacidade de
armazenamento de dados no lado do cliente. Antes do HTML5 a única
alternativa era usar cookies, os quais tem um armazenamento de no
máximo 4k e trafegam em toda a requisição, tornando o processo lento.
Essa área era ode as aplicações nativas detinham grande vantagem
sobre as aplicações Web. O HTML5 solucionou este problema introduzindo
várias formas de armazenamento de dados \textsc{\autocite{html5Tradeoffs}}.
Armazenamento local é um recurso importante para jogos, tanto por
diminuir a latência da persistência na rede, quanto para possibilitar
um experiência offline.

Existem algumas especificações sobre armazenamento, mas a grande
parte delas não conta com suporte completo em todos os navegadores
comuns, um polyfill interessante para Web Storage  e IndexedDB é o
projeto localForge \textit{https://github.com/mozilla/localForage} da
Mozilla.

\subsection{Web SQL}

A especificação Web SQL introduz uma API para manipular banco de
dados relacionais em SQL. A especificação suporta transações,
operações assíncronas e um tamanho de armazenamento substancial: 5
MB, o qual pode ser estendido pelo usuário. O grupo de trabalho do Web
SQL iniciou-se em 2010 e foi suspenso ainda como rascunho. Apesar de
ser um recurso desejável para muitos desenvolvedores, foi descontinuada
pelos motivos descritos abaixo.

Segundo \citet{diveIntohtml}
\begin{quote}
Todos os implementadores interessados em Web SQL utilizaram a mesma
tecnologia (Sqlite), mas para a padronização ficar completa é
necessário múltiplas implementações. Até outro implementador se
interessar em desenvolver a especificação a descrição do dialeto SQL
apenas referencia o SQLITE, o que não é aceitável para um padrão.
\end{quote}

Entretanto, a especificação ainda é suportada pelo Google
Chrome, Safari, Opera e Android, entre outros. Mas até que outros
implementadores se prontifiquem a especificação continuará suspensa.
No lugar do Web SQL a W3C recomenda a utilização do Web Storage e do
IndexedDB.

\subsection{Web Storage}

Web Storage, também conhecido como Local Storage, provê uma forma
de armazenar dados no formato chave-valor dentro do navegador. Os
dados são persistidos mesmo que o usuário feche a página ou o
navegador. Web Storage é um recurso similar a cookies, contudo algumas
diferenças substanciais são perceptíveis. Web Storage não requer que
os dados sejam trafegados como cabeçalhos nas requisições. Também
provê maiores espaços de armazenamento quando comparado a cookies. A
tecnologia começou como parte da especificação do HTML5 mas agora
conta com um documento próprio mantido pela W3C. A especificação é
suportada pela grande maioria dos navegadores populares.

A especificação oferece duas áreas de armazenamento, o armazenamento
local e de sessão. O armazenamento local é persistido por domínio
e outros scripts provindos deste mesmo domínio poderão fazer uso da
informação. O armazenamento de sessão é para informações que podem
variar de aba para aba e que não é interessante que sejam persistidos
para demais acessos além do atual.


\begin{figure}[H]
\centering
\begin{verbatim}
// Store value on browser for duration of the session
sessionStorage.setItem('key', 'value');

// Retrieve value (gets deleted when browser is closed and re-opened)
alert(sessionStorage.getItem('key'));

// Store value on the browser beyond the duration of the session
localStorage.setItem('key', 'value');

// Retrieve value (persists even after closing and re-opening the browser)
alert(localStorage.getItem('key'));

\end{verbatim}
\caption{Web Storage na prática}
\label{fig:WebStorage}
\source{https://en.wikipedia.org/wiki/Web\_storage\#usage}
\end{figure}

A API do Web Storage é simples, consistindo em uma interface
para buscar dados e outra para armazenar, no formato chave/valor.
A figura \ref{fig:WebStorage} exemplifica a utilização do Web
Storage, para realizar o armazenamento em sessão utiliza-se o objeto
\textit{sessionStorage}. Já para utilizar o armazenamento local
utiliza-se o objeto \textit{localStorage}.

Web Storage é uma solução simples que comporta muitos casos de uso.
Contudo, muitas vezes é necessário um controle mais refinado
sobre os dados, ou mais performance em uma base de dados massiva. Para
responder a estes desafios existe a especificação do IndexedDB.

\subsection{IndexedDB}
%{{{
IndexedDB é um banco de dados que suporta o armazenamento de grandes
quantidades de dados no formato de chave/valor o qual  permite alta
performance em buscas baseadas em índices. A tecnologia é uma recomendação
da W3C desde janeiro de 2015 e suportada, pelo menos parcialmente, por
praticamente todos os navegadores populares.

Inicialmente IndexedDB permitia operações síncronas e assíncronas.
Todavia, a versão síncrona foi removida devido a falta de
interesse da comunidade. Operações assíncronas permitem que
aplicativos JavaScript não esperam pelo resultado para continuar a
execução. Outrossim, cada interação com o banco de dados é uma
transação que pode retornar um resultado ou um erro. Os eventos da
transação são internamente eventos DOM cuja propriedade \textit{type}
do elemento foi definida como \textit{success} ou \textit{error}.

Ao invés de tabelas, IndexedDB trabalha com repositórios de objetos.
Cada entrada, tupla em SQL, de um determinado repositório pode ser de
um formato diferenciado, com exceção da chave única que deve estar
presente em cada uma das entradas.

\begin{figure}[H]
\centering
\begin{verbatim}
	var db;
	var request = window.indexedDB.open("Mydb", 9);
	request.onsuccess = function(event) {
		db = event.target.result;
		var transaction = db.transaction(["customers"], "readwrite");
		var objectStore = transaction.objectStore("customers");
		var request = objectStore.add({email: "mymail@domain.com", name: "foo"});
		request.onsuccess = function(event) {
			console.log('customer added')
		};
	}
\end{verbatim}
\caption{Adicionando um cliente em IndexedDB.}
\label{fig:IndexedDB}
\end{figure}

A figura \ref{fig:IndexedDB} demonstra um exemplo simplificado da
utilização do IndexedDB. Na figura fica visível como cada interação
com o banco de dados é construído através de uma nova requisição e
como o tratamento do resultado é dado dentro de eventos.

%}}}

A característica assíncrona do IndexedDB, é fundamentada na
premissa de não perturbar o fluxo principal da aplicação enquanto
processamento não vital, e possivelmente demorado, ocorre. Outra
tecnologia da Web que utiliza os mesmos princípios é Web Workers.

%}}}
\section{Web Workers}
%{{{

É uma API que possibilita executar vários scripts
(\textit{threads}) JavaScript ao mesmo tempo. O script que cria uma
thread é chamado de pai da thread, e a comunicação entre pai e filhos
pode acontecer de ambos os lados através de mensagem encapsuladas
em eventos. Um script que não seja pai de uma thread não pode se
comunicar com ela, a não ser que a thread esteja em modo compartilhado.

O contexto global (objeto \textit{window}) não existe em uma
thread, no seu lugar o objeto \textit{DedicatedWorkerGlobalScope}
pode ser utilizado. Workers compartilhados podem utilizar o
\textit{SharedWorkerGlobalScope}. Estes objetos contém grande parte das
funcionalidades proporcionadas pelo window com algumas exceções, por
exemplo, threads não podem fazer alterações no DOM.

%}}}
\section{Offline}
%{{{
Disponibilizar aplicações Web offline é uma característica
introduzida no HTML5. Uma nova gama de aplicativos Web foram
possibilitados devido as tecnologias offline. A importância de gestão
offline é tanta em alguns nichos que os avaliadores do mercado
de software do IOs consideram quase uma obrigação realizar gestão 
offline nas aplicações \textsc{\autocite{publishHtml5}}.

Jogos de usuário único podem se beneficiar enormemente de aplicativos
offline, tornando possível utilizar a aplicação com ou sem a
presença de rede. Para tanto é necessário poder armazenar dados
locais, tecnologias como IndexedDB e Web Storage permitem isso. O outro
requerimento para estar offline é uma forma de armazenar os arquivos
da Web localmente, de forma que sejam utilizados quando não houver uma
conexão a rede.

HTML5 conta com uma especificação estável de APIs de cache offline
mantida pela W3C. Esta especificação determina que uma arquivo de
manifesto contenha quais arquivos serão guardados para utilização
offline e possivelmente quais serão usados pela rede. A figura
\ref{fig:offline} exemplifica um arquivo de manifesto. Os arquivos
abaixo da palavra \textit{CACHE MANIFEST} serão armazenados em cache e
não serão buscados na rede a não ser que o arquivo de manifesto seja
modificado. Já os arquivos abaixo da palavra \textit{NETWORK:} serão
utilizados exclusivamente com rede e serão buscados todas as vezes.
Ainda exite a palavra chave \textit{FALLBACK} onde todos os itens abaixo
dela serão utilizados para substituir arquivos de rede.

É uma boa prática colocar um comentário com a versão do arquivo de
manifestos. Desse modo quando um arquivo for modificado incrementa-se a
versão do arquivo de manifestos e as modificações serão baixadas nos
navegadores clientes.

\begin{figure}[H]
\centering
\begin{verbatim}
CACHE MANIFEST
index.html
help.html
style/default.css
images/logo.png
images/backgound.png

NETWORK:
server.cgi
\end{verbatim}
\caption{Exemplo de arquivo de manifesto offline}
\source{http://www.w3.org/TR/offline-webapps/}
\label{fig:offline}
\end{figure}

%}}}
\section{Entrada de Comandos}
%{{{
Na construção da grande maioria dos jogos é muitas vezes
imprescindível grande flexibilidade na gestão de entrada comandos.
Esta necessidade se amplia na criação de jogos multiplataforma, em
determinadas plataformas a entrada de comandos pode-se dar través de
teclado, em dispositivos móveis através tela sensível ou sensor de
movimentos. O HTML5 trata todos estes casos abstratamente na forma de
eventos, os quais podem ser escutados através de \textit{listeners}.
JavaScript pode ser configurado para escutar cada vez que um evento
ocorre seja um clique do mouse o pressionar de uma tecla ou o mover de
um eixo em um joystick.

Quando um evento de interação é disparado, um \textit{listener}
que esteja ouvindo a este evento pode invocar uma função e realizar
qualquer controle desejado \textsc{\autocite{buildingHtml5Game}}. O teclado é
um periférico comum no caso de jogos da Web, para existem os eventos
\textit{keyup} e \textit{keydown} que representam uma tecla sendo solta
e pressionada respectivamente. A \ref{fig:keyboardEvents} demostra a
captura do pressionar das setas em JavaScript. Cada número corresponde
a um botão do teclado especificado através da tabela ASCII.

\begin{figure}[H]
\centering
\begin{verbatim}
window.addEventListener('keydown', function(event) {
  switch (event.keyCode) {
    case 37: // Left
      Game.player.moveLeft();
    break;

    case 38: // Up
      Game.player.moveUp();
    break;

    case 39: // Right
      Game.player.moveRight();
    break;

    case 40: // Down
      Game.player.moveDown();
    break;
  }
}, false);
\end{verbatim}
\caption{Utilização dos eventos do teclado}
\label{fig:keyboardEvents}
\source{\url{http://nokarma.org/2011/02/27/javascript-game-development-keyboard-input/}}
\end{figure}

\subsection{Gamepad}

Atualmente a única forma de utilizar gamepads na Web é
através software de terceiros. E sua utilização é limitada
restringida a emulação de mouse e teclado subutilizando seus
recursos \textsc{\autocite{gamepad}}.

Em 2015 a W3C introduziu uma API de Gamepads, atualmente em rascunho,
que pretende solucionar estes problemas. A especificação define um
conjunto de eventos e um objeto \textit{Gamepad} que, em conjunto,
permitem manipular os estados de um Gamepad eficientemente.

Exitem eventos para atividades esporádicas como a conexão de
desconexão de dispositivos. Já acontecimentos mais frequentes, como o
pressionar de botões, é detectado através da inspeção dos objetos
aninhados ao objeto principal (\textit{Gamepad}). Cada objeto botão contém um 
atributo \textit{pressed} que pode ser utilizado para saber se foi pressionado.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth,natwidth=610,natheight=642]{gamepad.png}
    \caption{Objetos de um Gamepad}
    \label{fig:gamepad}
    \source{https://w3c.github.io/gamepad}
\end{figure}

A figura \ref{fig:gamepad} contém os objetos tradicionais de um Gamepad.

%}}}
\section{Orientação}
%{{{
Muitos dispositivos móveis contam com tecnologias que permitem detectar
a orientação física e movimento como acelerômetros e giroscópios.
Visto que são comuns em dispositivos móveis, jogos podem se beneficiar
deste tipo de ferramenta para criar experiências peculiares para seus
usuários. A W3C tem uma especificação em rascunho que abstrai as
diferenças dos dispositivos e prove uma API padronizada para consumir
informações de orientação. A especificação define dois eventos de
DOM principais: \textit{deviceorientation} e \textit{devicemotion}.

O evento \textit{deviceorientation} provê a orientação do
dispositivo expressa como uma série de rotações a partir de um
ponto de coordenadas locais \textsc{\autocite{orientationSpec}}. Para colocar
claramente, o evento lançado em uma mudança de orientação provê
variáveis correspondentes a eixos (alfa, beta, gama) que podem ser
consultadas para determinar a orientação do dispositivo.

Já o evento \textit{devicemotion} dispõe de informações de
orientação, como o evento \textit{deviceorientation}, com o adicional
de informar a aceleração do dispositivo. A aceleração também é
descrita em eixos e sua unidade de medida é metros por segundo.

%}}}
\section{HTTP/2}
%{{
HTTP/2 é a última verão do protocolo de trocas de documentos entre
cliente e servidor na Web. Quando um navegador requisita algum documento
de esta requisição é geralmente feita através do protocolo HTTP. O
foco da nova versão do HTTP é performance; especialmente a latência
percebida pelos usuários e o uso de rede e servidores \textsc{\autocite{http2}}.
A forma que os documentos trafegam do servidor para o cliente afeta
diretamente a performance de uma aplicação, nos jogos esse fator se
amplia devido a grande quantidade de arquivos geralmente necessários
para montar uma cena de jogo.

Diferentemente do HTTP/1, HTTP/2 abre apenas uma conexão por servidor.
Usando a mesma para trafegar todos os dados necessários para montar
a página HTML. Dessa forma o HTTP/2 não necessita repetir as
negociações de protocolo nem aguardar parado quando o limite de
requisições que os navegadores suportam concorrentemente é atingido.
Segundo \citet{gameAssetManagement} o limite concorrente de conexões
por servidor é geralmente 5. Jogos, que muitas vezes trafegam
muitos arquivos via rede, podem se beneficiar drasticamente desta
características.

Outro benefício do HTTP/2 em relação a seu predecessor é que
os cabeçalhos das requisições são comprimidos, diminuindo
substancialmente o tamanho das requisições. HTTP/2 também permite
mensagens do servidor para o cliente (\textit{full-duplex}), o
que abre um leque de novas oportunidades que antes só podiam ser
obtidas através de requisições de tempos em tempos ao servidor
(\textit{pooling}) ou através de WebSockets.

HTTP/2 não recomenda a utilização de minificação nos arquivos,
visto que não existe abertura de novas conexões, trafegar múltiplos
arquivos se tornou barato. Dessa forma, algumas práticas, antes
recomendadas no desenvolvimento Web, tem de ser revistas depois do
HTTP/2.

Dentro do navegador as requisições HTTP/2 não convertidas em
equivalentes do HTTP/1, mantendo a retrocompatibilidade em aplicações
legadas. Sendo assim, os fatores que justifiquem a utilização do HTTP/1
são escassos e a tendência é observarmos cada vez mais aplicações
utilizando com o HTTP/2.

%}}}
\section{Depuração}
%{{{

Depuração (\textit{debug}) é o processo de encontrar e
reduzir defeitos em um aplicativo de software ou mesmo hardware
\textsc{\autocite{depuracao}}. As ferramentas de desenvolvimento do Google Chrome
(\textit{DevTools}) são uma boa opção para depurar aplicações
feitas utilizando as tecnologias da Web. Dos depuradores para
navegadores o do Google Chrome é o mais fácil de utilizar e já vem
integrado nativamente junto com o software \textsc{\autocite{gamesDebug}}.

\noindent \citet{chromeDevTools} cita algumas funcionalidades do DevTools:
\begin{quote}
Provê aos desenvolvedores profundo acesso as camadas internas do
navegador e aplicações Web. É possível utilizar o DevTools
para eficientemente detectar problemas de layout, adicionar
\textit{breakpoints} em JavaScript, e pegar dicas de otimização de
código.
\end{quote}

Estas características são comuns na maioria dos depuradores dos
navegadores como o do Internet Explorer (Visual Studio For Web) e do
Firefox (FireBug) \textsc{\autocite{gamesDebug}}.

Todavia, com o DevTools também é possível emular dispositivos alvo da
aplicação ou conectar-se a um dispositivo Android real, ideal para
testar ambientes multiplataforma. Para conectar-se a um dispositivo real
é necessário habilitar a depuração via USB no dispositivo, conectar
o dispositivo via cabo, e rodar o aplicativo no dispositivo através
do Google Chrome ou habilitando o modo depuração nos aplicativos
híbridos. Dessa forma é possível visualizar a aplicação dentro
Google Chrome do computador e utilizar as já mencionadas tecnologias do
DevTools.

O DevTools costumava permitir depuração do elemento canvas. Sobre ele
\citet{html5mostwanted} mencionou: com o inspetor WebGl é possível
conferir os estados dos buffers, informações de texturas, frames
individuais e outras informações úteis. Infelizmente este recurso
foi removido e atualmente inspeção de canvas é um terreno escaço
no ambiente Web, mais detalhes sobre o problema dos depuradores canvas
serão tratados nos resultados.

Especificamente para WebGl existe o plugin independente WebGL Inspector.
A ferramenta permite fazer inspeção da execução de métodos
WebGL, observar o estado de texturas, buffers, controlar o tempo de
execução entre outras funcionalidades \footnote{Mais informações
sobre o WebGL Inspector podem ser encontradas no seguinte endereço
\url{http://benvanik.github.io/WebGL-Inspector/}}.

\subsection{Source Maps}

Source Maps é uma tecnologia que permite mapear códigos fontes
minificados para seus respectivos originais. Este recurso é
interessante pois permite que os desenvolvedores visualizem o código
fonte em sua versão original, legível e fácil de depurar, enquanto
entregam ao usuário final a versão minificada, otimizada para
performance. Para o usuário final não há diferença pois Source Maps
são carregados apenas se as ferramentas de desenvolvimento estão
abertas e com a funcionalidade de Source Maps habilitada.

Source Maps foi desenvolvido como um trabalho em conjunto entre a
Mozilla e Google em 2010, atualmente na terceira revisão o projeto é
considerado estável e não recebe modificações na especificação
desde 2013. Sendo suportado por diversas ferramentas de desenvolvimento
como Google Chrome (DevTools) e Firefox.

A especificação prevê a existência de um arquivo \textit{.map} o
qual contém o mapeamento dos arquivos fonte e outros metadados. Este
arquivo é referenciado pelos arquivos minificados de modo a permitirem
o navegador a realizar o mapeamento. É possível informar o navegador a
localização do arquivo de metadados seguindo a seguinte sintaxe:

\begin{verbatim}
//# sourceMappingURL=/path/to/script.JavaScript.map
\end{verbatim}

Ou através de cabeçalhos HTTP como demostrado abaixo.

\begin{verbatim}
X-SourceMap: /path/to/script.JavaScript.map
\end{verbatim}

Para criar arquivos de Source Maps é possível utilizar ferramentas
especializadas ou integrá-los ao processo de \textit{build} como Grunt
ou Gulp. A biblioteca \url{https://github.com/mishoo/UglifyJS2} é uma
ferramenta de minificação capaz de gerar Source Maps. Após ter o jogo
ter sido depurado e seus erros minimizados, pode-se disponibilizar para
ser consumido por seus usuários finais.

Abaixo serão abordadas algumas formas de disponibilizar jogos Web em
ambientes multiplataforma.
%}}}
%}}}
\section{Disponibilização da Aplicação}\label{disponibilization}
%{{{

Os aplicativos puramente em HTML não requerem instalação e
funcionam apenas acessando o endereço através de um navegador.
\citet{browserGamesTechnologyAndFuture} cita à respeito de
aplicações Web "por não requererem instalação, sua distribuição é
superior ao estilo convencional de aplicações desktop".

Conquanto, se o objetivo é fornecer uma experiência similar aos
demais aplicativos mobile ou integrar um sistema de compras, geralmente
feitos através de um mercado como o GooglePlay, pode-se adotar a
alternativa híbrida criando um pacote para o software.

O PhoneGap é uma tecnologia que permite encapsular um código em
HTML e disponibilizá-lo nativamente. Não obstante, para empacotar
os aplicativos localmente é necessária configuração substancial
e só é possível empacotar para IOS em um computador da Apple.
Alternativamente, o PhoneGap disponibiliza um serviço de empacotamento
na nuvem que soluciona estes problemas o PhoneGap Build.

Através do PhoneGap Build pode-se carregar um arquivo zip, seguindo
determinado formato, o qual contenha os arquivos escritos com as
ferramentas da web, que o PhoneGap Build se responsabiliza por
empacotá-los nos formatos requeridos para serem instalados em Android,
IOS e Windows Phone.

\begin{figure}[H]
    \centering
    \includegraphics[width=15cm]{phonegapBuild.png}
    \caption{Protótipo no PhoneGap Build}
    \source{https://build.phonegap.com/apps}
\end{figure}

\citet{publishHtml5} descreve os passos que são feitos pelo PhoneGap Build para
disponibilizar a aplicação nativamente:

\begin{itemize}
\item É criada uma aplicação nativa utilizando a WebView da plataforma;
\item Todos os recursos da aplicação são armazenados dentro da aplicação nativa;
\item O PhoneGap carrega o HTML dentro da WebView;
\item A WebView mostra a aplicação para o usuário;
\end{itemize}

No endereço \url{https://github.com/phonegap/phonegap-start}
encontra-se um \textit{template} no formato requerido pelo PhoneGap
Build que pode ser utilizado para começar aplicações que serão
servidas através da solução.

Além do PhoneGap existem outras formas de empacotar aplicações
para múltiplas plataformas. Por exemplo, através de plataformas de
desenvolvimento como o Sencha Touch e Ionic, AppGyver ou Xamarin.
Entretanto, estas plataformas muitas vezes utilizam o PhoneGap
internamente ou, apesar de criar aplicações para Web, não comportam o
desenvolvimento com tecnologias da Web.
%}}}
